src\App.tsx:
// src/App.tsx
import { RouterProvider } from 'react-router-dom';
import { ConfigProvider, theme as antdTheme, Spin } from 'antd';
import { HelmetProvider } from 'react-helmet-async';
import { StylesContext } from './context';
import routes from './routes/routes.tsx';
import { useSelector, useDispatch } from 'react-redux';
import { RootState } from './redux/store';
import './App.css';
import { useEffect, useState } from 'react';
import { setUser } from './redux/userSlice';
import axiosInstance from './api/axiosInstance';

// Color palette (dùng để tham khảo)
const COLOR = {
  50: '#e0f1ff',
  100: '#b0d2ff',
  200: '#7fb0ff',
  300: '#4d8bff',
  400: '#1e79fe',
  500: '#076ee5',
  600: '#0062b3',
  700: '#004f81',
  800: '#003650',
  900: '#001620',
  borderColor: '#E7EAF3B2',
};

function App() {
  const { mytheme } = useSelector((state: RootState) => state.theme);
  const dispatch = useDispatch();
  // isAuthLoading: trạng thái đang load thông tin user
  // authChecked: cờ báo rằng quá trình kiểm tra xác thực đã xong (để tránh re-render không cần thiết)
  const [isAuthLoading, setIsAuthLoading] = useState(true);
  const [authChecked, setAuthChecked] = useState(false);

  useEffect(() => {
    // Kiểm tra xem URL có chứa accessToken (ví dụ: khi chuyển hướng từ OAuth)
    const accessTokenFromUrl = new URLSearchParams(window.location.search).get('accessToken');
    let accessToken = localStorage.getItem('accessToken');

    if (accessTokenFromUrl) {
      accessToken = accessTokenFromUrl;
      localStorage.setItem('accessToken', accessToken);
      window.history.replaceState({}, document.title, '/dashboards/general');
    }

    const checkAuth = async () => {
      if (accessToken) {
        try {
          // Gọi API lấy thông tin user
          const response = await axiosInstance.get('/users/profile');
          const userProfile = (response.data as { data: { user: any } }).data.user;
          dispatch(setUser(userProfile));
          localStorage.setItem('user', JSON.stringify(userProfile));
        } catch (error) {
          console.error('Failed to fetch user profile:', error);
          localStorage.removeItem('user');
        } finally {
          setIsAuthLoading(false);
          setAuthChecked(true);
        }
      } else {
        localStorage.removeItem('user');
        setIsAuthLoading(false);
        setAuthChecked(true);
      }
    };

    checkAuth();
  }, [dispatch]);

  // Nếu chưa kiểm tra xong authentication, hiển thị spinner (hoặc có thể là trang trắng)
  if (!authChecked || isAuthLoading) {
    return (
      <div style={{ display: 'flex', justifyContent:'center', alignItems:'center', height:'100vh' }}>
        <Spin size="large" tip="Loading..." />
      </div>
    );
  }

  return (
    <HelmetProvider>
      <ConfigProvider
        theme={{
          token: {
            colorPrimary: COLOR['500'],
            borderRadius: 6,
            fontFamily: 'Lato, sans-serif',
          },
          components: {
            Breadcrumb: {},
            Button: {
              colorLink: COLOR['500'],
              colorLinkActive: COLOR['700'],
              colorLinkHover: COLOR['300'],
            },
            Calendar: {
              colorBgContainer: 'none',
            },
            Card: {
              colorBorderSecondary: COLOR['borderColor'],
            },
            Carousel: {
              colorBgContainer: COLOR['800'],
              dotWidth: 8,
            },
            Rate: {
              colorFillContent: COLOR['100'],
              colorText: COLOR['600'],
            },
            Segmented: {
              colorBgLayout: COLOR['100'],
              borderRadius: 6,
              colorTextLabel: '#000000',
            },
            Table: {
              borderColor: COLOR['100'],
              colorBgContainer: 'none',
              headerBg: 'none',
              rowHoverBg: COLOR['50'],
            },
            Tabs: {
              colorBorderSecondary: COLOR['100'],
            },
            Timeline: {
              dotBg: 'none',
            },
            Typography: {
              colorLink: COLOR['500'],
              colorLinkActive: COLOR['700'],
              colorLinkHover: COLOR['300'],
              linkHoverDecoration: 'underline',
            },
          },
          algorithm:
            mytheme === 'dark'
              ? antdTheme.darkAlgorithm
              : antdTheme.defaultAlgorithm,
        }}
      >
        <StylesContext.Provider
          value={{
            rowProps: {
              gutter: [
                { xs: 8, sm: 16, md: 24, lg: 32 },
                { xs: 8, sm: 16, md: 24, lg: 32 },
              ],
            },
            carouselProps: {
              autoplay: true,
              dots: true,
              dotPosition: 'bottom',
              infinite: true,
              slidesToShow: 3,
              slidesToScroll: 1,
            },
          }}
        >
          <RouterProvider router={routes} />
        </StylesContext.Provider>
      </ConfigProvider>
    </HelmetProvider>
  );
}

export default App;
export { COLOR };


src\index.css:
:root {
  font-family: 'Lato', sans-serif;
}

body {
  margin: 0;
}


src\main.tsx:
// src\main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';
import { store, persistor } from './redux/store.ts';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';

ReactDOM.createRoot(document.getElementById('root')!).render(
  // <React.StrictMode>
    <PersistGate persistor={persistor}>
      <Provider store={store}>
        <App />
      </Provider>
    </PersistGate>
    ,
  // </React.StrictMode>
);


src\vite-env.d.ts:
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string;
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}


src\api\axiosInstance.ts:
// src\api\axiosInstance.ts:
// src/api/axiosInstance.ts
import axios from 'axios';
import { store } from '../redux/store';
import { setUser } from '../redux/userSlice';

const baseURL = 'http://localhost:8080/api/v1'; // Sử dụng biến môi trường hoặc giá trị mặc định

const axiosInstance = axios.create({
  baseURL: baseURL,
  withCredentials: true, 
});

axiosInstance.interceptors.request.use(
  (config) => {
    const accessToken = localStorage.getItem('accessToken');
    if (accessToken && config.headers) {
      config.headers['Authorization'] = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => {
    console.error('Interceptor Request Error:', error);
    return Promise.reject(error);
  }
);

axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && (error.response.data?.message === "Invalid token" || error.response.data?.error === "Unauthorized") && !originalRequest._retry) {
      originalRequest._retry = true;
      console.log("Interceptor Response: 401 Error intercepted, attempting refresh token...");

      try {
        console.log("Interceptor Response: Calling refresh token API...");
        const refreshTokenResponse = await axios.post(`${baseURL}/auth/refresh`, {}, { withCredentials: true });

        if (refreshTokenResponse.status === 200) {
          const newAccessToken = (refreshTokenResponse.data as { data: { accessToken: string, user: any } }).data.accessToken;
          const user = (refreshTokenResponse.data as { data: { accessToken: string, user: any } }).data.user;

          localStorage.setItem('accessToken', newAccessToken);
          localStorage.setItem('user', JSON.stringify(user));
          store.dispatch(setUser(user));

          originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
          console.log("Interceptor Response: Refresh token successful, retrying original request.");
          return axiosInstance(originalRequest); // Retry request with new token
        } else {
          // Refresh token API trả về lỗi (non-200 status)
          console.log("Interceptor Response: Refresh token failed (non-200 status), redirecting to login");
          localStorage.removeItem('accessToken');
          localStorage.removeItem('user');
          window.location.href = '/auth/signin';
          return Promise.reject(error); // Logout và reject lỗi ban đầu
        }
      } catch (refreshError) {
        // Lỗi trong quá trình gọi refresh token API (ví dụ: network error)
        console.error("Interceptor Response: Error during refresh token process:", refreshError);
        localStorage.removeItem('accessToken');
        localStorage.removeItem('user');
        window.location.href = '/auth/signin';
        return Promise.reject(refreshError); // Logout và reject lỗi refresh token
      }
    }

    // Nếu không phải lỗi 401 hoặc đã retry refresh token rồi thì reject lỗi ban đầu
    return Promise.reject(error);
  }
);

export default axiosInstance;


src\components\CreateGuestModal.tsx:
// src\components\CreateGuestModal.tsx
import React, { useState } from 'react';
import { Modal, Form, Input, Button, message, Spin } from 'antd';
import authService from '../services/authService';

interface CreateGuestModalProps {
  visible: boolean;
  onCancel: () => void;
  onCreated: (newGuest: any) => void; // Callback khi guest được tạo thành công
}

const CreateGuestModal: React.FC<CreateGuestModalProps> = ({ visible, onCancel, onCreated }) => {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);

  const handleOk = () => {
    form.submit();
  };

  const handleCancel = () => {
    onCancel();
    form.resetFields(); // Reset form khi cancel
  };

  const onFinish = async (values: any) => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('Bạn chưa đăng nhập.');
        return;
      }
      const response = await authService.createGuest(values, accessToken) as any;
      if (response.statusCode === 201 && response.data.guest) {
        message.success('Guest created successfully!');
        onCreated(response.data.guest); // Gọi callback và truyền guest mới
        handleCancel(); // Đóng modal và reset form
      } else {
        message.error(response.message || 'Failed to create guest');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to create guest');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  return (
    <Modal
      title="Create New Guest"
      visible={visible}
      onOk={handleOk}
      onCancel={handleCancel}
      confirmLoading={loading}
      destroyOnClose
    >
      <Form
        form={form}
        layout="vertical"
        name="create-guest-form"
        onFinish={onFinish}
        onFinishFailed={onFinishFailed}
        autoComplete="off"
        requiredMark={false}
      >
        <Form.Item
          label="Name"
          name="name"
          rules={[{ required: true, message: 'Please input guest name!' }]}
        >
          <Input placeholder="Guest Name" />
        </Form.Item>
        <Form.Item
          label="Job Title"
          name="jobTitle"
          rules={[{ required: true, message: 'Please input job title!' }]}
        >
          <Input placeholder="Job Title" />
        </Form.Item>
        <Form.Item
          label="Organization"
          name="organization"
          rules={[{ required: true, message: 'Please input organization!' }]}
        >
          <Input placeholder="Organization" />
        </Form.Item>
        <Form.Item
          label="Social Link"
          name="linkSocial"
        >
          <Input placeholder="Social Link (Optional)" />
        </Form.Item>
      </Form>
    </Modal>
  );
};

export default CreateGuestModal;


src\components\CreateSpeakerModal.tsx:
// src\components\CreateSpeakerModal.tsx
import React, { useState } from 'react';
import { Modal, Form, Input, Button, message, Spin } from 'antd';
import authService from '../services/authService';

interface CreateSpeakerModalProps {
  visible: boolean;
  onCancel: () => void;
  onCreated: (newSpeaker: any) => void; // Callback khi speaker được tạo thành công
}

const CreateSpeakerModal: React.FC<CreateSpeakerModalProps> = ({ visible, onCancel, onCreated }) => {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);

  const handleOk = () => {
    form.submit();
  };

  const handleCancel = () => {
    onCancel();
    form.resetFields(); // Reset form khi cancel
  };

  const onFinish = async (values: any) => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('Bạn chưa đăng nhập.');
        return;
      }
      const response: any = await authService.createSpeaker(values, accessToken);
      console.log('response', response);
      if (response.statusCode === 201 && response.data.speaker) {
        message.success('Speaker created successfully!');
        onCreated(response.data.speaker); // Gọi callback và truyền speaker mới
        handleCancel(); // Đóng modal và reset form
      } else {
        message.error(response.message || 'Failed to create speaker');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to create speaker');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  return (
    <Modal
      title="Create New Speaker"
      visible={visible}
      onOk={handleOk}
      onCancel={handleCancel}
      confirmLoading={loading}
      destroyOnClose
    >
      <Form
        form={form}
        layout="vertical"
        name="create-speaker-form"
        onFinish={onFinish}
        onFinishFailed={onFinishFailed}
        autoComplete="off"
        requiredMark={false}
      >
        <Form.Item
          label="Name"
          name="name"
          rules={[{ required: true, message: 'Please input speaker name!' }]}
        >
          <Input placeholder="Speaker Name" />
        </Form.Item>
        <Form.Item
          label="Job Title"
          name="jobTitle"
          rules={[{ required: true, message: 'Please input job title!' }]}
        >
          <Input placeholder="Job Title" />
        </Form.Item>
        <Form.Item
          label="Email"
          name="email"
          rules={[
            { required: true, message: 'Please input Email!' },
            { type: 'email', message: 'Please enter a valid email!' },
          ]}
        >
          <Input placeholder="Email" />
        </Form.Item>
        <Form.Item
          label="Bio"
          name="bio"
        >
          <Input.TextArea rows={4} placeholder="Bio (Optional)" />
        </Form.Item>
      </Form>
    </Modal>
  );
};

export default CreateSpeakerModal;


src\components\EventDiscussion.tsx:
// src/components/EventDiscussion.tsx
import React, { useState, useEffect } from 'react';
import { List, Card, Input, Button, message, Avatar, Typography, Form, Spin, Collapse, Flex } from 'antd';
import authService from '../services/authService';
import { UserOutlined } from '@ant-design/icons';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { Answer, Question } from '../types';

interface EventDiscussionProps {
  eventId: string;
  questions: Question[];
  setQuestions: React.Dispatch<React.SetStateAction<Question[]>>;
}

const { Text, Paragraph } = Typography;
const { Panel } = Collapse;

interface UserInfo {
  name: string;
  avatar: string;
}

const EventDiscussion: React.FC<EventDiscussionProps> = ({ eventId, questions, setQuestions }) => {
  const [questionInput, setQuestionInput] = useState('');
  const [answerInput, setAnswerInput] = useState('');
  const [activeAnswerQuestionId, setActiveAnswerQuestionId] = useState<string | null>(null);
  const [loadingQuestions, setLoadingQuestions] = useState(false);
  const [submittingQuestion, setSubmittingQuestion] = useState(false);
  const [submittingAnswer, setSubmittingAnswer] = useState(false);
  // State lưu thông tin của người dùng theo dạng: userId -> { name, avatar }
  const [userInfos, setUserInfos] = useState<Record<string, UserInfo>>({});
  const user = useSelector((state: RootState) => state.user);

  useEffect(() => {
    const fetchQuestionsAndUserInfos = async () => {
      setLoadingQuestions(true);
      try {
        const response = await authService.getEventQuestions(eventId) as {
          statusCode: number,
          data: { questions: Question[] },
          message?: string
        };
        if (response.statusCode === 200 && response.data.questions) {
          setQuestions(response.data.questions || []);
          // Lấy danh sách userId từ các câu hỏi và câu trả lời
          const allUserIds = new Set<string>();
          if (Array.isArray(response.data.questions)) {
            response.data.questions.forEach((q: Question) => {
              allUserIds.add(q.userId);
              if (Array.isArray(q.answers)) {
                q.answers.forEach((a: Answer) => allUserIds.add(a.userId));
              }
            });
          }
          fetchUserInfos(Array.from(allUserIds));
        } else {
          setQuestions([]);
        }
      } catch (error: any) {
        setQuestions([]);
      } finally {
        setLoadingQuestions(false);
      }
    };

    fetchQuestionsAndUserInfos();
  }, [eventId, setQuestions]);

  const fetchUserInfos = async (userIds: string[]) => {
    const infosMap: Record<string, UserInfo> = {};
    for (const userId of userIds) {
      try {
        const response = await authService.getUserById(userId) as {
          statusCode: number,
          data: {
            id: string,
            email: string,
            name: string,
            avatar: string,
            lastLoginAt: string,
            createdAt: string,
            updatedAt: string
          }
        };
        if (response.statusCode === 200 && response.data) {
          infosMap[userId] = { name: response.data.name, avatar: response.data.avatar };
        } else {
          infosMap[userId] = { name: 'Unknown User', avatar: '' };
        }
      } catch (error) {
        infosMap[userId] = { name: 'Unknown User', avatar: '' };
        console.error(`Failed to fetch user info for ${userId}`, error);
      }
    }
    setUserInfos(prevInfos => ({ ...prevInfos, ...infosMap }));
  };

  const handleQuestionSubmit = async () => {
    if (!questionInput.trim()) return;
    setSubmittingQuestion(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('You need to login to ask a question.');
        return;
      }
      const response = await authService.postQuestion(eventId, questionInput, accessToken) as {
        statusCode: number,
        data: { question: Question },
        message?: string
      };
      if (response.statusCode === 201) {
        message.success('Question submitted successfully!');
        setQuestionInput('');
        setQuestions([response.data.question, ...questions]);
        // Fetch thêm thông tin của người hỏi nếu cần
        fetchUserInfos([response.data.question.userId]);
      } else {
        message.error(response.message || 'Failed to submit question');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to submit question');
    } finally {
      setSubmittingQuestion(false);
    }
  };

  const handleAnswerSubmit = async (questionId: string) => {
    if (!answerInput.trim() || !questionId) return;
    setSubmittingAnswer(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('You need to login to submit an answer.');
        return;
      }
      const response = await authService.postAnswer(questionId, answerInput, accessToken) as {
        statusCode: number,
        data: { question: Question },
        message?: string
      };
      if (response.statusCode === 201) {
        message.success('Answer submitted successfully!');
        setAnswerInput('');
        setActiveAnswerQuestionId(null);
        const updatedQuestions = questions.map(q =>
          q.id === questionId ? response.data.question : q
        );
        setQuestions(updatedQuestions);
        // Fetch thông tin của người vừa trả lời
        const lastAnswer = response.data.question.answers[response.data.question.answers.length - 1];
        fetchUserInfos([lastAnswer.userId]);
      } else {
        message.error(response.message || 'Failed to submit answer');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to submit answer');
    } finally {
      setSubmittingAnswer(false);
    }
  };

  return (
    <Card title="Event Discussion" style={{ marginBottom: '20px' }}>
      {loadingQuestions ? (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <Spin tip="Loading..." />
        </div>
      ) : (
        <List
          dataSource={questions}
          itemLayout="vertical"
          renderItem={(question) => (
            <List.Item
              key={question.id}
              style={{
                flexDirection: 'column',
                alignItems: 'flex-start',
                marginBottom: '20px',
                borderBottom: '1px dashed #e8e8e8',
                paddingBottom: '20px'
              }}
            >
              <List.Item.Meta
                avatar={
                  <Avatar
                    src={userInfos[question.userId]?.avatar}
                    icon={!userInfos[question.userId]?.avatar ? <UserOutlined /> : undefined}
                  />
                }
                title={
                  <Text strong>
                    {userInfos[question.userId]?.name || 'Loading Name...'}
                  </Text>
                }
                description={<Paragraph style={{ margin: 0 }}>{question.text}</Paragraph>}
              />

              <Collapse bordered={false} defaultActiveKey={['1']} style={{ width: '100%', marginTop: '10px' }}>
                <Panel header={`Answers (${question.answers ? question.answers.length : 0})`} key="1" style={{ borderBottom: 'none' }}>
                  <List
                    className="answer-list"
                    dataSource={question.answers || []}
                    renderItem={(answer: Answer) => (
                      <List.Item
                        style={{
                          border: '1px solid #f0f0f0',
                          borderRadius: '5px',
                          padding: '10px',
                          marginBottom: '8px',
                          backgroundColor: '#fafafa'
                        }}
                      >
                        <List.Item.Meta
                          avatar={
                            <Avatar
                              src={userInfos[answer.userId]?.avatar}
                              icon={!userInfos[answer.userId]?.avatar ? <UserOutlined /> : undefined}
                            />
                          }
                          title={<Text strong>{userInfos[answer.userId]?.name || 'Loading Name...'}</Text>}
                          description={<Paragraph style={{ margin: 0 }}>{answer.text}</Paragraph>}
                        />
                      </List.Item>
                    )}
                  />
                </Panel>
              </Collapse>

              <Button
                type="dashed"
                onClick={() => setActiveAnswerQuestionId(question.id)}
                style={{ marginTop: 16, marginBottom: 8, textAlign: 'left' }}
              >
                Answer
              </Button>
              {activeAnswerQuestionId === question.id && (
                <Form.Item style={{ width: '100%' }}>
                  <Input.TextArea
                    rows={2}
                    placeholder="Your answer..."
                    value={answerInput}
                    onChange={(e) => setAnswerInput(e.target.value)}
                    onPressEnter={() => handleAnswerSubmit(question.id)}
                  />
                  <Flex justify="end" gap="small" style={{ marginTop: '10px' }}>
                    <Button
                      type="primary"
                      onClick={() => handleAnswerSubmit(question.id)}
                      loading={submittingAnswer}
                    >
                      Submit
                    </Button>
                    <Button onClick={() => setActiveAnswerQuestionId(null)}>
                      Cancel
                    </Button>
                  </Flex>
                </Form.Item>
              )}
            </List.Item>
          )}
          footer={
            <Form.Item>
              <Input
                placeholder="Your question..."
                value={questionInput}
                onChange={(e) => setQuestionInput(e.target.value)}
                onPressEnter={handleQuestionSubmit}
              />
              <Button
                type="primary"
                onClick={handleQuestionSubmit}
                loading={submittingQuestion}
                style={{ marginTop: '10px' }}
              >
                Submit Question
              </Button>
            </Form.Item>
          }
        />
      )}
    </Card>
  );
};

export default EventDiscussion;


src\components\GoogleLoginButton.tsx:
// src/components/GoogleLoginButton.tsx
import React from 'react';
import { Button } from 'antd';
import { GoogleOutlined } from '@ant-design/icons';

const GoogleLoginButton: React.FC<any> = ({
}) => {
    const handleGoogleLogin = async () => {
        // Chuyển hướng người dùng đến backend endpoint login google
        window.location.href = 'http://localhost:8080/api/v1/auth/google/login';
    };

    return (
        <Button icon={<GoogleOutlined />} onClick={handleGoogleLogin}>
            Sign in with Google
        </Button>
    );
};

export default GoogleLoginButton;


src\components\index.ts:
export * from './Nprogress';
export * from './dashboard';
export * from './Container';
export * from './CreateGuestModal';
export * from './CreateSpeakerModal';
export { BackBtn } from './BackBtn/BackBtn.tsx';
export { Card } from './Card/Card';
export { ContactForm } from './ContactForm/ContactForm';
export { EmployeeCard } from './EmployeeCard/EmployeeCard';
export { FaqCollapse } from './FaqCollapse/FaqCollapse';
export { Flex } from './Flex/Flex';
export { Loader } from './Loader/Loader';
export { Logo } from './Logo/Logo';
export { MoreMenu } from './MoreMenu/MoreMenu';
export { NotificationsCard } from './NotificationsCard/NotificationsCard';
export { NotificationsItem } from './NotificationsItem/NotificationsItem';
export { PageHeader } from './PageHeader/PageHeader';
export { PricingTable } from './PricingTable/PricingTable';
export { RefreshBtn } from './RefreshBtn/RefreshBtn.tsx';
export { SitemapCard } from './SitemapCard/SitemapCard';
export { SocialMediaCard } from './SocialMediaCard/SocialMediaCard';
export { TimelineCard } from './TimelineCard/TimelineCard';
export { UserAvatar } from './UserAvatar/UserAvatar';


src\components\InviteUsersModal.tsx:
// src\components\InviteUsersModal.tsx
import React, { useState, useEffect } from 'react';
import { Modal, Button, List, Checkbox, Avatar, message, Spin, Alert } from 'antd';
import { UserOutlined } from '@ant-design/icons';
import axiosInstance from '../api/axiosInstance';

interface User {
    id: string;
    email: string;
    name: string;
    avatar?: string;
}

interface InviteUsersModalProps {
    visible: boolean;
    onCancel: () => void;
    eventId: string;
    onInvitationsSent: () => void; // Callback khi gửi lời mời thành công
}

const InviteUsersModal: React.FC<InviteUsersModalProps> = ({ visible, onCancel, eventId, onInvitationsSent }) => {
    const [users, setUsers] = useState<User[]>([]);
    const [selectedUserIds, setSelectedUserIds] = useState<string[]>([]);
    const [loadingUsers, setLoadingUsers] = useState(false);
    const [inviting, setInviting] = useState(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchUsers = async () => {
            setLoadingUsers(true);
            setError(null);
            try {
                const response = await axiosInstance.get('/users');
                const data = response.data as { statusCode: number; data: { users: User[] } };
                if (data.statusCode === 200) {
                    setUsers(data.data.users);
                } else {
                    setError('Failed to load users.');
                    message.error('Failed to load users.');
                }
            } catch (error: any) {
                setError(error.message || 'Failed to load users.');
                message.error(error.message || 'Failed to load users.');
            } finally {
                setLoadingUsers(false);
            }
        };

        if (visible) {
            fetchUsers();
            setSelectedUserIds([]); // Reset selected users khi modal mở
        }
    }, [visible]);

    const handleCheckboxChange = (userId: string, checked: boolean) => {
        if (checked) {
            setSelectedUserIds([...selectedUserIds, userId]);
        } else {
            setSelectedUserIds(selectedUserIds.filter(id => id !== userId));
        }
    };

    const handleInviteUsers = async () => {
        if (selectedUserIds.length === 0) {
            message.warning('Please select users to invite.');
            return;
        }

        setInviting(true);
        setError(null);
        try {
            const usersToInvite = selectedUserIds.map(id => {
                const user = users.find(u => u.id === id);
                return { id: user?.id, email: user?.email };
            });

            const response = await axiosInstance.post(`/events/${eventId}/invite`, { users: usersToInvite });
            const responseData = response.data as { statusCode: number; message: string };
            if (responseData.statusCode === 201) {
                console.log("Before message.success: Invitations sent successfully!");
                message.success((response.data as { message: string }).message);
                onInvitationsSent();
                onCancel();
            } else {
                // **Lấy message lỗi từ responseData (nếu có)**
                const errorMessage = responseData.message || 'Failed to send invitations.';
                setError(errorMessage);
                message.error(errorMessage);
            }
        } catch (error: any) {
            // **Lấy message lỗi từ error.response.data (thêm vào)**
            const errorMessage = error.response?.data?.message || error.message || 'Failed to send invitations.';
            setError(errorMessage);
            message.error(errorMessage);
        } finally {
            setInviting(false);
        }
    };

    return (
        <Modal
            title="Invite Users"
            visible={visible}
            onCancel={onCancel}
            footer={[
                <Button key="cancel" onClick={onCancel}>
                    Cancel
                </Button>,
                <Button key="invite" type="primary" onClick={handleInviteUsers} loading={inviting}>
                    Invite
                </Button>,
            ]}
        >
            {error && <Alert message="Error" description={error} type="error" showIcon style={{ marginBottom: 16 }} />}
            {loadingUsers ? (
                <div style={{ textAlign: 'center' }}>
                    <Spin tip="Loading Users..." />
                </div>
            ) : (
                <List
                    dataSource={users}
                    renderItem={(user) => (
                        <List.Item>
                            <List.Item.Meta
                                avatar={<Avatar icon={<UserOutlined />} src={user.avatar} />}
                                title={user.name}
                                description={user.email}
                            />
                            <Checkbox
                                value={user.id}
                                onChange={(e) => handleCheckboxChange(user.id, e.target.checked)}
                            />
                        </List.Item>
                    )}
                />
            )}
        </Modal>
    );
};

export default InviteUsersModal;

src\components\oauth2-pkce.ts:
// src\components\oauth2-pkce.ts
import * as CryptoJS from 'crypto-js';

export function generateCodeVerifier(): string {
  const randomBytes = CryptoJS.lib.WordArray.random(32);
  return CryptoJS.enc.Base64url.stringify(randomBytes);
}

export async function generateCodeChallenge(codeVerifier: string): Promise<string> {
  const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier));
  return base64urlencode(digest);
}

function base64urlencode(arrayBuffer: ArrayBuffer): string {
  let base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
  return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

src\components\ProtectedRoute.tsx:
// src/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const user = useSelector((state: RootState) => state.user);
  const location = useLocation();

  // Nếu chưa có thông tin user (chưa đăng nhập), chuyển hướng về trang đăng nhập
  if (!user || !user.id) {
    return (
      <Navigate
        to="/auth/signin"
        replace
        state={{ from: location.pathname + location.search }}
      />
    );
  }

  return children;
};

export default ProtectedRoute;


src\components\TicketDetailsModal.tsx:
// src\components\TicketDetailsModal.tsx
import React from 'react';
import { Modal, Typography, Flex, Button, Spin } from 'antd';
import QRCode from 'qrcode.react';
import { TicketType } from '../types'; // Assuming you have this interface defined
import dayjs from 'dayjs';

interface TicketDetailsModalProps {
    ticket: TicketType | null;
    visible: boolean;
    onCancel: () => void;
}

const TicketDetailsModal: React.FC<TicketDetailsModalProps> = ({ ticket, visible, onCancel }) => {
    if (!ticket) return null;

    return (
        <Modal
            title="Your Event Ticket"
            visible={visible}
            onCancel={onCancel}
            footer={[
                <Button key="back" onClick={onCancel}>
                    Close
                </Button>,
            ]}
        >
            <Flex vertical gap="middle">
                <Typography.Title level={4}>{ticket.id ? `Ticket ID: ${ticket.id}` : 'Ticket Information'}</Typography.Title>
                <Typography.Text>Participant ID: {ticket.participantId}</Typography.Text>
                <Typography.Text>Status: {ticket.status}</Typography.Text>
                {ticket.usedAt && <Typography.Text>Used At: {dayjs(ticket.usedAt).format('YYYY-MM-DD HH:mm:ss')}</Typography.Text>}

                <Typography.Title level={5}>QR Code</Typography.Title>
                <Flex justify="center">
                    {ticket.qrCodeUrl && (
                        <QRCode value={ticket.qrCodeUrl} size={200} level="H" />
                    )}
                </Flex>
            </Flex>
        </Modal>
    );
};

export default TicketDetailsModal;


src\components\BackBtn\BackBtn.tsx:
import { useNavigate } from 'react-router-dom';
import { Button, ButtonProps, Tooltip } from 'antd';
import { LeftOutlined } from '@ant-design/icons';

type Props = {
  wIcon?: boolean;
  iconOnly?: boolean;
} & ButtonProps;

export const BackBtn = ({ wIcon, iconOnly, ...others }: Props) => {
  const navigate = useNavigate();

  return (
    <Tooltip title="Navigate to previous page">
      <Button
        icon={wIcon || iconOnly ? <LeftOutlined /> : null}
        onClick={() => navigate(-1)}
        {...others}
      >
        {!iconOnly && 'Go back'}
      </Button>
    </Tooltip>
  );
};


src\components\Card\Card.tsx:
import { Card as AntdCard, CardProps } from 'antd';
import { ReactNode } from 'react';

import './styles.css';

type Props = { children: ReactNode } & CardProps;

export const Card = ({ children, ...others }: Props) => {
  return (
    <AntdCard className="card" {...others}>
      {children}
    </AntdCard>
  );
};


src\components\Card\styles.css:
/* Glassmorphism card effect */
.card {
  /*backdrop-filter: blur(16px) saturate(180%);*/
  /*-webkit-backdrop-filter: blur(16px) saturate(180%);*/
  /* background-color: rgba(255, 255, 255, 1); */
  /*border: 1px solid rgba(209, 213, 219, 0.3);*/
  -webkit-box-shadow: rgba(140, 152, 164, 0.075) 0 6px 12px 0;
  -moz-box-shadow: rgba(140, 152, 164, 0.075) 0 6px 12px 0;
  box-shadow: rgba(140, 152, 164, 0.075) 0 6px 12px 0;
  border: 1px solid rgba(231, 234, 243, 0.7);
}

.card .ant-card-head-title {
  text-transform: capitalize;
}


src\components\ContactForm\ContactForm.tsx:
import { Button, Col, Form, FormProps, Input, Row } from 'antd';
import { SendOutlined } from '@ant-design/icons';
import { useStylesContext } from '../../context';

const { TextArea } = Input;

type Props = FormProps;

export const ContactForm = ({ ...others }: Props) => {
  const stylesContext = useStylesContext();

  return (
    <div>
      <Form layout="vertical" {...others}>
        <Row {...stylesContext?.rowProps}>
          <Col sm={24} lg={12}>
            <Form.Item label="Name" tooltip="This is a required field">
              <Input />
            </Form.Item>
          </Col>
          <Col sm={24} lg={12}>
            <Form.Item label="Email" tooltip="This is a required field">
              <Input />
            </Form.Item>
          </Col>
        </Row>
        <Form.Item label="Subject" tooltip="This is a required field">
          <Input />
        </Form.Item>
        <Form.Item label="Message">
          <TextArea />
        </Form.Item>
        <Form.Item>
          <Button type="primary" icon={<SendOutlined />}>
            Submit
          </Button>
        </Form.Item>
      </Form>
    </div>
  );
};


src\components\Container\Container.tsx:
import {
  CSSProperties,
  HTMLProps,
  ReactNode,
  useEffect,
  useState,
} from 'react';
import { useMediaQuery } from 'react-responsive';

type ContainerProps = {
  children: ReactNode;
  style?: CSSProperties;
} & HTMLProps<HTMLDivElement>;

export const Container = ({ children, style, ...others }: ContainerProps) => {
  const [containerWidth, setContainerWidth] = useState<string>();
  const isMedium = useMediaQuery({ minWidth: 769 }),
    isLarge = useMediaQuery({ minWidth: 992 }),
    isXLarge = useMediaQuery({ minWidth: 1200 }),
    isXXLarge = useMediaQuery({ minWidth: 1400 });

  useEffect(() => {
    // sort from large to small devices
    if (isXXLarge) {
      setContainerWidth('1320px');
    } else if (isXLarge) {
      setContainerWidth('1140px');
    } else if (isLarge) {
      setContainerWidth('960px');
    } else if (isMedium) {
      setContainerWidth('720px');
    } else {
      setContainerWidth('100%');
    }
  }, [isLarge, isXLarge, isXXLarge, isMedium]);

  return (
    <div
      {...others}
      style={{
        width: containerWidth,
        margin: '0 auto',
        ...style,
      }}
    >
      {children}
    </div>
  );
};


src\components\Container\index.ts:
export { Container } from './Container.tsx';


src\components\dashboard\index.ts:
export {
  CampaignsCard,
  RecentUsersCard,
  GetStartedCard,
  OrdersChart,
  LatestOrdersCard,
  EarningsCard,
  SubscribersChart,
  WeeklyActivityCard,
  TasksChartCard,
  TasksListCard,
} from './default';
export { RevenueCard, PostsCard, ProjectsCard } from './shared';
export { CustomerReviewsCard } from './ecommerce';
export { ProjectsCountCard, ProjectsTable, ClientsTable } from './projects';
export {
  EventTable,
  EventTimelineCard,
  MyEventTimelineCard
} from './events';
export {
  UserTable
} from './users'; 


src\components\dashboard\default\index.ts:
export { CampaignsCard } from './CampaignsCard/CampaignsCard.tsx';
export { EarningsCard } from './EarningsCard/EarningsCard.tsx';
export { GetStartedCard } from './GetStartedCard/GetStartedCard.tsx';
export { LatestOrdersCard } from './LatestOrdersCard/LatestOrdersCard.tsx';
export { OrdersChart } from './OrdersChart/OrdersChart.tsx';
export { RecentUsersCard } from './RecentUsersCard/RecentUsersCard.tsx';
export { SubscribersChart } from './SubscribersChart/SubscribersChart.tsx';
export { WeeklyActivityCard } from './WeeklyActivityCard/WeeklyActivityCard.tsx';
export { TasksChartCard } from './TasksChartCard/TasksChartCard.tsx';
export { TasksListCard } from './TasksListCard/TasksListCard.tsx';
export { CategoriesChart } from './CategoriesChart/CategoriesChart.tsx';


src\components\dashboard\default\CampaignsCard\CampaignsCard.tsx:
import {
  Alert,
  Badge,
  Button,
  Card,
  CardProps,
  Space,
  Spin,
  Table,
  Tag,
  TagProps,
  theme,
  Typography,
} from 'antd';
import { ReactNode, useEffect, useState } from 'react';
import { CalendarOutlined, PlusOutlined } from '@ant-design/icons';
import { blue, green, orange } from '@ant-design/colors';
import CampaignsData from '../../../../../public/mocks/Campaigns.json';
import { Loader } from '../../../index.ts';

// socials - Facebook, Instagram, Twitter, LinkedIn
// target audience - men, women, young adults, parents
// statuses - active, inactive, pending, completed, cancelled

enum Status {
  Pending = 'pending',
  Inactive = 'inactive',
  Active = 'active',
  Cancelled = 'cancelled',
  Completed = 'completed',
}

const DATA_SOURCE = CampaignsData;

const COLUMNS = [
  {
    title: 'Name',
    dataIndex: 'campaign_name',
    key: 'name',
    render: (_: any) => <span className="text-capitalize">{_}</span>,
  },
  {
    title: 'Audience',
    dataIndex: 'target_audience',
    key: 'audience',
    render: (_: any) => <span className="text-capitalize">{_}</span>,
  },
  {
    title: 'Objective',
    dataIndex: 'campaign_objective',
    key: 'objective',
    render: (_: any) => <span className="text-capitalize">{_}</span>,
  },
  {
    title: 'Platform',
    dataIndex: 'platform',
    key: 'platform',
  },
  {
    title: 'Status',
    dataIndex: 'status',
    key: 'status',
    render: (_: any) => {
      let color: TagProps['color'];

      if (_ === 'pending') {
        color = 'orange';
      } else if (_ === 'active') {
        color = 'blue';
      } else if (_ === 'completed') {
        color = 'green';
      } else if (_ === 'cancelled') {
        color = 'red';
      } else {
        color = 'default';
      }

      return (
        <Tag color={color} className="text-capitalize">
          {_}
        </Tag>
      );
    },
  },
  {
    title: 'Start - End Date',
    dataIndex: 'start_date',
    key: 'status',
    render: (_: any, { start_date, end_date }: any) => (
      <Space>
        <CalendarOutlined />
        <Typography.Text>{start_date}</Typography.Text>-
        <Typography.Text>{end_date}</Typography.Text>
      </Space>
    ),
  },
];

type Props = { data?: any; loading?: boolean; error?: ReactNode } & CardProps;

export const CampaignsCard = ({ error, data, loading, ...others }: Props) => {
  const {
    token: { colorPrimary },
  } = theme.useToken();
  const [activeTabKey, setActiveTabKey] = useState<string>('allCampaigns');
  const [campaignsData, setCampaignsData] = useState<any>([]);

  const TAB_LIST = [
    {
      key: 'allCampaigns',
      label: (
        <Space>
          <Typography.Text>All Campaigns</Typography.Text>
          {loading ? (
            <Spin size="small" />
          ) : (
            <Badge color={colorPrimary} count={DATA_SOURCE.length} />
          )}
        </Space>
      ),
    },
    {
      key: 'pending',
      label: (
        <Space>
          <Typography.Text>Pending</Typography.Text>
          {loading ? (
            <Spin size="small" />
          ) : (
            <Badge
              color={orange[5]}
              count={
                DATA_SOURCE.filter((_: any) => _.status === Status.Pending)
                  .length
              }
            />
          )}
        </Space>
      ),
    },
    {
      key: 'active',
      label: (
        <Space>
          <Typography.Text>Active</Typography.Text>
          {loading ? (
            <Spin size="small" />
          ) : (
            <Badge
              color={blue[5]}
              count={
                DATA_SOURCE.filter((_: any) => _.status === Status.Active)
                  .length
              }
            />
          )}
        </Space>
      ),
    },
    {
      key: 'completed',
      label: (
        <Space>
          <Typography.Text>Completed</Typography.Text>
          {loading ? (
            <Spin size="small" />
          ) : (
            <Badge
              color={green[6]}
              count={
                DATA_SOURCE.filter((_: any) => _.status === Status.Pending)
                  .length
              }
            />
          )}
        </Space>
      ),
    },
  ];

  const onTabChange = (key: string) => {
    setActiveTabKey(key);
  };

  useEffect(() => {
    const dd = data.length > 0 ? data : DATA_SOURCE;
    if (activeTabKey !== 'allCampaigns') {
      setCampaignsData(dd.filter((_: any) => _.status === activeTabKey));
    } else {
      setCampaignsData(dd);
    }
  }, [activeTabKey, data]);

  return (
    <Card
      style={{ width: '100%' }}
      tabList={TAB_LIST}
      activeTabKey={activeTabKey}
      tabBarExtraContent={
        <Button type="primary" icon={<PlusOutlined />}>
          Create campaign
        </Button>
      }
      onTabChange={onTabChange}
      {...others}
    >
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <Table columns={COLUMNS} dataSource={campaignsData} />
      )}
    </Card>
  );
};


src\components\dashboard\default\CategoriesChart\CategoriesChart.tsx:
// src\components\dashboard\default\CategoriesChart\CategoriesChart.tsx
import { CardProps, Typography, Spin, Alert } from 'antd';
import { Pie } from '@ant-design/charts';
import { Card } from '../../../index.ts';
import React, { useState, useEffect } from 'react'; // Import useState and useEffect
import authService from '../../../../services/authService.ts';

type Props = CardProps;

const CategoriesChartComponent: React.FC<Props> = ({ ...others }) => {
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [totalEvents, setTotalEvents] = useState<number>(0); // State for total events

  useEffect(() => {
    const fetchCategoryData = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await authService.getEventCategoryDistribution();
        const data = response as { data: { categoryDistribution: any[], totalEvents: number } };
        setData(data.data.categoryDistribution);
        setTotalEvents(data.data.totalEvents); // Set totalEvents from response
      } catch (error: any) {
        setError(error.message || 'Failed to load category distribution.');
      } finally {
        setLoading(false);
      }
    };

    fetchCategoryData();
  }, []);

  const config = {
    appendPadding: 10,
    data,
    angleField: 'value',
    colorField: 'type',
    radius: 1,
    innerRadius: 0.5,
    label: {
      type: 'inner',
      offset: '-50%',
      content: ({ percent }: any) => `${(percent * 100).toFixed(0)}%`,
      style: {
        textAlign: 'center',
        fontSize: 16,
      },
    },
    interactions: [
      {
        type: 'element-selected',
      },
      {
        type: 'element-active',
      },
    ],
    statistic: {
      title: false,
      content: {
        style: {
          whiteSpace: 'pre-wrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          fontSize: 18,
        },
        // Use totalEvents in the statistic content
        content: `${totalEvents} Events\nTotal`, 
      },
    },
  };

  return (
    <Card title="Categories" {...others}>
      {error && <Alert message="Error" description={error} type="error" showIcon style={{ marginBottom: 16 }} />}
      {loading ? (
        <div style={{ textAlign: 'center' }}>
          <Spin tip="Loading Categories..." />
        </div>
      ) : (
        // @ts-ignore
        <Pie {...config} />
      )}
    </Card>
  );
};

export const CategoriesChart = CategoriesChartComponent;


src\components\dashboard\default\EarningsCard\EarningsCard.tsx:
import { Badge, Card, CardProps, Space, Typography } from 'antd';
import { Pie } from '@ant-design/charts';
import { ArrowDownOutlined, ArrowUpOutlined } from '@ant-design/icons';
import * as _ from 'lodash';
import { MoreMenu } from '../../../index.ts';

type Props = {
  data: any;
  title: string;
  diff: number;
} & CardProps;

export const EarningsCard = ({ data, title, diff, ...others }: Props) => {
  const config = {
    appendPadding: 10,
    data,
    angleField: 'value',
    colorField: 'type',
    radius: 1,
    innerRadius: 0.6,
    label: {
      type: 'inner',
      offset: '-50%',
      content: '{value}',
      style: {
        textAlign: 'center',
        fontSize: 14,
      },
    },
    interactions: [
      {
        type: 'element-selected',
      },
      {
        type: 'element-active',
      },
    ],
    statistic: {
      title: false,
      content: {
        style: {
          whiteSpace: 'pre-wrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        },
        content: '',
      },
    },
  };

  return (
    <Card title={title} extra={<MoreMenu />} {...others}>
      <Space
        direction="vertical"
        style={{ justifyContent: 'flex-start', width: '100%' }}
      >
        <Space direction="horizontal" align="center">
          <Typography.Title level={1} style={{ margin: 0 }}>
            <small>$</small>
            {_.sumBy(data, 'value')}
          </Typography.Title>
          <Badge
            count={
              <div style={{ display: 'flex', gap: '4px' }}>
                {diff < 0 ? <ArrowDownOutlined /> : <ArrowUpOutlined />}
                <Typography.Text style={{ color: 'white' }} strong>
                  {diff}
                </Typography.Text>
              </div>
            }
            style={{
              backgroundColor: diff < 0 ? '#ff4d4f' : '#52c41a',
              color: 'white',
              padding: '.175rem .35rem',
            }}
          />
        </Space>
        <div style={{ height: 180, textAlign: 'center' }}>
          {/*@ts-ignore*/}
          <Pie {...config} />
        </div>
      </Space>
    </Card>
  );
};


src\components\dashboard\default\GetStartedCard\GetStartedCard.tsx:
import { Button, CardProps, Flex, Image, Typography } from 'antd';
import { RightOutlined } from '@ant-design/icons';
import { Card } from '../../../index';
import CountUp from 'react-countup';

type Props = CardProps;

export const GetStartedCard = ({ ...others }: Props) => {
  return (
    <Card {...others}>
      <Flex justify="space-between" align="center" gap="middle">
        <Flex vertical gap="large" align="flex-start">
          <Typography.Title level={4} style={{ margin: 0 }}>
            You have <CountUp end={2} /> projects to finish this week
          </Typography.Title>
          <Typography.Text>
            You have already completed 68% of your monthly target. Keep going to
            achieve your goal.
          </Typography.Text>
          <Button type="primary" size="middle">
            Get started <RightOutlined />
          </Button>
        </Flex>
        <Image
          src="/get-started.png"
          height={180}
          preview={false}
          style={{ objectFit: 'cover' }}
        />
      </Flex>
    </Card>
  );
};


src\components\dashboard\default\LatestOrdersCard\LatestOrdersCard.tsx:
import { Alert, Card, CardProps, Table } from 'antd';
import { MoreMenu } from '../../../index.ts';
import { ReactNode } from 'react';
import { useFetchData } from '../../../../hooks';

const COLUMNS = [
  {
    title: 'Customer name',
    dataIndex: 'customer_name',
    key: 'customer_name',
  },
  {
    title: 'Product',
    dataIndex: 'product_name',
    key: 'product_name',
  },
  {
    title: 'Orders',
    dataIndex: 'orders',
    key: 'orders',
  },
  {
    title: 'Country',
    dataIndex: 'country',
    key: 'country',
  },
  {
    title: 'Shipping address',
    dataIndex: 'shipping_address',
    key: 'shipping_address',
  },
];

type Props = {
  data?: any;
  loading?: boolean;
  error?: ReactNode;
} & CardProps;

export const LatestOrdersCard = ({
  data,
  loading,
  error,
  ...others
}: Props) => {
  const {
    data: ordersData,
    loading: ordersDataLoading,
    error: ordersDataError,
  } = useFetchData('/mocks/CountryOrders.json');

  return (
    <Card title={`Latest Orders`} extra={<MoreMenu />} {...others}>
      {ordersDataError || error ? (
        <Alert
          message="Error"
          description={error?.toString() || ordersDataError.toString()}
          type="error"
          showIcon
        />
      ) : (
        <Table
          columns={COLUMNS}
          dataSource={ordersData}
          loading={ordersDataLoading || loading}
        />
      )}
    </Card>
  );
};


src\components\dashboard\default\OrdersChart\OrdersChart.tsx:
import { Card, CardProps } from 'antd';
import { Area } from '@ant-design/charts';
import { MoreMenu } from '../../../index.ts';

const AreaChart = () => {
  const data = [
    {
      country: 'order',
      date: '1 Aug',
      value: 100,
    },
    {
      country: 'order',
      date: '8 Aug',
      value: 300,
    },
    {
      country: 'order',
      date: '15 Aug',
      value: 200,
    },
    {
      country: 'order',
      date: '22 Aug',
      value: 250,
    },
    {
      country: 'revenue',
      date: '1 Aug',
      value: 900.5,
    },
    {
      country: 'revenue',
      date: '8 Aug',
      value: 1500.5,
    },
    {
      country: 'revenue',
      date: '15 Aug',
      value: 1200.7,
    },
    {
      country: 'revenue',
      date: '22 Aug',
      value: 1300.1,
    },
  ];

  const config = {
    data,
    xField: 'date',
    yField: 'value',
    seriesField: 'country',
    slider: {
      start: 0.1,
      end: 0.9,
    },
  };

  return <Area {...config} />;
};

type Props = CardProps;

export const OrdersChart = ({ ...others }: Props) => {
  return (
    <Card title="Orders value" extra={<MoreMenu />} {...others}>
      <AreaChart />
    </Card>
  );
};


src\components\dashboard\default\RecentUsersCard\RecentUsersCard.tsx:
import { Alert, Card, CardProps, Table, Typography } from 'antd';
import { MoreMenu } from '../../../index.ts';
import { useFetchData } from '../../../../hooks';
import { ReactNode } from 'react';

const COLUMNS = [
  {
    title: 'Names',
    dataIndex: 'first_name',
    key: 'name',
    render: (_: any, { first_name, last_name }: any) => (
      <Typography.Text>
        {first_name} {last_name}
      </Typography.Text>
    ),
  },
  {
    title: 'Gender',
    dataIndex: 'gender',
    key: 'gender',
  },
  {
    title: 'Country',
    dataIndex: 'country',
    key: 'country',
  },
  {
    title: 'Birth date',
    dataIndex: 'birthdate',
    key: 'birthdate',
  },
];

type Props = { data?: any; loading?: boolean; error?: ReactNode } & CardProps;

export const RecentUsersCard = ({ data, loading, error, ...others }: Props) => {
  const {
    data: usersData,
    loading: usersDataLoading,
    error: usersDataError,
  } = useFetchData('/mocks/ChannelUsers.json');

  return (
    <Card title={`Recent Users`} extra={<MoreMenu />} {...others}>
      {usersDataError || error ? (
        <Alert
          message="Error"
          description={error?.toString() || usersDataError.toString()}
          type="error"
          showIcon
        />
      ) : (
        <Table
          columns={COLUMNS}
          dataSource={usersData}
          loading={usersDataLoading || loading}
        />
      )}
    </Card>
  );
};


src\components\dashboard\default\SubscribersChart\SubscribersChart.tsx:
import { Card, CardProps, Flex, Typography } from 'antd';
import { Column } from '@ant-design/charts';
import { MoreMenu } from '../../../index.ts';

type Props = CardProps;

const ColumnChart = () => {
  const data = [
    {
      type: '1 July',
      subscribers: 38,
    },
    {
      type: '8 July',
      subscribers: 52,
    },
    {
      type: '15 July',
      subscribers: 61,
    },
    {
      type: '22 July',
      subscribers: 145,
    },
    {
      type: '29 July',
      subscribers: 48,
    },
    {
      type: '5 Aug',
      subscribers: 38,
    },
    {
      type: '12 Aug',
      subscribers: 38,
    },
    {
      type: '19 Aug',
      subscribers: 38,
    },
  ];
  const config = {
    data,
    xField: 'type',
    yField: 'subscribers',
    label: {
      position: 'middle',

      style: {
        fill: '#FFFFFF',
        opacity: 0.6,
      },
    },
    xAxis: {
      label: {
        autoHide: true,
        autoRotate: false,
      },
    },
    meta: {
      type: {
        alias: 'Subscribers',
      },
      subscribers: {
        alias: 'count',
      },
    },
  };
  // @ts-ignore
  return <Column {...config} />;
};

export const SubscribersChart = ({ ...others }: Props) => {
  return (
    <Card title="YouTube Subscribers" extra={<MoreMenu />} {...others}>
      <Flex gap="middle" vertical>
        <Typography.Text>75% activity growth</Typography.Text>
        <ColumnChart />
      </Flex>
    </Card>
  );
};


src\components\dashboard\default\TasksChartCard\TasksChartCard.tsx:
import { Column } from '@ant-design/charts';
import { Button, CardProps } from 'antd';
import { Card } from '../../../index.ts';

type Tasks = {
  day: string;
  value: number;
  status: string;
};

type ChartProps = {
  data: Tasks[];
};

const ColumnChart = ({ data }: ChartProps) => {
  const config = {
    data,
    isStack: true,
    xField: 'day',
    yField: 'value',
    seriesField: 'status',
    label: {
      position: 'top', // 'top', 'bottom', 'middle'
      offset: 10,
      style: {
        fill: 'transparent',
      },
    },
    interactions: [
      {
        type: 'active-region',
        enable: false,
      },
    ],
    columnBackground: {
      style: {
        fill: 'rgba(0,0,0,0.1)',
      },
    },
    legend: {
      position: 'bottom',
    },
  };

  // @ts-ignore
  return <Column {...config} />;
};

type Props = {
  data?: Tasks[];
} & CardProps;

export const TasksChartCard = ({ data, ...others }: Props) => {
  return (
    <Card title="Tasks stats" extra={<Button>See all</Button>} {...others}>
      <ColumnChart data={data || []} />
    </Card>
  );
};


src\components\dashboard\default\TasksListCard\styles.css:
.tasks-list-card .ant-card-body {
  /*padding: 0 0 1rem 0;*/
}

.tasks-list-card .ant-list-item {
  /*padding: 0;*/
}


src\components\dashboard\default\TasksListCard\TasksListCard.tsx:
import {
  Alert,
  Badge,
  Button,
  Card as AntdCard,
  CardProps,
  Flex,
  List,
  Space,
  Tag,
  Typography,
} from 'antd';
import { Tasks } from '../../../../types';
import { CalendarOutlined, FlagOutlined } from '@ant-design/icons';
import { Card, Loader, UserAvatar } from '../../../index';

import './styles.css';

type Props = {
  data?: Tasks[];
  loading?: boolean;
  error?: any;
} & CardProps;

export const TasksListCard = ({ data, error, loading, ...others }: Props) => {
  return (
    <Card
      title="Tasks"
      extra={<Button>View all</Button>}
      className="tasks-list-card card"
      {...others}
    >
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <List
          grid={{
            gutter: 16,
            xs: 1,
            sm: 1,
            md: 2,
            lg: 2,
            xl: 3,
            xxl: 4,
          }}
          pagination={{
            onChange: (page) => {
              console.log(page);
            },
            pageSize: 6,
            align: 'center',
          }}
          dataSource={data}
          renderItem={(item) => (
            <List.Item key={item.name} style={{ height: '100%' }}>
              <AntdCard
                hoverable
                bordered
                type="inner"
                style={{ height: '100%' }}
              >
                <Flex vertical gap="middle">
                  <Flex justify="space-between" align="center">
                    <Typography.Text strong className="text-capitalize">
                      {item.name.slice(0, 20)}...
                    </Typography.Text>
                    <Tag className="text-capitalize">{item.category}</Tag>
                  </Flex>
                  <Flex justify="space-between" align="center">
                    <Tag
                      icon={<FlagOutlined />}
                      color={item.color}
                      style={{ textTransform: 'capitalize' }}
                    >
                      {item.priority}
                    </Tag>
                    <Badge
                      className="text-capitalize"
                      status={
                        item.status.toLowerCase() === 'completed'
                          ? 'success'
                          : item.status.toLowerCase() === 'in progress'
                            ? 'processing'
                            : 'warning'
                      }
                      text={item.status}
                    />
                  </Flex>
                  <Space>
                    <CalendarOutlined />
                    <Typography.Text>{item.due_date}</Typography.Text>
                  </Space>
                  <UserAvatar fullName={item.assigned_to} size="middle" />
                </Flex>
              </AntdCard>
            </List.Item>
          )}
        />
      )}
    </Card>
  );
};


src\components\dashboard\default\WeeklyActivityCard\WeeklyActivityCard.tsx:
import { Area } from '@ant-design/charts';
import { CardProps } from 'antd';
import { Card } from '../../../index.ts';

type Activity = {
  day: string;
  value: number;
};

type ChartProps = {
  data: Activity[];
};

const AreaChart = ({ data }: ChartProps) => {
  const config = {
    data,
    xField: 'day',
    yField: 'value',
    xAxis: {
      range: [0, 1],
    },
    smooth: true,
  };

  return <Area {...config} />;
};

type Props = {
  data: Activity[];
} & CardProps;

export const WeeklyActivityCard = ({ data, ...others }: Props) => {
  return (
    <Card title="Weekly activity" {...others}>
      <AreaChart data={data} />
    </Card>
  );
};


src\components\dashboard\ecommerce\index.ts:
export { CustomerReviewsCard } from './CustomerReviewsCard/CustomerReviewsCard.tsx';


src\components\dashboard\ecommerce\CustomerReviewsCard\CustomerReviewsCard.tsx:
// src/components/CustomerReviewsCard.tsx
import { useState, useEffect } from 'react';
import {
  Button,
  CardProps,
  Flex,
  Popover,
  Progress,
  ProgressProps,
  Rate,
  Typography,
} from 'antd';
import { green, lime, orange, red, yellow } from '@ant-design/colors';
import { QuestionOutlined } from '@ant-design/icons';
import { Card } from '../../../index.ts';
import authService from '../../../../services/authService';
// Giả sử bạn có service feedbackService với hàm getOrganizerEventFeedbackSummary

const { Title, Text } = Typography;

const PROGRESS_PROPS: ProgressProps = {
  style: {
    width: 200,
  },
};

type Props = CardProps;

export const CustomerReviewsCard = ({ ...others }: Props) => {
  const [feedbackData, setFeedbackData] = useState<{
    averageRating: number;
    ratingDistribution: { [key: string]: number };
    totalFeedbacks: number;
  } | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchFeedback = async () => {
      setLoading(true);
      try {
        // Lấy accessToken theo cách của bạn (ví dụ từ localStorage)
        const accessToken = localStorage.getItem('accessToken') || '';
        const res = await authService.getOrganizerEventFeedbackSummary(accessToken) as { statusCode: number; data: { averageRating: number; ratingDistribution: { [key: string]: number }; totalFeedbacks: number; }; message?: string; };
        if (res.statusCode === 200) {
          setFeedbackData(res.data);
        } else {
          setError(res.message || 'Error fetching feedback summary');
        }
      } catch (err: any) {
        setError(err.message || 'Error fetching feedback summary');
      } finally {
        setLoading(false);
      }
    };

    fetchFeedback();
  }, []);

  if (loading) {
    return (
      <Card title="Customer reviews" {...others}>
        <Text>Loading feedback summary...</Text>
      </Card>
    );
  }

  if (error || !feedbackData) {
    return (
      <Card title="Customer reviews" {...others}>
        <Text type="danger">{error || 'No feedback data available'}</Text>
      </Card>
    );
  }

  // Destructure data từ API
  const { averageRating, ratingDistribution, totalFeedbacks } = feedbackData;

  // Tính phần trăm cho từng hạng mục dựa trên tổng số feedback
  const distributionPercentages = {
    Excellent: Math.round(((ratingDistribution["4-5"] || 0) / totalFeedbacks) * 100),
    Good: Math.round(((ratingDistribution["3-4"] || 0) / totalFeedbacks) * 100),
    Average: Math.round(((ratingDistribution["2-3"] || 0) / totalFeedbacks) * 100),
    Poor: Math.round(((ratingDistribution["1-2"] || 0) / totalFeedbacks) * 100),
    Critical: Math.round(((ratingDistribution["0-1"] || 0) / totalFeedbacks) * 100),
  };

  return (
    <Card
      title="Customer reviews"
      extra={
        <Popover
          content={`Overall rating based on ${totalFeedbacks} reviews`}
          title="Review ratings"
        >
          <Button icon={<QuestionOutlined />} size="small" type="text" />
        </Popover>
      }
      actions={[<Button>See all customer reviews</Button>]}
      {...others}
    >
      <Flex vertical gap="middle">
        <Flex align="center" gap="middle" justify="center">
          <Rate allowHalf value={averageRating} disabled />
          <Title level={2} style={{ margin: 0 }}>
            {averageRating.toFixed(1)}/5
          </Title>
        </Flex>
        <Flex vertical gap="small">
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <Text>Excellent</Text>
            <Progress
              percent={distributionPercentages.Excellent}
              strokeColor={lime[6]}
              {...PROGRESS_PROPS}
            />
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <Text>Good</Text>
            <Progress
              percent={distributionPercentages.Good}
              strokeColor={green[5]}
              {...PROGRESS_PROPS}
            />
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <Text>Average</Text>
            <Progress
              percent={distributionPercentages.Average}
              strokeColor={yellow[6]}
              {...PROGRESS_PROPS}
            />
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <Text>Poor</Text>
            <Progress
              percent={distributionPercentages.Poor}
              strokeColor={orange[5]}
              {...PROGRESS_PROPS}
            />
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <Text>Critical</Text>
            <Progress
              percent={distributionPercentages.Critical}
              strokeColor={red[6]}
              {...PROGRESS_PROPS}
            />
          </div>
        </Flex>
      </Flex>
    </Card>
  );
};

export default CustomerReviewsCard;


src\components\dashboard\events\ActivityTable.tsx:
import {
    Alert,
    Button,
    Table,
} from 'antd';
import { useNavigate } from 'react-router-dom';
import { Card } from '../../';

const ACTIVITY_COLUMNS = (navigate: ReturnType<typeof useNavigate>) => [
    {
      title: 'ID',
      dataIndex: 'activity_id',
      key: 'id',
    },
    {
      title: 'Activity Name',
      dataIndex: 'activity_name',
      key: 'name',
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: 'Attendees',
      dataIndex: 'attendees',
      key: 'Attendees',
    },
    {
      title: 'Actions',
      dataIndex: 'activity_id',
      key: 'id',
      render: (value,record) => (
        <div>
        <Button type="primary" onClick={() => navigate(`/details/events/${value}`)}>
          Details
        </Button>
        </div>
      )
    }
  ];
  interface EventTableProps {
    data: [];
    error?: string;
    loading: boolean;
  }
export const ActivityTable : React.FC<EventTableProps> = ({data,error,loading} ) => {
  const navigate = useNavigate();
  return (
    <div>
          <Card title="This Event's Activities" extra={<a href="/create/activities">Create Activities for this Event</a>}>
            {error ? (
              <Alert
                message="Error"
                description={error.toString()}
                type="error"
                showIcon
              />
            ) : (
              <Table
                columns={ACTIVITY_COLUMNS(navigate)}
                dataSource={data}
                loading={loading}
                className="overflow-scroll"
              />
            )}
          </Card>
    </div>
  )
}


src\components\dashboard\events\EventSchedule.tsx:
import { Alert, Button, CardProps, Flex, Timeline, Typography } from 'antd';
import {
  LaptopOutlined,
  MobileOutlined,
  TabletOutlined,
} from '@ant-design/icons';
// import { ActivityTimeline } from '../../../types';
import { Card, Loader } from '../../index.ts';
import { ReactNode } from 'react';

type Props = {
  data?: [];
  loading?: boolean;
  error?: ReactNode;
} & CardProps;

export const EventTimelineCard = ({ data, error, loading, ...others }: Props) => {
  return (
    <Card title="Latest activities" {...others}>
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <Timeline
          mode="left"
          items={data?.map((_) => ({
            // dot:
            //   _.device_type === 'desktop' ? (
            //     <LaptopOutlined />
            //   ) : _.device_type === 'tablet' ? (
            //     <TabletOutlined />
            //   ) : (
            //     <MobileOutlined />
            //   ),
            children: (
              <Flex gap="small" vertical>
                <Typography.Paragraph
                  ellipsis={{
                    rows: 2,
                  }}
                  // title={`${_.post_content}--${_.timestamp}`}
                  style={{ marginBottom: 0 }}
                >
                  {_.post_content} - By <i>{_.speaker_name}</i>
                </Typography.Paragraph>
                {/* <Typography.Text type="secondary">
                  {_.timestamp}
                </Typography.Text> */}
              </Flex>
            ),
          }))}
        />
      )}
    </Card>
  );
};


src\components\dashboard\events\EventTable.tsx:
  // src\components\dashboard\events\EventTable.tsx
  import {
    Alert,
    Button,
    Table,
  } from 'antd';
  import { useNavigate } from 'react-router-dom';
  import { Card } from '../../';

  const EVENT_COLUMNS = (navigate: ReturnType<typeof useNavigate>) => [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
    },
    {
      title: 'Event Name',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: 'Attendees',
      dataIndex: 'capacity',
      key: 'capacity',
    },
    {
      title: 'Location',
      dataIndex: 'location',
      key: 'location',
    },
    {
      title: 'Start At',
      dataIndex: 'startDate',
      key: 'startDate',
    },
    {
      title: 'End At',
      dataIndex: 'endDate',
      key: 'endDate',
    },
    {
      title: 'Actions',
      dataIndex: 'id',
      key: 'id',
      render: (/* value bị xóa */_: any, record: any) => ( // Xóa parameter value
        <div>
          <Button type="primary" onClick={() => navigate(`/details/events/${record.id}`)}> {/* Đảm bảo URL là `/details/events/${record.id}` */}
            Details
          </Button>
        </div>
      )
    }
  ];
  interface EventTableProps {
    data: [];
    error?: string;
    loading: boolean;
  }
  export const EventTable: React.FC<EventTableProps> = ({ data, error, loading }) => {
    const navigate = useNavigate();
    return (
      <div>
        <Card title="Your Events" extra={<a href="/create/events">Create Your Events</a>}>
          {error ? (
            <Alert
              message="Error"
              description={error.toString()}
              type="error"
              showIcon
            />
          ) : (
            <Table
              columns={EVENT_COLUMNS(navigate)}
              dataSource={data}
              loading={loading}
              className="overflow-scroll"
            />
          )}
        </Card>
      </div>
    )
  }


src\components\dashboard\events\index.tsx:
export {EventTable} from './EventTable.tsx';
export {EventTimelineCard} from './EventSchedule.tsx';
export {MyEventTimelineCard} from './MyEventTimelineCard.tsx';
export {ActivityTable} from './ActivityTable.tsx';

src\components\dashboard\events\MyEventTable.tsx:
// src\components\dashboard\events\MyEventTable.tsx
import {
  Badge,
  BadgeProps,
  Button,
  Popconfirm,
  Space,
  Spin,
  Table,
  TableProps,
  Tag,
  TagProps,
  Typography,
  message,
} from 'antd';
import { useNavigate } from 'react-router-dom';
import { useEffect, useState } from 'react';
import authService from '../../../services/authService';
import { Events } from '../../../types';
import { ColumnsType } from 'antd/es/table';
import dayjs from 'dayjs';

type Props = {
  data: Events[];
  loading: boolean;
  fetchData: () => void;
  activeTabKey: string;
} & TableProps<Events>;

export const MyEventsTable = ({ data, loading, fetchData, activeTabKey, ...others }: Props) => {
  const [categoryNamesMap, setCategoryNamesMap] = useState<Record<string, string>>({}); // State to store category names by categoryId
  const [categoryLoading, setCategoryLoading] = useState(false); // Loading state
  const navigate = useNavigate();
  const [tableLoading, setTableLoading] = useState(false);

  useEffect(() => {
    const fetchCategoryNames = async () => {
      if (!data || data.length === 0) return; // Exit if no events data

      setCategoryLoading(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        if (!accessToken) {
          message.error("No access token found. Please login again.");
          return;
        }

        const newCategoryNamesMap: Record<string, string> = {};
        // Fetch category name for each event
        for (const event of data) {
          if (event.categoryId) {
            try {
              const response = await authService.getCategoryById(event.categoryId, accessToken);
              const categoryResponse = response as { data: { category: { name: string } } };
              newCategoryNamesMap[event.categoryId] = categoryResponse.data.category.name;
            } catch (categoryError) {
              console.error(`Error fetching category name for categoryId ${event.categoryId}:`, categoryError);
              newCategoryNamesMap[event.categoryId] = 'N/A'; // Set to N/A in case of error for a specific category
            }
          }
        }
        setCategoryNamesMap(newCategoryNamesMap);
      } catch (error: any) {
        console.error('Error fetching category names:', error);
        message.error('Failed to load category names');
        setCategoryNamesMap({}); // Clear the map in case of a general error
      } finally {
        setCategoryLoading(false);
      }
    };

    fetchCategoryNames();
  }, [data]);

  const COLUMNS = (navigate: ReturnType<typeof useNavigate>, setLoading: (loading: boolean) => void, fetchData: () => void, activeTabKey: string): ColumnsType<Events> => [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'proj_name',
      render: (_: any, record: Events) => (
        <Typography.Paragraph
          ellipsis={{ rows: 1 }}
          className="text-capitalize"
          style={{ marginBottom: 0 }}
        >
          {record.name?.substring(0, 20)}
        </Typography.Paragraph>
      ),
    },
    {
      title: 'Category',
      dataIndex: 'categoryId',
      key: 'event_category',
      render: (categoryId: string) => { // Changed render to receive categoryId
        return (
          <Space>
            {categoryLoading ? (
              <Spin />
            ) : (
              <Tag color="blue">{categoryNamesMap[categoryId] || 'N/A'}</Tag> // Use categoryNamesMap to get the name
            )}
          </Space>
        );
      },
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'proj_status',
      render: (_: any) => {
        let status: BadgeProps['status'];

        if (_ === 'SCHEDULED') {
          status = 'default';
        } else if (_ === 'FINISHED') {
          status = 'success';
        } else if (_ === "CANCELED") {
          status = 'error';
        } else {
          status = 'processing'
        }

        return <Badge status={status} text={_} className="text-capitalize" />;
      },
    },
    {
      title: 'Capacity',
      dataIndex: 'maxParticipants',
      key: 'event_capacity',
    },
    {
      title: 'Start Date',
      dataIndex: 'startDate',
      key: 'event_start_date',
      render: (date) => date ? dayjs(date).format('DD/MM/YYYY HH:mm:ss') : 'N/A', // Thêm định dạng DD/MM/YYYY HH:mm:ss
    },
    {
      title: 'End Date',
      dataIndex: 'endDate',
      key: 'event_end_date',
      render: (date) => date ? dayjs(date).format('DD/MM/YYYY HH:mm:ss') : 'N/A', // Thêm định dạng DD/MM/YYYY HH:mm:ss
    },
    {
      title: 'Actions',
      dataIndex: 'id',
      key: 'event_actions',
      render: (eventId: string, record: Events) => {
        return (
          <Space size="small">
            <Button type="primary" onClick={() => navigate(`/details/my-events/${record.id}`)}> {/* Đã sửa URL navigate */}
              Details
            </Button>
            {activeTabKey !== 'CANCELED' && activeTabKey !== 'FINISHED' && (
              <Button type="primary" onClick={() => navigate(`/edit/events/${record.id}`)}>
                Update
              </Button>
            )}
            {activeTabKey !== 'CANCELED' && activeTabKey !== 'FINISHED' && (
              <Popconfirm
                title="Cancel Event"
                description="Are you sure to cancel this event?"
                onConfirm={() => handleCancel(eventId, setTableLoading, fetchData)}
                onCancel={() => message.info('Cancel cancel')}
                okText="Yes, Cancel"
                cancelText="No"
                placement="topRight" // Thử thay đổi placement
                overlayInnerStyle={{ width: 300 }} // Thử set width
              >
                <Button danger>
                  Cancel
                </Button>
              </Popconfirm>
            )}
          </Space>
        );
      },
    },
  ];

  const handleCancel = async (eventId: string, setLoading: (loading: boolean) => void, fetchData: () => void) => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        return;
      }

      const response = await authService.deleteEvent(eventId, accessToken) as { statusCode: number, message: string };
      if (response.statusCode === 200) {
        message.success(response.message);
        fetchData();
      } else {
        message.error(response.message || 'Failed to cancel event');
      }
    } catch (error: any) {
      console.error('Error canceling event:', error);
      message.error(error.message || 'Failed to cancel event');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Table
      rowKey="id"
      dataSource={data}
      columns={COLUMNS(navigate, setTableLoading, fetchData, activeTabKey)}
      className="overflow-scroll"
      loading={loading || tableLoading || categoryLoading} // Include categoryLoading in table loading
      {...others}
    />
  );
};


src\components\dashboard\events\MyEventTimelineCard.tsx:
import { Alert, Button, CardProps, Flex, Form, Input, Modal, Timeline, Typography } from 'antd';
import {
  LaptopOutlined,
  MobileOutlined,
  TabletOutlined,
} from '@ant-design/icons';
// import { ActivityTimeline } from '../../../types';
import { Card, Loader } from '../../index.ts';
import { ReactNode, useEffect, useState } from 'react';

type Props = {
  data?: [];
  loading?: boolean;
  error?: ReactNode;
} & CardProps;

export const MyEventTimelineCard = ({ data, error, loading, ...others }: Props) => {

    // Modal State for create event type
    const [activityTimeline, setActivityTimeline] = useState(data);
    useEffect(() => {
      setActivityTimeline(data);
    }, [data]);
    const [isCreateTimelineModalOpen, setIsCreateTimelineModalOpen] = useState<any>(false);
  
      const [form] = Form.useForm();
  
    const showCreateTimelineModal = () => {
      setIsCreateTimelineModalOpen(true);
    };
  
    const handleOkCreateTimeline = () => {
      setIsCreateTimelineModalOpen(false);
      form.submit()
    };
  
    const handleCancelCreateTimeline = () => {
      setIsCreateTimelineModalOpen(false);
    };

    const onFinishTimeline = (values : any) => {
      setActivityTimeline([...activityTimeline, {
        speaker_name: values.speaker_name,
        post_content: values.post_content
      }]);
      setIsCreateTimelineModalOpen(false);
    };
  return (
    <Card title="Latest activities" {...others} extra={<Button type='primary' onClick={showCreateTimelineModal}>Add New Activity</Button>}>
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <Timeline
          mode="left"
          items={activityTimeline?.map((_) => ({
            // dot:
            //   _.device_type === 'desktop' ? (
            //     <LaptopOutlined />
            //   ) : _.device_type === 'tablet' ? (
            //     <TabletOutlined />
            //   ) : (
            //     <MobileOutlined />
            //   ),
            children: (
              <Flex gap="small" vertical>
                <Typography.Paragraph
                  ellipsis={{
                    rows: 2,
                  }}
                  // title={`${_.post_content}--${_.timestamp}`}
                  style={{ marginBottom: 0 }}
                >
                  {_.post_content} - By <i>{_.speaker_name}</i>
                </Typography.Paragraph>
                {/* <Typography.Text type="secondary">
                  {_.timestamp}
                </Typography.Text> */}
              </Flex>
            ),
          }))}
        />
      )}
              <Modal title="Create Event Type" open={isCreateTimelineModalOpen} onOk={handleOkCreateTimeline} onCancel={handleCancelCreateTimeline}>
          <Form layout='vertical'
            onFinish={onFinishTimeline}
            form={form}
          >
            <Form.Item label="Speaker's Name" name="speaker_name">
              <Input placeholder="John Doe" />
            </Form.Item>
            <Form.Item label="Talk About" name="post_content">
              <Input placeholder="Software Engineering Future" />
            </Form.Item>
          </Form>
      </Modal>
    </Card>
  );
};


src\components\dashboard\projects\index.ts:
export { ClientsTable } from './ClientsTable/ClientsTable.tsx';
export { ProjectsCountCard } from './ProjectsCountCard/ProjectsCountCard.tsx';
export { ProjectsTable } from './ProjectsTables/ProjectsTable.tsx';


src\components\dashboard\projects\ClientsTable\ClientsTable.tsx:
// src\components\dashboard\projects\ClientsTable\ClientsTable.tsx
import { Table, TableProps, Typography } from 'antd';
import { Clients } from '../../../../types';
import { UserAvatar } from '../../../index.ts';
import dayjs from 'dayjs';

const COLUMNS = [
  {
    title: 'Client Name',
    dataIndex: 'name', // changed from 'client_name' to 'name'
    key: 'c_name',
    render: (_: any, record: any) => ( // use any to avoid type error, or define proper type for record
      <UserAvatar fullName={record.name} avatarUrl={record.avatar} /> // use record.name and record.avatarUrl
    ),
  },
  {
    title: 'Email',
    dataIndex: 'email', // added Email column
    key: 'client_email',
  },
  {
    title: 'Last Login', // added Last Login column
    dataIndex: 'lastLoginAt',
    key: 'client_last_login',
    render: (text: string) => text ? dayjs(text).format('YYYY-MM-DD HH:mm') : 'Never', // format date
  },
];

interface Props extends TableProps<any> {
  data: any[]; // changed type to any[] to match fetched user data
}

export const ClientsTable = ({ data, ...others }: Props) => (
  <Table
    dataSource={data}
    columns={COLUMNS}
    key="client_table"
    size="middle"
    className="overflow-scroll"
    {...others}
  />
);


src\components\dashboard\projects\ProjectsCountCard\ProjectsCountCard.tsx:
import {
  Card,
  CardProps,
  Col,
  Progress,
  ProgressProps,
  Row,
  Space,
  SpaceProps,
  Statistic,
  Tooltip,
} from 'antd';
import ProjectsData from '../../../../../public/mocks/Projects.json';
import './styles.scss';

const PROGRESS_PROPS: ProgressProps = {
  type: 'circle',
  showInfo: false,
  size: 24,
  style: {
    paddingBottom: '.35rem',
  },
};

const SPACE_PROPS: SpaceProps = {
  align: 'end',
};

type Props = CardProps;

export const ProjectsCountCard = ({ ...others }: Props) => {
  const completed = ProjectsData.filter((_) => _.status === 'completed'),
    inProgress = ProjectsData.filter((_) => _.status === 'in progress'),
    onHold = ProjectsData.filter((_) => _.status === 'on hold');

  return (
    <Card
      title="Project stats"
      bodyStyle={{
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        height: '80%',
      }}
      className="card"
      style={{
        height: '100%',
      }}
      {...others}
    >
      <Row gutter={16}>
        <Col span={8}>
          <Space {...SPACE_PROPS}>
            <Statistic title="Active" value={inProgress.length} />
            <Tooltip
              title={`${inProgress.length} / ${ProjectsData.length} active`}
            >
              <Progress
                percent={Number(
                  ((inProgress.length / ProjectsData.length) * 100).toFixed(2)
                )}
                {...PROGRESS_PROPS}
              />
            </Tooltip>
          </Space>
        </Col>
        <Col span={8}>
          <Space {...SPACE_PROPS}>
            <Statistic title="On Hold" value={onHold.length} />
            <Tooltip
              title={`${onHold.length} / ${ProjectsData.length} on hold`}
            >
              <Progress
                percent={Number(
                  ((onHold.length / ProjectsData.length) * 100).toFixed(2)
                )}
                {...PROGRESS_PROPS}
              />
            </Tooltip>
          </Space>
        </Col>
        <Col span={8}>
          <Space {...SPACE_PROPS}>
            <Statistic title="Completed" value={completed.length} />
            <Tooltip
              title={`${completed.length} / ${ProjectsData.length} completed`}
            >
              <Progress
                percent={Number(
                  ((completed.length / ProjectsData.length) * 100).toFixed(2)
                )}
                {...PROGRESS_PROPS}
              />
            </Tooltip>
          </Space>
        </Col>
      </Row>
    </Card>
  );
};


src\components\dashboard\projects\ProjectsCountCard\styles.scss:


src\components\dashboard\projects\ProjectsTables\ProjectsTable.tsx:
// src\components\dashboard\projects\ProjectsTables\ProjectsTable.tsx
import {
  Badge,
  BadgeProps,
  Table,
  TableProps,
  Tag,
  TagProps,
  Typography,
} from 'antd';
import { Projects } from '../../../../types';
import { ColumnsType } from 'antd/es/table'; // Import ColumnsType

const COLUMNS: ColumnsType<Projects> = [ // Specify ColumnsType<Projects>
  {
    title: 'Name',
    dataIndex: 'project_name',
    key: 'proj_name',
    render: (_: any, { project_name }: Projects) => ( // Ensure record is of type Projects
      <Typography.Paragraph
        ellipsis={{ rows: 1 }}
        className="text-capitalize"
        style={{ marginBottom: 0 }}
      >
        {project_name?.substring(0, 20)}  // Optional chaining for safety
      </Typography.Paragraph>
    ),
  },
  {
    title: 'Client',
    dataIndex: 'client_name',
    key: 'proj_client_name',
  },
  {
    title: 'Category',
    dataIndex: 'project_category',
    key: 'proj_category',
    render: (_: any) => <span className="text-capitalize">{_}</span>,
  },
  {
    title: 'Priority',
    dataIndex: 'priority',
    key: 'proj_priority',
    render: (_: any) => {
      let color: TagProps['color'];

      if (_ === 'low') {
        color = 'cyan';
      } else if (_ === 'medium') {
        color = 'geekblue';
      } else {
        color = 'magenta';
      }

      return (
        <Tag color={color} className="text-capitalize">
          {_}
        </Tag>
      );
    },
  },
  {
    title: 'Status',
    dataIndex: 'status',
    key: 'proj_status',
    render: (_: any) => {
      let status: BadgeProps['status'];

      if (_ === 'on hold') {
        status = 'default';
      } else if (_ === 'finished') { // Đã sửa thành finished
        status = 'success';
      } else {
        status = 'processing';
      }

      return <Badge status={status} text={_} className="text-capitalize" />;
    },
  },
  {
    title: 'Team size',
    dataIndex: 'team_size',
    key: 'proj_team_size',
  },
  {
    title: 'Duration',
    dataIndex: 'project_duration',
    key: 'project_duration',
  },
  {
    title: 'Start date',
    dataIndex: 'start_date',
    key: 'proj_start_date',
  },
];

type Props = {
  data: Projects[];
} & TableProps<Projects>; // Fixed type to TableProps<Projects>

export const ProjectsTable = ({ data, ...others }: Props) => {
  return (
    <Table
      rowKey="project_id" // Thêm rowKey="project_id"
      dataSource={data}
      columns={COLUMNS}
      className="overflow-scroll"
      {...others}
    />
  );
};

src\components\dashboard\shared\index.ts:
export { RevenueCard } from './RevenueCard/RevenueCard.tsx';
export { PostsCard } from './PostsCard/PostsCard.tsx';
export { ProjectsCard } from './ProjectsCard/ProjectsCard.tsx';
export {EventsCard } from './EventsCard/EventsCard.tsx';

src\components\dashboard\shared\EventsCard\EventsCard.tsx:
// src\components\dashboard\shared\EventsCard\EventsCard.tsx
import React from 'react';
import {
  Card as AntdCard,
  CardProps,
  Descriptions,
  DescriptionsProps,
  Flex,
  Tooltip,
  Typography,
  Spin, // Import Spin
  Tag, // Import Tag
  message, // Import message
} from 'antd';
import {
  CalendarOutlined,
  UsergroupAddOutlined,
} from '@ant-design/icons';

import './styles.css';
import { Events } from '../../../../types';
import { useState, useEffect } from 'react'; // Import useState and useEffect
import authService from '../../../../services/authService';
import dayjs from 'dayjs';

const { Text, Title } = Typography;

type Props = {
  event?: Events; // Make event prop optional
  size?: 'small' | 'default';
} & CardProps;

export const EventsCard = (props: Props) => {
  const {
    size,
    event, // Event can be potentially undefined
    ...others
  } = props;

  const [categoryName, setCategoryName] = useState<string | null>(null); // State for category name
  const [categoryLoading, setCategoryLoading] = useState(false); // Loading state

  useEffect(() => {
    const fetchCategoryName = async () => {
      if (!event?.categoryId) return; // Exit if categoryId is missing
      setCategoryLoading(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getCategoryById(event.categoryId, accessToken || '');
        const categoryResponse = response as { data: { category: { name: string } } };
        setCategoryName(categoryResponse.data.category.name);
      } catch (error: any) {
        console.error('Error fetching category name:', error);
        message.error('Failed to load category name');
        setCategoryName('N/A'); // Set to N/A in case of error
      } finally {
        setCategoryLoading(false);
      }
    };

    if (event) {
      fetchCategoryName();
    }
  }, [event]);


  const items: DescriptionsProps['items'] = event ? [
    {
      key: 'event_name',
      label: 'Title',
      children: (
        <span className="text-capitalize">{event.name?.slice(0, 36)}...</span>
      ),
      span: 24,
    },
    {
      key: 'event_id',
      label: 'ID',
      children: event.id,
      span: 24,
    },
    {
      key: 'event_type',
      label: 'Category',
      children: categoryLoading ? <Spin size="small" /> : <Tag color="blue">{categoryName || 'Loading...'}</Tag>, // Display category name or loader
      span: 24,
    },
    {
      key: 'project_location',
      label: 'Location',
      children: event.location,
      span: 24,
    },
    {
      key: 'project_status',
      label: 'Status',
      children: <span className="text-capitalize">{event.status}</span>,
    },
    {
      key: 'team_size',
      label: <UsergroupAddOutlined />,
      children: (
        <Tooltip title="Team size">
          <Typography.Text>{event.maxParticipants}</Typography.Text>
        </Tooltip>
      ),
    },
    {
      key: 'start_date',
      label: <CalendarOutlined />,
      children: (
        <Tooltip title="Project date">
          <Typography.Text>{event.startDate ? dayjs(event.startDate).format('DD/MM/YYYY HH:mm') : 'N/A'} - {event.endDate ? dayjs(event.endDate).format('DD/MM/YYYY HH:mm') : 'N/A'}</Typography.Text>
        </Tooltip>
      ),
    },
  ] : [];


  return size === 'small' ? (
    <AntdCard
      bordered
      hoverable={true}
      className="project-small-card"
      {...others}
    >
      <Title level={5} className="text-capitalize m-0">
        {event?.name?.slice(0, 15)}
      </Title>
      <br />
      <Flex wrap="wrap" gap="small" className="text-capitalize">
        <Text>
          Category: <b>{categoryLoading ? <Spin size="small" /> : <Tag color="blue">{categoryName || 'Loading...'}</Tag>}</b>,
        </Text>
        <Text>
          Location: <b>{event?.location}</b>
        </Text>
      </Flex>
    </AntdCard>
  ) : (
    <AntdCard bordered hoverable={true} {...others}>
      <Descriptions
        items={items}
        column={{ xxl: 2, xl: 2, lg: 2, md: 1, sm: 1, xs: 1 }}
      />
    </AntdCard>
  );
};


src\components\dashboard\shared\EventsCard\styles.css:
.project-small-card .ant-card-body {
}


src\components\dashboard\shared\PostsCard\PostsCard.tsx:
import {
  Alert,
  Avatar,
  Button,
  CardProps,
  Col,
  Divider,
  Flex,
  Image,
  List,
  Row,
  Space,
  theme,
  Typography,
} from 'antd';
import { Posts } from '../../../../types';
import {
  CommentOutlined,
  DeleteFilled,
  EditFilled,
  LikeOutlined,
  ShareAltOutlined,
} from '@ant-design/icons';
import React, { ReactNode } from 'react';
import { getNameInitials } from '../../../../utils';
import { Card, Loader } from '../../../index.ts';

import './styles.css';

const IconText = ({
  icon,
  text,
}: {
  icon: React.FC;
  text: string | number;
}) => (
  <Space>
    {React.createElement(icon)}
    {text}
  </Space>
);

type Props = {
  as: 'scheduled' | 'active';
  data?: Posts[];
  loading?: boolean;
  error?: ReactNode;
} & CardProps;

export const PostsCard = ({ as, data, error, loading, ...others }: Props) => {
  const { token } = theme.useToken();

  return (
    <Card className="posts-lists-card card" {...others}>
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <List
          itemLayout="vertical"
          size="large"
          pagination={{
            onChange: (page) => {
              console.log(page);
            },
            pageSize: 5,
            align: 'center',
          }}
          dataSource={data}
          renderItem={(item: Posts) =>
            as === 'active' ? (
              <List.Item
                key={item.title}
                actions={[
                  <IconText
                    icon={LikeOutlined}
                    text={item.likes_count}
                    key="list-vertical-star-o"
                  />,
                  <IconText
                    icon={CommentOutlined}
                    text={item.comments_count}
                    key="list-vertical-like-o"
                  />,
                  <IconText
                    icon={ShareAltOutlined}
                    text={item.shares_count}
                    key="list-vertical-message"
                  />,
                ]}
                extra={<img width={32} alt="logo" src={item.image_url} />}
              >
                <List.Item.Meta
                  avatar={
                    <Avatar style={{ backgroundColor: token.colorPrimary }}>
                      {getNameInitials(item.author)}
                    </Avatar>
                  }
                  title={
                    <Typography.Link style={{ textTransform: 'capitalize' }}>
                      {item.title.slice(0, 30)}...
                    </Typography.Link>
                  }
                  description={
                    <Space>
                      <Typography.Text>{item.category}</Typography.Text>
                      <Divider type="vertical" />
                      <Typography.Text>{item.date}</Typography.Text>
                      <Divider type="vertical" />
                      <Typography.Text>{item.location}</Typography.Text>
                    </Space>
                  }
                />
                <Typography.Paragraph ellipsis={{ rows: 3 }}>
                  {item.content}
                </Typography.Paragraph>
              </List.Item>
            ) : (
              <List.Item key={item.title}>
                <Row gutter={[8, 8]}>
                  <Col span={2}>
                    <Flex
                      justify="center"
                      align="center"
                      style={{ height: '100%' }}
                    >
                      <Image
                        src={item.image_url}
                        width={24}
                        height={24}
                        alt={item.title}
                        placeholder={true}
                        preview={false}
                      />
                    </Flex>
                  </Col>
                  <Col span={20}>
                    <Flex vertical gap="small">
                      <Typography.Text strong className="text-capitalize m-0">
                        {item.title.slice(0, 50)}...
                      </Typography.Text>
                      <Flex vertical gap="small">
                        <Flex gap="small">
                          <Typography.Text>Category:</Typography.Text>
                          <Typography.Text>{item.category}</Typography.Text>
                        </Flex>
                        <Flex gap="small">
                          <Typography.Text>Posting date:</Typography.Text>
                          <Typography.Text>
                            {item.date} - {item.time}:00h
                          </Typography.Text>
                        </Flex>
                      </Flex>
                    </Flex>
                  </Col>
                  <Col span={2}>
                    <Flex vertical align="flex-end" gap="middle">
                      <Button shape="circle">
                        <EditFilled />
                      </Button>
                      <Button shape="circle">
                        <DeleteFilled />
                      </Button>
                    </Flex>
                  </Col>
                </Row>
              </List.Item>
            )
          }
        />
      )}
    </Card>
  );
};


src\components\dashboard\shared\PostsCard\styles.css:
.posts-lists-card .ant-card-body {
  padding: 0 0 1rem 0;
}

.available-tucks-card .ant-list-item {
  /*padding: 0;*/
}


src\components\dashboard\shared\ProjectsCard\ProjectsCard.tsx:
import {
  Card as AntdCard,
  CardProps,
  Descriptions,
  DescriptionsProps,
  Flex,
  Tooltip,
  Typography,
} from 'antd';
import {
  CalendarOutlined,
  ClockCircleOutlined,
  UsergroupAddOutlined,
} from '@ant-design/icons';
import { Projects } from '../../../../types';

import './styles.css';

const { Text, Title } = Typography;

type Props = {
  project: Projects;
  size?: 'small' | 'default';
} & CardProps;

export const ProjectsCard = (props: Props) => {
  const {
    size,
    project: {
      client_name,
      end_date,
      project_duration,
      project_manager,
      project_name,
      project_type,
      project_location,
      priority,
      team_size,
      status,
    },
    ...others
  } = props;

  const items: DescriptionsProps['items'] = [
    {
      key: 'project_name',
      label: 'Title',
      children: (
        <span className="text-capitalize">{project_name.slice(0, 36)}...</span>
      ),
      span: 24,
    },
    {
      key: 'project_manager',
      label: 'Manager',
      children: project_manager,
      span: 24,
    },
    {
      key: 'project_client',
      label: 'Client',
      children: client_name,
      span: 24,
    },
    {
      key: 'project_type',
      label: 'Type',
      children: <span className="text-capitalize">{project_type}</span>,
      span: 24,
    },
    {
      key: 'project_location',
      label: 'Location',
      children: project_location,
      span: 24,
    },
    {
      key: 'project_priority',
      label: 'Priority',
      children: <span className="text-capitalize">{priority}</span>,
    },
    {
      key: 'project_status',
      label: 'Status',
      children: <span className="text-capitalize">{status}</span>,
    },
    {
      key: 'team_size',
      label: <UsergroupAddOutlined />,
      children: (
        <Tooltip title="Team size">
          <Typography.Text>{team_size}</Typography.Text>
        </Tooltip>
      ),
    },
    {
      key: 'period',
      label: <ClockCircleOutlined />,
      children: (
        <Tooltip title="Project duration (months)">
          <Typography.Text>{project_duration}</Typography.Text>
        </Tooltip>
      ),
    },
    {
      key: 'end_date',
      label: <CalendarOutlined />,
      children: (
        <Tooltip title="Project end date">
          <Typography.Text>{end_date}</Typography.Text>
        </Tooltip>
      ),
    },
  ];

  return size === 'small' ? (
    <AntdCard
      bordered
      hoverable={true}
      className="project-small-card"
      {...others}
    >
      <Title level={5} className="text-capitalize m-0">
        {project_name.slice(0, 15)}
      </Title>
      <br />
      <Flex wrap="wrap" gap="small" className="text-capitalize">
        <Text>
          Owner: <b>{project_manager},</b>
        </Text>
        <Text>
          Client: <b>{client_name},</b>
        </Text>
        <Text>
          Priority: <b>{priority},</b>
        </Text>
        <Text>
          Type: <b>{project_type},</b>
        </Text>
        <Text>
          Location: <b>{project_location}</b>
        </Text>
      </Flex>
    </AntdCard>
  ) : (
    <AntdCard bordered hoverable={true} {...others}>
      <Descriptions
        items={items}
        column={{ xxl: 2, xl: 2, lg: 2, md: 1, sm: 1, xs: 1 }}
      />
    </AntdCard>
  );
};


src\components\dashboard\shared\ProjectsCard\styles.css:
.project-small-card .ant-card-body {
}


src\components\dashboard\shared\RevenueCard\RevenueCard.tsx:
import React, { CSSProperties } from 'react';
import { CardProps, Space, Typography } from 'antd';
import { ArrowDownOutlined, ArrowUpOutlined } from '@ant-design/icons';
import { green, red } from '@ant-design/colors';
import CountUp from 'react-countup';
import { Card } from '../../../index.ts';

const { Title, Text } = Typography;

type RevenueCardProps = {
  title: string;
  value: number | string;
  diff: number;
  justify?: CSSProperties['justifyContent'];
  height?: number;
} & CardProps;

export const RevenueCard: React.FC<RevenueCardProps> = ({
  title,
  value,
  diff,
  justify = 'space-between',
  height,
  ...others
}) => {
  // Tính toán chiều cao nội dung bên trong (giảm đi khoảng padding, tiêu đề,...)
  const contentHeight = height ? height - 60 : 'auto';

  // Style cho container nội dung card
  const containerStyle: CSSProperties = {
    height: contentHeight,
    display: 'flex',
    flexDirection: 'column',
    justifyContent: justify,
    padding: 16,
  };

  return (
    <Card
      {...others}
      style={{
        height,
        borderRadius: 8,
        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        ...others.style,
      }}
    >
      <div style={containerStyle}>
        <Text style={{ fontSize: 16, color: '#666' }}>{title}</Text>
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            marginTop: 8,
          }}
        >
          <Title level={2} style={{ margin: 0 }}>
            {typeof value === 'number' ? (
              <>
                <CountUp end={value} duration={1.5} separator="," />
              </>
            ) : (
              <span >{value}</span>
            )}
          </Title>
          <Space size="small" style={{ color: diff > 0 ? green[6] : red[5] }}>
            {diff > 0 ? (
              <ArrowUpOutlined style={{ fontSize: 18 }} />
            ) : (
              <ArrowDownOutlined style={{ fontSize: 18 }} />
            )}
            <Text style={{ fontSize: 16, fontWeight: 500, color: diff > 0 ? green[6] : red[5] }}>
              <CountUp end={diff} duration={1.5} decimals={0} />%
            </Text>
          </Space>
        </div>
      </div>
    </Card>
  );
};


src\components\dashboard\social\index.ts:
export { SocialStatsCard } from './SocialStatsCard/SocialStatsCard.tsx';
export { FollowersChart } from './FollowersChart/FollowersChart.tsx';
export { LikesChart } from './LikesChart/LikesChart.tsx';
export { DevicesCardChart } from './DevicesCardChart/DevicesCardChart.tsx';
export { MilestonesCard } from './MilestonesCard/MilestonesCard.tsx';
export { CommentsCard } from './CommentsCard/CommentsCard.tsx';


src\components\dashboard\social\CommentsCard\CommentsCard.tsx:
import { ReactNode } from 'react';
import {
  Alert,
  Button,
  CardProps,
  Flex,
  List,
  Space,
  Tag,
  Typography,
} from 'antd';
import {
  ArrowRightOutlined,
  CommentOutlined,
  DeleteOutlined,
  EyeOutlined,
  LikeOutlined,
} from '@ant-design/icons';
import { Comments } from '../../../../types';
import { Card, Loader, UserAvatar } from '../../../index';

import './styles.css';

type Props = {
  data?: Comments[];
  error?: ReactNode;
  loading?: boolean;
} & CardProps;

export const CommentsCard = ({ data, error, loading, ...others }: Props) => (
  <Card
    title="recent comments"
    actions={[
      <Button>
        View all <ArrowRightOutlined />
      </Button>,
    ]}
    className="comments-lists-card card"
    {...others}
  >
    {error ? (
      <Alert
        message="Error"
        description={error.toString()}
        type="error"
        showIcon
      />
    ) : loading ? (
      <Loader />
    ) : (
      <List
        itemLayout="vertical"
        pagination={false}
        dataSource={data}
        renderItem={(item: Comments) => (
          <List.Item key={item.id}>
            <Space direction="vertical" size="small">
              <Flex justify="space-between">
                <UserAvatar
                  fullName={item.author}
                  size="middle"
                  style={{ fontWeight: 500 }}
                />
                <Tag className="text-capitalize" bordered={false}>
                  {item.activity_type}
                </Tag>
              </Flex>
              <Typography.Paragraph ellipsis={{ rows: 3 }} className="m-0">
                {item.post_content}
              </Typography.Paragraph>
              <Flex justify="space-between">
                <Space size="small">
                  <Button shape="circle" type="text">
                    <LikeOutlined />
                  </Button>
                  <Button shape="circle" type="text">
                    <CommentOutlined />
                  </Button>
                  <Button type="text" icon={<EyeOutlined />}>
                    See Post
                  </Button>
                </Space>
                <Button shape="circle" type="text" danger>
                  <DeleteOutlined />
                </Button>
              </Flex>
            </Space>
          </List.Item>
        )}
      />
    )}
  </Card>
);


src\components\dashboard\social\CommentsCard\styles.css:
.comments-lists-card .ant-card-body {
  /*padding: 1rem 0 1rem 0;*/
}

.available-tucks-card .ant-list-item {
  /*padding: 0;*/
}


src\components\dashboard\social\DevicesCardChart\DevicesCardChart.tsx:
import { Button, CardProps, Col, Popover, Row, Space, Typography } from 'antd';
import { Pie } from '@ant-design/charts';
import {
  DesktopOutlined,
  MobileOutlined,
  QuestionOutlined,
  SettingOutlined,
  TabletFilled,
} from '@ant-design/icons';
import { Card } from '../../../index.ts';

const PieChart = () => {
  const data = [
    {
      type: 'Desktop',
      value: 16,
    },
    {
      type: 'Mobile',
      value: 70,
    },
    {
      type: 'Tablet',
      value: 10,
    },
    {
      type: 'Others',
      value: 4,
    },
  ];
  const config = {
    appendPadding: 10,
    data,
    angleField: 'value',
    colorField: 'type',
    radius: 1,
    innerRadius: 0.6,
    label: {
      type: 'inner',
      offset: '-50%',
      content: ({ percent }: any) => `${(percent * 100).toFixed(0)}%`,
      style: {
        textAlign: 'center',
        fontSize: 12,
      },
    },
    interactions: [
      {
        type: 'element-selected',
      },
      {
        type: 'element-active',
      },
    ],
    statistic: {
      title: false,
      content: {
        style: {
          whiteSpace: 'pre-wrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          fontSize: 16,
          fontWeight: 'normal',
        },
        content: 'Devices\nUsage',
      },
    },
    legend: false,
  };

  // @ts-ignore
  return <Pie {...config} />;
};

type Props = CardProps;

export const DevicesCardChart = ({ ...others }: Props) => {
  return (
    <Card
      title="Flow on device"
      extra={
        <Popover content="Stats can help to design post">
          <Button icon={<QuestionOutlined />} type="text" />
        </Popover>
      }
      {...others}
    >
      <Row gutter={[8, 8]} style={{ alignItems: 'center' }}>
        <Col xs={24} sm={10} lg={8}>
          <div style={{ height: 200 }}>
            <PieChart />
          </div>
        </Col>
        <Col xs={24} sm={12} lg={14}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
            }}
          >
            <Space direction="vertical">
              <DesktopOutlined />
              <Typography.Text>Desktop</Typography.Text>
              <Typography.Text style={{ color: '#62daaa' }}>
                70%
              </Typography.Text>
            </Space>
            <Space direction="vertical">
              <MobileOutlined />
              <Typography.Text>Mobile</Typography.Text>
              <Typography.Text style={{ color: '#6394f9' }}>
                16%
              </Typography.Text>
            </Space>
            <Space direction="vertical">
              <TabletFilled />
              <Typography.Text>Tablet</Typography.Text>
              <Typography.Text style={{ color: '#657797' }}>
                10%
              </Typography.Text>
            </Space>
            <Space direction="vertical">
              <SettingOutlined />
              <Typography.Text>Other</Typography.Text>
              <Typography.Text style={{ color: '#f6c022' }}>4%</Typography.Text>
            </Space>
          </div>
        </Col>
      </Row>
    </Card>
  );
};


src\components\dashboard\social\FollowersChart\FollowersChart.tsx:
import { CardProps, Typography } from 'antd';
import { useEffect, useState } from 'react';
import { Line } from '@ant-design/charts';
import { Card } from '../../../index.ts';

type TabKeys = 'all' | 'followers' | 'following' | 'blocked' | string;

type LineProps = {
  type: TabKeys;
};

const LineChart = ({ type }: LineProps) => {
  const dd = [
    {
      month: 'Jan',
      key: 'followers',
      value: 125,
    },
    {
      month: 'Jan',
      key: 'following',
      value: 51,
    },
    {
      month: 'Jan',
      key: 'blocked',
      value: 6,
    },
    {
      month: 'Feb',
      key: 'followers',
      value: 132,
    },
    {
      month: 'Feb',
      key: 'following',
      value: 91,
    },
    {
      month: 'Feb',
      key: 'blocked',
      value: 9,
    },
    {
      month: 'Mar',
      key: 'followers',
      value: 141,
    },
    {
      month: 'Mar',
      key: 'following',
      value: 34,
    },
    {
      month: 'Mar',
      key: 'blocked',
      value: 3,
    },
    {
      month: 'Apr',
      key: 'followers',
      value: 158,
    },
    {
      month: 'Apr',
      key: 'following',
      value: 47,
    },
    {
      month: 'Apr',
      key: 'blocked',
      value: 4,
    },
    {
      month: 'May',
      key: 'followers',
      value: 133,
    },
    {
      month: 'May',
      key: 'following',
      value: 63,
    },
    {
      month: 'May',
      key: 'blocked',
      value: 6,
    },
    {
      month: 'June',
      key: 'followers',
      value: 143,
    },
    {
      month: 'June',
      key: 'following',
      value: 58,
    },
    {
      month: 'June',
      key: 'blocked',
      value: 7,
    },
    {
      month: 'July',
      key: 'followers',
      value: 176,
    },
    {
      month: 'July',
      key: 'following',
      value: 56,
    },
    {
      month: 'July',
      key: 'blocked',
      value: 6,
    },
    {
      month: 'Aug',
      key: 'followers',
      value: 194,
    },
    {
      month: 'Aug',
      key: 'following',
      value: 77,
    },
    {
      month: 'Aug',
      key: 'blocked',
      value: 8,
    },
    {
      month: 'Sep',
      key: 'followers',
      value: 115,
    },
    {
      month: 'Sep',
      key: 'following',
      value: 99,
    },
    {
      month: 'Sep',
      key: 'blocked',
      value: 10,
    },
    {
      month: 'Oct',
      key: 'followers',
      value: 134,
    },
    {
      month: 'Oct',
      key: 'following',
      value: 106,
    },
    {
      month: 'Oct',
      key: 'blocked',
      value: 16,
    },
    {
      month: 'Nov',
      key: 'followers',
      value: 110,
    },
    {
      month: 'Nov',
      key: 'following',
      value: 88,
    },
    {
      month: 'Nov',
      key: 'blocked',
      value: 8,
    },
    {
      month: 'Dec',
      key: 'followers',
      value: 91,
    },
    {
      month: 'Dec',
      key: 'following',
      value: 56,
    },
    {
      month: 'Dec',
      key: 'blocked',
      value: 8,
    },
  ];
  const [data, setData] = useState<any>([]);

  useEffect(() => {
    if (type === 'all') {
      setData(dd);
    } else {
      setData(dd.filter((_) => _.key === type));
    }
  }, [type]);

  const config = {
    data,
    xField: 'month',
    yField: 'value',
    legend: false,
    seriesField: 'key',
    stepType: 'hvh',
  };

  // @ts-ignore
  return <Line {...config} />;
};

const TAB_LIST = [
  {
    key: 'all',
    tab: 'All',
  },
  {
    key: 'followers',
    tab: 'Followers',
  },
  {
    key: 'following',
    tab: 'Following',
  },
  {
    key: 'blocked',
    tab: 'Blocked',
  },
];

const TAB_CONTENT: Record<TabKeys, React.ReactNode> = {
  all: <LineChart type="all" />,
  followers: <LineChart type="followers" />,
  following: <LineChart type="following" />,
  blocked: <LineChart type="blocked" />,
};

type Props = CardProps;

export const FollowersChart = ({ ...others }: Props) => {
  const [activeTabKey, setActiveTabKey] = useState<TabKeys>('all');

  const onTabChange = (key: TabKeys) => {
    setActiveTabKey(key);
  };

  return (
    <Card
      tabList={TAB_LIST}
      activeTabKey={activeTabKey}
      onTabChange={onTabChange}
      tabBarExtraContent={
        <Typography.Title level={5} className="m-0">
          Account activity
        </Typography.Title>
      }
      tabProps={{
        size: 'large',
      }}
      {...others}
    >
      {TAB_CONTENT[activeTabKey]}
    </Card>
  );
};


src\components\dashboard\social\LikesChart\LikesChart.tsx:
import { CardProps } from 'antd';
import { Column } from '@ant-design/charts';
import { Card } from '../../../index.ts';

const ColumnChart = () => {
  const data = [
    {
      name: 'Likes',
      month: 'Jan.',
      rainfall: 18.9,
    },
    {
      name: 'Likes',
      month: 'Feb.',
      rainfall: 28.8,
    },
    {
      name: 'Likes',
      month: 'Mar.',
      rainfall: 39.3,
    },
    {
      name: 'Likes',
      month: 'Apr.',
      rainfall: 81.4,
    },
    {
      name: 'Likes',
      month: 'May',
      rainfall: 47,
    },
    {
      name: 'Likes',
      month: 'Jun.',
      rainfall: 20.3,
    },
    {
      name: 'Likes',
      month: 'Jul.',
      rainfall: 24,
    },
    {
      name: 'Likes',
      month: 'Aug.',
      rainfall: 35.6,
    },
    {
      name: 'Share',
      month: 'Jan.',
      rainfall: 12.4,
    },
    {
      name: 'Share',
      month: 'Feb.',
      rainfall: 23.2,
    },
    {
      name: 'Share',
      month: 'Mar.',
      rainfall: 34.5,
    },
    {
      name: 'Share',
      month: 'Apr.',
      rainfall: 99.7,
    },
    {
      name: 'Share',
      month: 'May',
      rainfall: 52.6,
    },
    {
      name: 'Share',
      month: 'Jun.',
      rainfall: 35.5,
    },
    {
      name: 'Share',
      month: 'Jul.',
      rainfall: 37.4,
    },
    {
      name: 'Share',
      month: 'Aug.',
      rainfall: 42.4,
    },
    {
      name: 'Comments',
      month: 'Jan.',
      rainfall: 8.4,
    },
    {
      name: 'Comments',
      month: 'Feb.',
      rainfall: 33.2,
    },
    {
      name: 'Comments',
      month: 'Mar.',
      rainfall: 24.5,
    },
    {
      name: 'Comments',
      month: 'Apr.',
      rainfall: 79.7,
    },
    {
      name: 'Comments',
      month: 'May',
      rainfall: 42.6,
    },
    {
      name: 'Comments',
      month: 'Jun.',
      rainfall: 65.5,
    },
    {
      name: 'Comments',
      month: 'Jul.',
      rainfall: 57.4,
    },
    {
      name: 'Comments',
      month: 'Aug.',
      rainfall: 52.4,
    },
  ];
  const config = {
    data,
    isGroup: true,
    xField: 'month',
    yField: 'rainfall',
    seriesField: 'name',
    columnStyle: {
      radius: [20, 20, 0, 0],
    },
    label: {
      position: 'top',
    },
    /** Set color */
    //color: ['#1ca9e6', '#f88c24'],
  };

  // @ts-ignore
  return <Column {...config} />;
};

type Props = CardProps;

export const LikesChart = ({ ...others }: Props) => {
  return (
    <Card title="Posts activity" {...others}>
      <ColumnChart />
    </Card>
  );
};


src\components\dashboard\social\MilestonesCard\MilestonesCard.tsx:
import {
  Button,
  CardProps,
  Col,
  Flex,
  List,
  Progress,
  Row,
  Typography,
} from 'antd';
import React from 'react';
import {
  GroupOutlined,
  RadiusSettingOutlined,
  ShareAltOutlined,
} from '@ant-design/icons';
import { Card } from '../../../index.ts';

import './styles.css';

const MOCK_DATA = [
  {
    title: 'ads challenges',
    progress: 56,
    current: 12000,
    target: 20000,
    deadline: '12/05/2023',
    icon: RadiusSettingOutlined,
  },
  {
    title: 'add members',
    progress: 28,
    current: 3400,
    target: 20000,
    deadline: '12/05/2023',
    icon: GroupOutlined,
  },
];

type Props = CardProps;

export const MilestonesCard = ({ ...others }: Props) => {
  return (
    <Card
      title="Milestones"
      extra={<Button icon={<ShareAltOutlined />}>Share</Button>}
      className="milestones-lists-card card"
      {...others}
    >
      <List
        itemLayout="vertical"
        size="large"
        pagination={{
          onChange: (page) => {
            console.log(page);
          },
          pageSize: 3,
          align: 'center',
        }}
        dataSource={MOCK_DATA}
        renderItem={(item) => (
          <List.Item key={item.title}>
            <Row gutter={[8, 8]}>
              <Col xs={2} sm={2} lg={2}>
                <Flex
                  align="center"
                  justify="center"
                  style={{ height: '100%' }}
                >
                  {React.createElement(item.icon, {
                    style: { fontSize: 24, margin: 4 },
                  })}
                </Flex>
              </Col>
              <Col xs={22} sm={6} lg={6}>
                <Flex
                  vertical
                  gap="small"
                  justify="center"
                  style={{ height: '100%' }}
                >
                  <Typography.Title level={5} className="text-capitalize m-0">
                    {item.title}
                  </Typography.Title>
                  <Typography.Text>{item.target} reached</Typography.Text>
                </Flex>
              </Col>
              <Col xs={24} sm={8} lg={8}>
                <Flex vertical justify="center" style={{ height: '100%' }}>
                  <Flex align="end" gap="small">
                    <Typography.Title level={4} className="m-0">
                      {item.progress}%
                    </Typography.Title>
                    <Typography.Text>target</Typography.Text>
                  </Flex>
                  <Progress percent={item.progress} showInfo={false} />
                </Flex>
              </Col>
              <Col xs={12} sm={4} lg={4}>
                <Flex align="center" style={{ height: '100%' }}>
                  <Typography.Text>Deadline: {item.deadline}</Typography.Text>
                </Flex>
              </Col>
              <Col xs={12} sm={4} lg={4}>
                <Flex align="center" style={{ height: '100%' }}>
                  <Button size="middle" type="link">
                    View details
                  </Button>
                </Flex>
              </Col>
            </Row>
          </List.Item>
        )}
        className="overflow-scroll"
      />
    </Card>
  );
};


src\components\dashboard\social\MilestonesCard\styles.css:
.milestones-lists-card .ant-card-body {
  padding: 0 0 1rem 0;
}

.available-tucks-card .ant-list-item {
  /*padding: 0;*/
}


src\components\dashboard\social\SocialStatsCard\SocialStatsCard.tsx:
import { Alert, CardProps, Flex, Typography } from 'antd';
import {
  CommentOutlined,
  LikeOutlined,
  UserAddOutlined,
  UserOutlined,
  UserSwitchOutlined,
} from '@ant-design/icons';
import { ReactElement, ReactNode } from 'react';
import { Card, Loader } from '../../../index';
import CountUp from 'react-countup';

type Props = {
  title: 'followers' | 'following' | 'likes' | 'comments' | string;
  value?: number;
  error?: ReactNode;
  loading?: boolean;
} & CardProps;

export const SocialStatsCard = ({
  value,
  title,
  loading,
  error,
  ...others
}: Props) => {
  const Icon = (): ReactElement => {
    let i;
    switch (title) {
      case 'following':
        i = <UserAddOutlined style={{ fontSize: 30 }} />;
        break;
      case 'followers':
        i = <UserSwitchOutlined style={{ fontSize: 30 }} />;
        break;
      case 'likes':
        i = <LikeOutlined style={{ fontSize: 30 }} />;
        break;
      case 'comments':
        i = <CommentOutlined style={{ fontSize: 30 }} />;
        break;
      default:
        i = <UserOutlined style={{ fontSize: 30 }} />;
        break;
    }

    return i;
  };

  return (
    <Card {...others}>
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <Flex vertical gap="middle">
          <Icon />
          <Typography.Text className="text-capitalize">{title}</Typography.Text>
          <Typography.Title level={2} className="m-0">
            <CountUp end={value || 0} />
          </Typography.Title>
        </Flex>
      )}
    </Card>
  );
};


src\components\dashboard\users\index.tsx:
export {UserTable} from './UserTable';

src\components\dashboard\users\UserTable.tsx:
import {
    Alert,
    Badge,
    BadgeProps,
    Button,
    Form,
    Input,
    Modal,
    Table,
} from 'antd';
// import { useNavigate } from 'react-router-dom';  
import { Card } from '../..';
import { useState } from 'react';
// navigate: ReturnType<typeof useNavigate>
const USER_COLUMNS = () => [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
    },
    {
      title: 'Full Name',
      dataIndex: 'full_name',
      key: 'name',
    },
    {
      title: 'Email Address',
      dataIndex: 'email',
      key: 'emailAddress',
    },
    {
      title: 'Gender',
      dataIndex: 'gender',
      key: 'gender',
    },
    {
      title: 'Job Title',
      dataIndex: 'title',
      key: 'title',
    },
    // {
    //   title: 'Actions',
    //   dataIndex: 'id',
    //   key: 'id',
    //   render: (value,record) => (
    //     <div>
    //     <Button type="primary" onClick={() => navigate(`/details/events/${record.id}`)}>
    //       Details
    //     </Button>
    //     </div>
    //   )
    // }
    {
      title: 'Current Status',
      dataIndex: 'status',
      key: 'status',
      render: (_: any) => {
        let status: BadgeProps['status'];
  
        if (_ === 'offline') {
          status = 'default';
        } else if (_ === 'online') {
          status = 'success';
        } 
  
        return <Badge status={status} text={_} className="text-capitalize" />;
      },
    }
  ];
  interface UserTableProps {
    data: [];
    error?: string;
    loading: boolean;
  }

export const UserTable : React.FC<UserTableProps> = ({data,error,loading} ) => {
        // Modal State for create user
        const [isCreateUserModalOpen, setIsCreateUserModalOpen] = useState<any>(false);
  
        const showCreateUserModal = () => {
          setIsCreateUserModalOpen(true);
        };
      
        const handleOkCreateUser = () => {
          setIsCreateUserModalOpen(false);
        };
      
        const handleCancelCreateUser = () => {
          setIsCreateUserModalOpen(false);
        };
  // const navigate = useNavigate();
  return (
    <div>
          <Card title="Your Events" extra={<Button onClick={showCreateUserModal}>Create New User</Button>}>
            {error ? (
              <Alert
                message="Error"
                description={error.toString()}
                type="error"
                showIcon
              />
            ) : (
              <Table
                columns={USER_COLUMNS()}
                dataSource={data}
                loading={loading}
                className="overflow-scroll"
              />
            )}
          </Card>
          <Modal title="Create Event User" open={isCreateUserModalOpen} onOk={handleOkCreateUser} onCancel={handleCancelCreateUser}>
          <Form layout='vertical'>
            <Form.Item label="User's Email">
              <Input placeholder="example@email.com" />
            </Form.Item>
            <Form.Item label="User's Full Name">
              <Input placeholder="John Doe" />
            </Form.Item>
            <Form.Item label="User's Title">
              <Input placeholder="Software Engineer" />
            </Form.Item>
          </Form>
      </Modal>
    </div>
  )
}


src\components\EmployeeCard\EmployeeCard.tsx:
import { Employee } from '../../types';
import { Card as AntdCard, CardProps, Flex, Typography } from 'antd';

const { Meta } = AntdCard;

type Props = {
  data: Employee;
  showInfo?: boolean;
} & CardProps;

export const EmployeeCard = ({ data, showInfo, ...others }: Props) => {
  const {
    avatar,
    first_name,
    middle_name,
    last_name,
    role,
    age,
    country,
    title,
    email,
    hire_date,
  } = data;

  return (
    <AntdCard
      hoverable
      cover={
        <img
          alt={`${first_name} image`}
          src={avatar}
          height={240}
          style={{ objectFit: 'cover' }}
        />
      }
      {...others}
    >
      <Meta title={`${title}. ${first_name} ${middle_name} ${last_name}`} />
      <Flex vertical gap="small" style={{ marginTop: '8px' }}>
        <Typography.Text>{role}</Typography.Text>
        {showInfo && (
          <>
            <Typography.Text>Email: {email}</Typography.Text>
            <Typography.Text>Country: {country}</Typography.Text>
            <Typography.Text>Age: {age}</Typography.Text>
            <Typography.Text>Join date: {hire_date}</Typography.Text>
          </>
        )}
      </Flex>
    </AntdCard>
  );
};


src\components\FaqCollapse\FaqCollapse.tsx:
import { Collapse, CollapseProps } from 'antd';

type Props = CollapseProps;

export const FaqCollapse = ({ ...others }: Props) => {
  return <Collapse {...others} />;
};


src\components\Flex\Flex.tsx:
import { CSSProperties, ReactNode } from 'react';

type Props = {
  gap?: 'small' | 'middle' | 'large' | number;
  justifyContent?: CSSProperties['justifyContent'];
  alignItems?: CSSProperties['alignItems'];
  flexDirection?: CSSProperties['flexDirection'];
  children: ReactNode;
} & CSSProperties;

export const Flex = ({
  flexDirection,
  alignItems,
  gap,
  justifyContent,
  children,
  ...others
}: Props) => {
  return (
    <div
      style={{
        width: '100%',
        display: 'flex',
        flexDirection,
        justifyContent,
        alignItems,
        gap:
          typeof gap === 'number'
            ? gap
            : gap === 'large'
              ? '24px'
              : gap === 'small'
                ? '8px'
                : '16px',
        ...others,
      }}
    >
      {children}
    </div>
  );
};


src\components\Loader\Loader.tsx:
import { Spin, theme } from 'antd';

import './styles.css';

export const Loader = () => {
  const {
    token: { borderRadius },
  } = theme.useToken();

  return (
    <div className="loader-container" style={{ borderRadius }}>
      <Spin tip="Loading">
        <div className="content" />
      </Spin>
    </div>
  );
};


src\components\Loader\styles.css:
.loader-container {
  text-align: center;
  background: rgba(0, 0, 0, 0.05);
}

.content {
  padding: 50px;
}


src\components\Logo\Logo.tsx:
import { Flex, FlexProps, theme, Typography } from 'antd';
import { Link } from 'react-router-dom';
import { CSSProperties } from 'react';

import './styles.css';

type LogoProps = {
  color: CSSProperties['color'];
  imgSize?: {
    h?: number | string;
    w?: number | string;
  };
  asLink?: boolean;
  href?: string;
  bgColor?: CSSProperties['backgroundColor'];
} & Partial<FlexProps>;

export const Logo = ({
  asLink,
  color,
  href,
  imgSize,
  bgColor,
  ...others
}: LogoProps) => {
  const {
    token: { borderRadius },
  } = theme.useToken();

  return asLink ? (
    <Link to={'/dashboards/general'} className="logo-link">
      <Flex gap={others.gap || 'small'} align="center" {...others}>
        <img
          src="/tdtu_logo.jpg"
          alt="design sparx logo"
          height={imgSize?.h || 48}
        />
        <Typography.Title
          level={5}
          type="secondary"
          style={{
            color,
            margin: 0,
            padding: `4px 8px`,
            backgroundColor: bgColor,
            borderRadius,
          }}
        >
          TDTUEVENT
        </Typography.Title>
      </Flex>
    </Link>
  ) : (
    <Flex gap={others.gap || 'small'} align="center" {...others}>
      <img
        src="/tdtu_logo.jpg"
        alt="design sparx logo"
        height={imgSize?.h || 48}
      />
      <Typography.Title
        level={4}
        type="secondary"
        style={{
          color,
          margin: 0,
          padding: `4px 8px`,
          backgroundColor: bgColor,
          borderRadius,
        }}
      >
        TDTUEVENT
      </Typography.Title>
    </Flex>
  );
};


src\components\Logo\styles.css:
.logo-link {
  text-decoration: none;
}

.logo-link:hover,
.logo-link:focus {
  text-decoration: underline;
}


src\components\MoreMenu\MoreMenu.tsx:
import { Button, Dropdown, MenuProps } from 'antd';
import {
  DeleteOutlined,
  ExpandOutlined,
  MinusOutlined,
  MoreOutlined,
  SyncOutlined,
} from '@ant-design/icons';

const items: MenuProps['items'] = [
  {
    label: 'Expand',
    key: '1',
    icon: <ExpandOutlined />,
  },
  {
    label: 'Minimize',
    key: '2',
    icon: <MinusOutlined />,
  },
  {
    label: 'Reload',
    key: '3',
    icon: <SyncOutlined />,
  },
  {
    label: 'Remove',
    key: '4',
    icon: <DeleteOutlined />,
    danger: true,
  },
];

export const MoreMenu = () => {
  return (
    <Dropdown menu={{ items }} placement="bottomLeft">
      <Button>
        More <MoreOutlined />
      </Button>
    </Dropdown>
  );
};


src\components\NotificationsCard\NotificationsCard.tsx:
import { Alert, Button, CardProps, List } from 'antd';
import { Card, Loader, NotificationsItem } from '../index.ts';
import { Notifications } from '../../types';

import './styles.css';

type Props = {
  data?: Notifications[];
  loading?: boolean;
  error?: any;
} & CardProps;

export const NotificationsCard = ({
  data,
  loading,
  error,
  ...others
}: Props) => {
  return (
    <Card
      title="Notifications"
      extra={<Button>View all</Button>}
      className="card notifications-list-card"
      {...others}
    >
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <List
          itemLayout="vertical"
          size="large"
          pagination={{
            onChange: (page) => {
              console.log(page);
            },
            pageSize: 5,
            align: 'center',
          }}
          dataSource={data}
          renderItem={(item) => (
            <List.Item key={item.notification_id}>
              <NotificationsItem data={item} />
            </List.Item>
          )}
        />
      )}
    </Card>
  );
};


src\components\NotificationsCard\styles.css:
.notifications-list-card .ant-card-body {
  padding: 0 0 1rem 0;
}

.available-tucks-card .ant-list-item {
  /*padding: 0;*/
}


src\components\NotificationsItem\NotificationsItem.tsx:
import { Notifications } from '../../types';
import { Avatar, Flex, FlexProps, Tag, Typography } from 'antd';
import {
  ContainerOutlined,
  MailOutlined,
  PhoneOutlined,
} from '@ant-design/icons';

type Props = {
  data: Notifications;
} & Omit<FlexProps, 'children'>;

export const NotificationsItem = ({ data, ...others }: Props) => {
  const {
    notification_type,
    notification_category,
    notification_image,
    notification_date,
    notification_message,
    color,
  } = data;

  return (
    <Flex gap="small" {...others}>
      <Avatar src={notification_image} />
      <Flex vertical gap="small" style={{ flexGrow: 1 }}>
        <Flex align="center" justify="space-between">
          <Typography.Text>
            {notification_message.slice(0, 30)}...
          </Typography.Text>
          <Tag
            bordered={true}
            icon={
              notification_type === 'voice' ? (
                <PhoneOutlined />
              ) : notification_type === 'email' ? (
                <MailOutlined />
              ) : (
                <ContainerOutlined />
              )
            }
            style={{ textTransform: 'capitalize' }}
          >
            {notification_type}
          </Tag>
        </Flex>
        <Flex justify="space-between" align="center">
          <Tag bordered={true} color={color}>
            {notification_category}
          </Tag>
          <Typography.Text>{notification_date}</Typography.Text>
        </Flex>
      </Flex>
    </Flex>
  );
};


src\components\Nprogress\Bar.tsx:
type Props = {
  animationDuration: number;
  progress: number;
};

export const Bar = ({ animationDuration, progress }: Props) => (
  <div
    style={{
      background: '#29d',
      height: 2,
      left: 0,
      marginLeft: `${(-1 + progress) * 100}%`,
      position: 'fixed',
      top: 0,
      transition: `margin-left ${animationDuration}ms linear`,
      width: '100%',
      zIndex: 1031,
    }}
  >
    <div
      style={{
        boxShadow: '0 0 10px #29d, 0 0 5px #29d',
        display: 'block',
        height: '100%',
        opacity: 1,
        position: 'absolute',
        right: 0,
        transform: 'rotate(3deg) translate(0px, -4px)',
        width: 100,
      }}
    />
  </div>
);


src\components\Nprogress\Container.tsx:
import { ReactNode } from 'react';

type Props = {
  animationDuration: number;
  isFinished: boolean;
  children: ReactNode;
};

export const NContainer = ({
  animationDuration,
  children,
  isFinished,
}: Props) => (
  <div
    style={{
      opacity: isFinished ? 0 : 1,
      pointerEvents: 'none',
      transition: `opacity ${animationDuration}ms linear`,
    }}
  >
    {children}
  </div>
);


src\components\Nprogress\index.ts:
export { Bar } from './Bar.tsx';
export { NContainer } from './Container.tsx';
export { NProgress } from './Progress.tsx';
export { NSpinner } from './Spinner.tsx';


src\components\Nprogress\Progress.tsx:
import { useNProgress } from '@tanem/react-nprogress';
import { NContainer } from './Container.tsx';
import { Bar } from './Bar.tsx';
import { NSpinner } from './Spinner.tsx';

type Props = {
  isAnimating?: boolean;
};

export const NProgress = ({ isAnimating }: Props) => {
  const { animationDuration, isFinished, progress } = useNProgress({
    isAnimating,
  });

  return (
    <NContainer animationDuration={animationDuration} isFinished={isFinished}>
      <Bar animationDuration={animationDuration} progress={progress} />
      <NSpinner />
      {/*
              This example doesn't use a spinner component so the UI stays
              tidy. You're free to render whatever is appropriate for your
              use-case.
              */}
    </NContainer>
  );
};


src\components\Nprogress\spinner.css:
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}


src\components\Nprogress\Spinner.tsx:
import './spinner.css';

export const NSpinner = () => (
  <div
    style={{
      display: 'block',
      position: 'fixed',
      right: 15,
      top: 15,
      zIndex: 1031,
    }}
  >
    <div
      style={{
        animation: '400ms linear infinite spinner',
        borderBottom: '2px solid transparent',
        borderLeft: '2px solid #29d',
        borderRadius: '50%',
        borderRight: '2px solid transparent',
        borderTop: '2px solid #29d',
        boxSizing: 'border-box',
        height: 36,
        width: 36,
      }}
    />
  </div>
);


src\components\PageHeader\PageHeader.tsx:
import React from 'react';
import { Breadcrumb, BreadcrumbProps, Divider, Space, Typography } from 'antd';

import './styles.css';

type Props = {
  title: string;
  breadcrumbs: BreadcrumbProps['items'];
  btnBack?: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>;


export const PageHeader = ({ breadcrumbs, title, ...others }: Props) => {
  return (
    <div {...others}>
      <Space direction="vertical" size="small">
        <Typography.Title
          level={4}
          style={{ padding: 0, margin: 0, textTransform: 'capitalize' }}
        >
          {title}
        </Typography.Title>
        <Breadcrumb items={breadcrumbs} className="page-header-breadcrumbs" />
      </Space>
      <Divider orientation="right" plain>
        <span style={{ textTransform: 'capitalize' }}>{title}</span>
      </Divider>
    </div>
  );
};


src\components\PageHeader\styles.css:
.page-header-breadcrumbs .ant-breadcrumb-link {
  text-transform: capitalize !important;
}

.ant-dropdown .ant-dropdown-menu-item .ant-dropdown-menu-title-content {
  text-transform: capitalize !important;
}


src\components\PricingTable\PricingTable.tsx:
import { Pricing } from '../../types';
import {
  Alert,
  Card as AntdCard,
  CardProps,
  Col,
  List,
  Row,
  Segmented,
  Space,
  theme,
  Typography,
} from 'antd';
import { CheckCircleOutlined } from '@ant-design/icons';
import { Card, Loader } from '../index.ts';
import { ReactNode, useState } from 'react';
import { useStylesContext } from '../../context';
import CountUp from 'react-countup';

const textStyles = (
  preferred?: boolean,
  primary?: string
): React.CSSProperties => {
  return {
    color: preferred ? 'white' : primary ? primary : 'initial',
    textTransform: 'capitalize',
    textAlign: 'center',
  };
};

type Props = {
  data?: Pricing[];
  error?: ReactNode;
  loading?: boolean;
} & CardProps;

export const PricingTable = ({ data, error, loading, ...others }: Props) => {
  const {
    token: { colorPrimary, colorFillSecondary },
  } = theme.useToken();
  const [value, setValue] = useState<'monthly' | 'annually' | string | number>(
    'monthly'
  );
  const stylesContext = useStylesContext();

  return (
    <Card
      title="Pricing"
      actions={[
        <Typography.Text italic>
          Note: All plans come with a 30-day money-back guarantee.
        </Typography.Text>,
      ]}
      {...others}
    >
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <>
          <div
            className="text-capitalize text-center"
            style={{ marginBottom: '1rem' }}
          >
            <Segmented
              size="large"
              options={['monthly', 'annually']}
              value={value}
              onChange={setValue}
            />
          </div>
          <Row {...stylesContext?.rowProps}>
            {data?.map((d, i) => (
              <Col sm={24} lg={8} key={`${d.color}-${i}`}>
                <AntdCard
                  style={{
                    background: d.preferred ? colorPrimary : colorFillSecondary,
                    border: `1px solid ${
                      d.preferred ? colorPrimary : colorFillSecondary
                    }`,
                  }}
                >
                  <Typography.Text
                    strong
                    style={{
                      ...textStyles(d.preferred, colorPrimary),
                      fontSize: 16,
                    }}
                  >
                    {d.plan}
                  </Typography.Text>
                  <Typography.Title
                    style={{ margin: '1rem 0', ...textStyles(d.preferred) }}
                  >
                    ${' '}
                    <CountUp
                      decimals={2}
                      end={value === 'monthly' ? d.monthly : d.annually}
                    />
                    /
                    <small
                      style={{
                        fontSize: 16,
                        fontWeight: 400,
                        textTransform: 'lowercase',
                      }}
                    >
                      per {value === 'monthly' ? 'month' : 'year'}
                    </small>
                  </Typography.Title>
                  <List
                    header={
                      <Typography.Text style={textStyles(d.preferred)}>
                        Features
                      </Typography.Text>
                    }
                    dataSource={d.features}
                    renderItem={(item) => (
                      <List.Item>
                        <Space>
                          <CheckCircleOutlined
                            style={textStyles(d.preferred)}
                          />
                          <Typography.Text style={textStyles(d.preferred)}>
                            {item}
                          </Typography.Text>
                        </Space>
                      </List.Item>
                    )}
                  />
                </AntdCard>
              </Col>
            ))}
          </Row>
        </>
      )}
    </Card>
  );
};


src\components\RefreshBtn\RefreshBtn.tsx:
import { Button, ButtonProps } from 'antd';
import { SyncOutlined } from '@ant-design/icons';

type Props = {
  icon?: boolean;
} & ButtonProps;

export const RefreshBtn = ({ icon, ...others }: Props) => {
  return (
    <Button
      icon={icon ? <SyncOutlined /> : null}
      onClick={() => window.location.reload()}
      {...others}
    >
      Refresh page
    </Button>
  );
};


src\components\SitemapCard\SitemapCard.tsx:
import { CardProps, Flex, Typography } from 'antd';
import { Card } from '../index.ts';

import './styles.css';
import { Link } from 'react-router-dom';

type Props = {
  data: {
    title: string;
    links: { title: string; path: string }[];
  };
} & CardProps;

export const SitemapCard = ({ data, ...others }: Props) => {
  return (
    <Card {...others}>
      <Flex vertical gap="middle">
        <Typography.Title level={5} className="m-0 text-capitalize">
          {data.title}
        </Typography.Title>
        <Flex gap="middle" wrap="wrap">
          {data.links.map((d) => (
            <Link to={d.path} className="text-capitalize">
              {d.title}
            </Link>
          ))}
        </Flex>
      </Flex>
    </Card>
  );
};


src\components\SitemapCard\styles.css:
.sitemap-card .ant-card-body {
  padding: 0;
}

.sitemap-card .ant-list-item {
  text-transform: capitalize;
}


src\components\SocialMediaCard\SocialMediaCard.tsx:
import { Button, ButtonProps, CardProps, Flex } from 'antd';
import { Card } from '../index.ts';
import {
  FacebookFilled,
  GithubFilled,
  InstagramFilled,
  LinkedinFilled,
  TwitterCircleFilled,
} from '@ant-design/icons';

const BUTTON_PROPS: ButtonProps = {
  type: 'link',
  style: {
    textAlign: 'start',
  },
};

type Props = CardProps;

export const SocialMediaCard = ({ ...others }: Props) => {
  return (
    <Card title="Social Media" {...others}>
      <Flex vertical gap="small">
        <Button icon={<FacebookFilled />} {...BUTTON_PROPS}>
          Facebook
        </Button>
        <Button icon={<InstagramFilled />} {...BUTTON_PROPS}>
          Instagram
        </Button>
        <Button icon={<TwitterCircleFilled />} {...BUTTON_PROPS}>
          Facebook
        </Button>
        <Button icon={<LinkedinFilled />} {...BUTTON_PROPS}>
          Facebook
        </Button>
        <Button icon={<GithubFilled />} {...BUTTON_PROPS}>
          Facebook
        </Button>
      </Flex>
    </Card>
  );
};


src\components\TimelineCard\TimelineCard.tsx:
import { Alert, CardProps, Flex, Timeline, Typography } from 'antd';
import {
  LaptopOutlined,
  MobileOutlined,
  TabletOutlined,
} from '@ant-design/icons';
import { ActivityTimeline } from '../../types';
import { Card, Loader } from '../index.ts';
import { ReactNode } from 'react';

type Props = {
  data?: ActivityTimeline[];
  loading?: boolean;
  error?: ReactNode;
} & CardProps;

export const TimelineCard = ({ data, error, loading, ...others }: Props) => {
  return (
    <Card title="Latest activities" {...others}>
      {error ? (
        <Alert
          message="Error"
          description={error.toString()}
          type="error"
          showIcon
        />
      ) : loading ? (
        <Loader />
      ) : (
        <Timeline
          mode="left"
          items={data?.map((_) => ({
            dot:
              _.device_type === 'desktop' ? (
                <LaptopOutlined />
              ) : _.device_type === 'tablet' ? (
                <TabletOutlined />
              ) : (
                <MobileOutlined />
              ),
            children: (
              <Flex gap="small" vertical>
                <Typography.Paragraph
                  ellipsis={{
                    rows: 2,
                  }}
                  title={`${_.post_content}--${_.timestamp}`}
                  style={{ marginBottom: 0 }}
                >
                  {_.post_content}
                </Typography.Paragraph>
                <Typography.Text type="secondary">
                  {_.timestamp}
                </Typography.Text>
              </Flex>
            ),
          }))}
        />
      )}
    </Card>
  );
};


src\components\UserAvatar\UserAvatar.tsx:
// src\components\UserAvatar\UserAvatar.tsx
import { Avatar, AvatarProps, Flex, FlexProps, theme, Typography } from 'antd';
import { colourNameToHex, getNameInitials, isColorLight } from '../../utils';
import { CheckCircleFilled, UserOutlined } from '@ant-design/icons';
import { blue } from '@ant-design/colors';
import { CSSProperties } from 'react';

type Props = {
  fullName: string;
  mark?: boolean;
  size?: 'small' | 'middle' | 'large';
  verified?: boolean;
  color?: CSSProperties['color'];
  textWidth?: CSSProperties['width'];
  avatarUrl?: string | null; // Add avatarUrl prop
} & Omit<FlexProps, 'children'>;

export const UserAvatar = ({
  fullName,
  mark,
  size,
  verified,
  color,
  textWidth,
  avatarUrl, // Use avatarUrl prop
  ...others
}: Props) => {
  const {
    token: { colorPrimary },
  } = theme.useToken();

  const avatarProps: AvatarProps = {
    size: size === 'large' ? 36 : size === 'small' ? 18 : 24,
    src: avatarUrl, // Set src from avatarUrl prop
    icon: !avatarUrl ? <UserOutlined /> : undefined, // Show default icon if no avatarUrl
  };

  return (
    <Flex gap="small" align="center" {...others}>
      {mark ? (
        <Avatar
          style={{
            backgroundColor: color || colorPrimary,
            color: isColorLight(colourNameToHex(color || colorPrimary))
              ? 'black'
              : 'white',
          }}
          icon={<UserOutlined />}
          {...avatarProps}
        />
      ) : (
        <Avatar
          style={{
            backgroundColor: color || colorPrimary,
            color: isColorLight(colourNameToHex(color || colorPrimary))
              ? 'black'
              : 'white',
          }}
          {...avatarProps}
        >
          {!avatarUrl && getNameInitials(fullName)} {/* Show initials only if no avatarUrl */}
        </Avatar>
      )}
      <Typography.Text
        style={{
          fontSize: size === 'large' ? 18 : size === 'small' ? 14 : 16,
          width: textWidth || 160,
        }}
      >
        {fullName}
      </Typography.Text>
      {verified && (
        <CheckCircleFilled style={{ fontSize: 14, color: blue[6] }} />
      )}
    </Flex>
  );
};

src\constants\index.ts:
import {
  PATH_CALENDAR,
  PATH_INBOX,
  PATH_ACCOUNT,
  PATH_AUTH,
  PATH_BLOG,
  PATH_CAREERS,
  PATH_CHANGELOG,
  PATH_CONTACTS,
  PATH_DASHBOARD,
  PATH_DOCS,
  PATH_ERROR,
  PATH_FILE,
  PATH_GITHUB,
  PATH_INVOICE,
  PATH_LAYOUT,
  PATH_PROJECTS,
  PATH_SOCIAL,
  PATH_START,
  PATH_SUBSCRIPTION,
  PATH_USER_MGMT,
  PATH_USER_PROFILE,
  PATH_LANDING,
  PATH_SITEMAP,
  PATH_SOCIALS,
  PATH_ABOUT,
} from './routes.ts';

const DASHBOARD_ITEMS = [
  { title: 'general', path: PATH_DASHBOARD.general },
  { title: 'projects', path: PATH_DASHBOARD.projects },
  { title: 'events', path: PATH_DASHBOARD.events },
  { title: 'my events', path: PATH_DASHBOARD.my_events },

  {title: 'participated events', path: PATH_DASHBOARD.participated_events},
  { title: 'speakers & guests', path: PATH_DASHBOARD.speaker_guest },
];

const USER_PROFILE_ITEMS = [
  { title: 'information', path: PATH_USER_PROFILE.personalInformation },
  { title: 'security', path: PATH_USER_PROFILE.security },
  { title: 'feedback', path: PATH_USER_PROFILE.feedback },
];

const AUTHENTICATION_ITEMS = [
  { title: 'sign in', path: PATH_AUTH.signin },
  { title: 'sign up', path: PATH_AUTH.signup },
  { title: 'welcome', path: PATH_AUTH.welcome },
  { title: 'verify email', path: PATH_AUTH.verifyEmail },
  { title: 'password reset', path: PATH_AUTH.passwordReset },
  { title: 'account deleted', path: PATH_AUTH.accountDelete },
];

const ERROR_ITEMS = [
  { title: '400', path: PATH_ERROR.error400 },
  { title: '403', path: PATH_ERROR.error403 },
  { title: '404', path: PATH_ERROR.error404 },
  { title: '500', path: PATH_ERROR.error500 },
  { title: '503', path: PATH_ERROR.error503 },
];

export {
  PATH_CALENDAR,
  PATH_USER_MGMT,
  PATH_INBOX,
  PATH_PROJECTS,
  PATH_LAYOUT,
  PATH_CONTACTS,
  PATH_DASHBOARD,
  PATH_CHANGELOG,
  PATH_CAREERS,
  PATH_ACCOUNT,
  PATH_GITHUB,
  PATH_AUTH,
  PATH_INVOICE,
  PATH_BLOG,
  PATH_ERROR,
  PATH_DOCS,
  PATH_SUBSCRIPTION,
  PATH_USER_PROFILE,
  PATH_FILE,
  PATH_SOCIAL,
  PATH_START,
  PATH_LANDING,
  PATH_SITEMAP,
  DASHBOARD_ITEMS,
  USER_PROFILE_ITEMS,
  PATH_SOCIALS,
  AUTHENTICATION_ITEMS,
  ERROR_ITEMS,
  PATH_ABOUT,
};


src\constants\routes.ts:
function path(root: string, sublink: string) {
  return `${root}${sublink}`;
}

const ROOTS_LANDING = '/';
const ROOTS_DASHBOARD = '/dashboards';
const ROOTS_SITEMAP = '/sitemap';
const ROOTS_LAYOUT = '/layouts';
const ROOTS_PROFILE = '/user-profile';
const ROOTS_SOCIAL = '/social';
const ROOTS_BLOG = '/blog';
const ROOTS_CAREERS = '/careers';
const ROOTS_ACCOUNT = '/account';
const ROOTS_AUTH = '/auth';
const ROOTS_PROJECTS = '/projects';
const ROOTS_CONTACTS = '/contacts';
const ROOTS_USER_MGMT = '/user-management';
const ROOTS_SUBSCRIPTION = '/subscription';
const ROOTS_INVOICE = '/invoice';
const ROOTS_FILE_MGMT = '/file-manager';
const ROOTS_INBOX = '/inbox';
const ROOTS_CALENDAR = '/calendar';
const ROOTS_ERRORS = '/errors';
const ROOTS_ABOUT = '/about';

export const PATH_LANDING = {
  root: ROOTS_LANDING,
  why: '/why-us',
  pricing: '/pricing',
  about: '/about',
  contact: '/contact',
};

export const PATH_DASHBOARD = {
  root: ROOTS_DASHBOARD,
  projects: path(ROOTS_DASHBOARD, '/projects'),
  general: path(ROOTS_DASHBOARD, '/general'),
  events : path(ROOTS_DASHBOARD, '/events-list'),
  my_events : path(ROOTS_DASHBOARD, '/my-events'),
  users : path(ROOTS_DASHBOARD, '/users'),
  participated_events: path(ROOTS_DASHBOARD, '/participated-events'),
  events_list: path(ROOTS_DASHBOARD, '/events-list'),
  speaker_guest: path(ROOTS_DASHBOARD, '/speakers-guests'),
};

export const PATH_SITEMAP = {
  root: ROOTS_SITEMAP,
};

export const PATH_LAYOUT = {
  root: ROOTS_LAYOUT,
  sidebar: {
    light: path(ROOTS_LAYOUT, '/sidebar/light'),
    dark: path(ROOTS_LAYOUT, '/sidebar/dark'),
    minimized: path(ROOTS_LAYOUT, '/sidebar/minimized'),
  },
  header: {
    light: path(ROOTS_LAYOUT, '/header/light'),
    dark: path(ROOTS_LAYOUT, '/header/dark'),
    overlay: path(ROOTS_LAYOUT, '/header/overlay'),
  },
};

export const PATH_USER_PROFILE = {
  root: ROOTS_PROFILE,
  personalInformation: path(ROOTS_PROFILE, '/personal-information'),
  security: path(ROOTS_PROFILE, '/security'),
  feedback: path(ROOTS_PROFILE, '/feedback'),
};

export const PATH_SOCIAL = {
  root: ROOTS_SOCIAL,
  feed: path(ROOTS_SOCIAL, '/feed'),
  activity: path(ROOTS_SOCIAL, '/activity'),
  followers: path(ROOTS_SOCIAL, '/followers'),
  settings: path(ROOTS_SOCIAL, '/settings'),
};

export const PATH_BLOG = {
  root: ROOTS_BLOG,
  details: (id: string | number): string => path(ROOTS_BLOG, `/view/${id}`),
};

export const PATH_CAREERS = {
  root: ROOTS_CAREERS,
  new: path(ROOTS_CAREERS, `/new`),
};

export const PATH_ACCOUNT = {
  root: ROOTS_ACCOUNT,
  settings: path(ROOTS_ACCOUNT, '/settings'),
  security: path(ROOTS_ACCOUNT, '/security'),
  activity: path(ROOTS_ACCOUNT, '/activity'),
  billing: path(ROOTS_ACCOUNT, '/billing'),
  statements: path(ROOTS_ACCOUNT, '/statements'),
  referral: path(ROOTS_ACCOUNT, '/referral'),
  api: path(ROOTS_ACCOUNT, '/api-keys'),
  logs: path(ROOTS_ACCOUNT, '/logs'),
};

export const PATH_AUTH = {
  root: ROOTS_AUTH,
  signin: path(ROOTS_AUTH, '/signin'),
  signup: path(ROOTS_AUTH, '/signup'),
  passwordReset: path(ROOTS_AUTH, '/password-reset'),
  passwordConfirm: path(ROOTS_AUTH, '/password-confirmation'),
  welcome: path(ROOTS_AUTH, '/welcome'),
  verifyEmail: path(ROOTS_AUTH, '/verify-email'),
  accountDelete: path(ROOTS_AUTH, '/account-delete'),
};

export const PATH_ERROR = {
  root: ROOTS_ERRORS,
  error400: path(ROOTS_ERRORS, '/400'),
  error403: path(ROOTS_ERRORS, '/403'),
  error404: path(ROOTS_ERRORS, '/404'),
  error500: path(ROOTS_ERRORS, '/500'),
  error503: path(ROOTS_ERRORS, '/503'),
};

export const PATH_PROJECTS = {
  root: ROOTS_PROJECTS,
  details: (id: string | number): string => path(ROOTS_PROJECTS, `/view/${id}`),
};

export const PATH_CONTACTS = {
  root: ROOTS_CONTACTS,
  details: (id: string | number): string => path(ROOTS_CONTACTS, `/view/${id}`),
  new: path(ROOTS_CONTACTS, '/new'),
  editDetails: (id: string | number): string =>
    path(ROOTS_CONTACTS, `/edit/${id}`),
};

export const PATH_USER_MGMT = {
  root: ROOTS_USER_MGMT,
  users: {
    all: path(ROOTS_USER_MGMT, '/users'),
    details: (id: string | number): string =>
      path(ROOTS_USER_MGMT, `/view/${id}`),
  },
  roles: {
    all: path(ROOTS_USER_MGMT, '/roles'),
    details: (id: string | number): string =>
      path(ROOTS_USER_MGMT, `/roles/view/${id}`),
  },
  permissions: path(ROOTS_USER_MGMT, '/permissions'),
};

export const PATH_INVOICE = {
  root: ROOTS_INVOICE,
  new: path(ROOTS_INVOICE, `/new`),
  details: (id: string | number): string =>
    path(ROOTS_USER_MGMT, `/view/${id}`),
};

export const PATH_FILE = {
  root: ROOTS_FILE_MGMT,
  files: path(ROOTS_FILE_MGMT, `/files`),
  blank: path(ROOTS_FILE_MGMT, `/blank`),
};

export const PATH_INBOX = {
  root: ROOTS_INBOX,
  new: path(ROOTS_INBOX, `/new`),
  details: (id: string | number): string => path(ROOTS_INBOX, `/view/${id}`),
  blank: path(ROOTS_INBOX, `/blank`),
};

export const PATH_CALENDAR = {
  root: ROOTS_CALENDAR,
};

export const PATH_SUBSCRIPTION = {
  root: ROOTS_SUBSCRIPTION,
  list: path(ROOTS_SUBSCRIPTION, `/list`),
  new: path(ROOTS_SUBSCRIPTION, `/new`),
  details: (id: string | number): string =>
    path(ROOTS_SUBSCRIPTION, `/view/${id}`),
};

export const PATH_START = {
  root: 'https://mantine-analytics-dashboard-docs.netlify.app/getting-started',
};

export const PATH_DOCS = {
  help: 'https://github.com/design-sparx/antd-multipurpose-dashboard/blob/main/README.md',
  components: 'https://6546507b657a74164abf2db6-oniqlpqtfs.chromatic.com/',
  productRoadmap:
    'https://kelvink96.notion.site/1af2c000eb4f4b1688684cb2d88d5ee4?v=eb14f3050b7d4357821dbcb4bb61b636&p=752cacbf390f4d1cbc0e625550391d9b&pm=s',
};

export const PATH_CHANGELOG = {
  root: '',
};

export const PATH_GITHUB = {
  org: 'https://github.com/design-sparx',
  personal: 'https://github.com/kelvink96',
  repo: 'https://github.com/design-sparx/antd-multipurpose-dashboard',
};

export const PATH_SOCIALS = {
  behance: 'https://www.behance.net/kelvink96',
  dribbble: 'https://dribbble.com/kelvink96',
  facebook: 'https://www.facebook.com/kelvinkk96',
  instagram: 'https://www.instagram.com/kelvink_96/',
  linkedin: 'https://www.linkedin.com/in/kelvink96/',
  youtube: 'https://twitter.com/kelvink_96',
};

export const PATH_ABOUT = {
  root: ROOTS_ABOUT,
};


src\context\index.ts:
import { StylesContext, useStylesContext } from './styles';

export { StylesContext, useStylesContext };


src\context\styles.tsx:
import { createContext, useContext } from 'react';
import { CarouselProps, RowProps } from 'antd';

export type StylesContentProps = {
  rowProps: RowProps;
  carouselProps: CarouselProps;
};

export const StylesContext = createContext<StylesContentProps | null>(null);

export const useStylesContext = () => useContext(StylesContext);


src\firebase\firebaseConfig.ts:
// Import the functions you need from the SDKs you need
import { initializeApp } from 'firebase/app';
import { getAnalytics } from 'firebase/analytics';
import { getMessaging } from 'firebase/messaging';

const {
  VITE_APP_API_KEY,
  VITE_APP_AUTH_DOMAIN,
  VITE_APP_PROJECT_ID,
  VITE_APP_STORAGE_BUCKET,
  VITE_APP_MESSENGER_SENDER_ID,
  VITE_APP_APP_ID,
  VITE_APP_MEASUREMENT_ID,
} = import.meta.env;

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: VITE_APP_API_KEY,
  authDomain: VITE_APP_AUTH_DOMAIN,
  projectId: VITE_APP_PROJECT_ID,
  storageBucket: VITE_APP_STORAGE_BUCKET,
  messagingSenderId: VITE_APP_MESSENGER_SENDER_ID,
  appId: VITE_APP_APP_ID,
  measurementId: VITE_APP_MEASUREMENT_ID,
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
const messaging = getMessaging(app);

export { analytics, messaging };


src\hooks\index.ts:
import { usePageContext } from './usePageContext.tsx';
import useFetchData from './useFetchData.tsx';

export { usePageContext, useFetchData };


src\hooks\useFetchData.tsx:
// src\hooks\useFetchData.tsx
import { useCallback, useEffect, useState } from 'react';

const useFetchData = (url: string, token?: string) => { // Thêm tham số token tùy chọn
    const [data, setData] = useState<any>([]);
    const [error, setError] = useState<any>(null);
    const [loading, setLoading] = useState(true);

    const fetchData = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const headers: HeadersInit = { // Khởi tạo headers
                'Content-Type': 'application/json',
            };
            if (token) { // Nếu có token, thêm vào headers
                headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(url, { // Truyền headers vào fetch
                headers: new Headers(headers)
            });

            if (!response.ok) {
                const message = `This is an HTTP error: ${response.status}`;
                throw new Error(message);
            }

            const json = await response.json();
            setData(json);
        } catch (error: any) {
            setError(error);
        } finally {
            setLoading(false);
        }
    }, [url, token]); // Thêm token vào dependency array

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    return { data, error, loading };
};

export default useFetchData;

src\hooks\useFetchOrganizedEventsData.tsx:
// src\hooks\useFetchOrganizedEventsData.tsx
import { useCallback, useEffect, useState } from 'react';
import authService from '../services/authService';

const useFetchOrganizedEventsData = (status?: string) => { // status now is optional
    const [data, setData] = useState<any>([]);
    const [error, setError] = useState<any>(null);
    const [loading, setLoading] = useState(true);

    const fetchData = useCallback(async (statusParam?: string) => { // fetchData now accepts statusParam
        setLoading(true);
        setError(null);
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) {
                throw new Error("No access token found. Please login again.");
            }

            const response = await authService.getOrganizedEvents(statusParam, accessToken); // Pass statusParam to API call
            if (response && typeof response === 'object' && 'data' in response && response.data && typeof response.data === 'object' && 'events' in response.data) {
                setData(response.data.events);
            } else {
                throw new Error("Unexpected response format");
            }
        } catch (error: any) {
            setError(error);
        } finally {
            setLoading(false);
        }
    }, []); // fetchData dependency array is now empty, status is handled in useCallback argument

    useEffect(() => {
        fetchData(status); // Call fetchData with status from hook argument
    }, [fetchData, status]); // fetchData and status are dependencies

    return { data, error, loading, fetchData }; // Return fetchData for refresh
};

export default useFetchOrganizedEventsData;

src\hooks\useFetchParticipatedEventsData.tsx:
// src\hooks\useFetchParticipatedEventsData.tsx
import { useCallback, useEffect, useState } from 'react';
import authService from '../services/authService';

const useFetchParticipatedEventsData = (status?: string) => {
    const [data, setData] = useState<any>([]);
    const [error, setError] = useState<any>(null);
    const [loading, setLoading] = useState(true);

    const fetchData = useCallback(async (statusParam?: string) => {
        setLoading(true);
        setError(null);
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) {
                throw new Error("No access token found. Please login again.");
            }

            const response = await authService.getParticipatedEvents(statusParam, accessToken); // Call API for participated events
             if (response && typeof response === 'object' && 'data' in response && response.data && typeof response.data === 'object') {
                setData(response.data);
            } else {
                throw new Error("Unexpected response format");
            }
        } catch (error: any) {
            setError(error);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchData(status);
    }, [fetchData, status]);

    return { data, error, loading, fetchData };
};

export default useFetchParticipatedEventsData;

src\hooks\useFetchTopClients.tsx:
// src\hooks\useFetchTopClients.tsx
// src\hooks\useFetchTopClients.tsx
import { useCallback, useEffect, useState } from 'react';
import authService from '../services/authService';
import { User } from '../types';

interface UserApiResponse {
    statusCode: number;
    message: string;
    data: {
        users: User[];
        meta: {
            totalItems: number;
            page: number;
            limit: number;
            totalPages: number;
            count: number;
        };
    };
}

const useFetchTopClients = (limit?: number) => {
    const [data, setData] = useState<User[]>([]);
    const [error, setError] = useState<any>(null);
    const [loading, setLoading] = useState<boolean>(true);

    const fetchData = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) {
                throw new Error("No access token found. Please login again.");
            }

            const response = await authService.getUsers(accessToken);
            const apiResponse = response as UserApiResponse;

            if (apiResponse.statusCode === 200 && apiResponse.data.users) {
                let users = apiResponse.data.users;
                if (limit) {
                    users = users.slice(0, limit);
                }
                setData(users);
            } else {
                throw new Error(apiResponse.message || "Failed to fetch users");
            }
        } catch (error: any) {
            setError(error);
        } finally {
            setLoading(false);
        }
    }, [limit]);

    useEffect(() => {
        const fetchTopClientsData = async () => {
            setLoading(true);
            setError(null);
            try {
                const accessToken = localStorage.getItem('accessToken');
                if (!accessToken) {
                    throw new Error("No access token found. Please login again.");
                }

                const response = await authService.getUsers(accessToken);
                const apiResponse = response as UserApiResponse;

                if (apiResponse.statusCode === 200 && apiResponse.data.users) {
                    let users = apiResponse.data.users;
                    if (limit) {
                        users = users.slice(0, limit);
                    }
                    setData(users);
                } else {
                    throw new Error(apiResponse.message || "Failed to fetch users");
                }
            } catch (error: any) {
                setError(error);
            } finally {
                setLoading(false);
            }
        };

        fetchTopClientsData();
    }, [limit]);

    return { data, error, loading };
};

export default useFetchTopClients;


src\hooks\useFetchUserEventsByDate.tsx:
// src\hooks\useFetchUserEventsByDate.tsx
import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../api/axiosInstance';

interface UserEventsData {
  organizedEvents: any[];
  participatedEvents: any[];
}

const useFetchUserEventsByDate = (userId: string, year: number, month?: number) => {
  const [data, setData] = useState<UserEventsData | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const params: any = { userId, year }; // Truyền userId vào query params
      if (month) {
        params.month = month;
      }
      const response = await axiosInstance.get(`/reports/user-events-by-date`, { // Đường dẫn API đã thay đổi
        params,
      });
      const responseData = response.data as { data: UserEventsData };
      setData(responseData.data);
    } catch (error: any) {
      setError(error.message || 'Failed to fetch user events by date');
    } finally {
      setLoading(false);
    }
  }, [userId, year, month]);

  useEffect(() => {
    if (userId && year) {
      fetchData();
    }
  }, [fetchData, userId, year]);

  return { data, loading, error, fetchData };
};

export default useFetchUserEventsByDate;


src\hooks\usePageContext.tsx:
import { useOutletContext } from 'react-router-dom';

export type ContextType = { title: string | null };

export function usePageContext() {
  return useOutletContext<ContextType>();
}


src\layouts\index.ts:
import { EventDetailLayout } from './eventDetails/index.tsx';

export { AppLayout } from './app';
export { DashboardLayout } from './dashboards';
// export { GuestLayout } from './guest/Guest.tsx';
export { UserAccountLayout } from './userAccount';
export {EventDetailLayout} from './eventDetails';


src\layouts\app\App.tsx:
import {
  Button,
  Dropdown,
  Flex,
  FloatButton,
  Input,
  Layout,
  MenuProps,
  message,
  theme,
  Tooltip,
  Switch,
} from 'antd';
import { useLocation, useNavigate } from 'react-router-dom';
import { ReactNode, useEffect, useRef, useState } from 'react';
import {
  AppstoreOutlined,
  LogoutOutlined,
  MenuFoldOutlined,
  MenuUnfoldOutlined,
  MessageOutlined,
  QuestionOutlined,
  SettingOutlined,
  UserOutlined,
  MoonOutlined,
  SunOutlined,
} from '@ant-design/icons';
import {
  CSSTransition,
  SwitchTransition,
  TransitionGroup,
} from 'react-transition-group';
import { useMediaQuery } from 'react-responsive';
import SideNav from './SideNav.tsx';
import HeaderNav from './HeaderNav.tsx';
import FooterNav from './FooterNav.tsx';
import { NProgress } from '../../components';
import { PATH_LANDING, PATH_AUTH } from '../../constants';
import { useSelector, useDispatch } from 'react-redux';
import { toggleTheme } from '../../redux/theme/themeSlice.ts';
import { RootState } from '../../redux/store.ts';
import authService from '../../services/authService'; // Import service
import { clearUser } from '../../redux/userSlice.tsx';
const { Content } = Layout;

type AppLayoutProps = {
  children: ReactNode;
};

export const AppLayout = ({ children }: AppLayoutProps) => {
  const {
    token: { borderRadius },
  } = theme.useToken();
  const isMobile = useMediaQuery({ maxWidth: 769 });
  const [collapsed, setCollapsed] = useState(true);
  const [navFill, setNavFill] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const location = useLocation();
  const navigate = useNavigate();
  const nodeRef = useRef(null);
  const floatBtnRef = useRef(null);
  const dispatch = useDispatch();
  const { mytheme } = useSelector((state: RootState) => state.theme);
  const user = useSelector((state: RootState) => state.user);
//
    const handleLogout = async () => {
        message.open({
            type: 'loading',
            content: 'Signing you out',
        });
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) return navigate(PATH_AUTH.signin);
            await authService.logout(accessToken);
            localStorage.removeItem('accessToken');
            localStorage.removeItem('user');
            dispatch(clearUser());
    
            setTimeout(() => {
              navigate(PATH_AUTH.signin);
              message.success('Logout successful');
            }, 1000);
          } catch (error: any) {
            setTimeout(() => {
              navigate(PATH_AUTH.signin);
              message.success('Logout successful');
            }, 1000);
          }
    };

  const items: MenuProps['items'] = [
    {
      key: 'user-profile-link',
      label: 'profile',
      icon: <UserOutlined />,
    },
    {
      key: 'user-settings-link',
      label: 'settings',
      icon: <SettingOutlined />,
    },
    {
      key: 'user-help-link',
      label: 'help center',
      icon: <QuestionOutlined />,
    },
    {
      type: 'divider',
    },
    {
      key: 'user-logout-link',
      label: 'logout',
      icon: <LogoutOutlined />,
      danger: true,
      onClick: handleLogout
    },
  ];

  useEffect(() => {
    setCollapsed(isMobile);
  }, [isMobile]);

  useEffect(() => {
    window.addEventListener('scroll', () => {
      if (window.scrollY > 5) {
        setNavFill(true);
      } else {
        setNavFill(false);
      }
    });
  }, []);

  return (
    <>
      <NProgress isAnimating={isLoading} key={location.key} />
      <Layout
        style={{
          minHeight: '100vh',
          // backgroundColor: 'white',
        }}
      >
        <SideNav
          trigger={null}
          collapsible
          collapsed={collapsed}
          onCollapse={(value) => setCollapsed(value)}
          style={{
            overflow: 'auto',
            position: 'fixed',
            left: 0,
            top: 0,
            bottom: 0,
            background: 'none',
            border: 'none',
            transition: 'all .2s',
          }}
        />
        <Layout
          style={
            {
              // background: 'none',
            }
          }
        >
          <HeaderNav
            style={{
              marginLeft: collapsed ? 0 : '200px',
              padding: '0 2rem 0 0',
              background: navFill ? 'rgba(255, 255, 255, .5)' : 'none',
              backdropFilter: navFill ? 'blur(8px)' : 'none',
              boxShadow: navFill ? '0 0 8px 2px rgba(0, 0, 0, 0.05)' : 'none',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              position: 'sticky',
              top: 0,
              zIndex: 1,
              gap: 8,
              transition: 'all .25s',
            }}
          >
            <Flex align="center">
              <Tooltip title={`${collapsed ? 'Expand' : 'Collapse'} Sidebar`}>
                <Button
                  type="text"
                  icon={
                    collapsed ? <MenuUnfoldOutlined /> : <MenuFoldOutlined />
                  }
                  onClick={() => setCollapsed(!collapsed)}
                  style={{
                    fontSize: '16px',
                    width: 64,
                    height: 64,
                  }}
                />
              </Tooltip>
              <Input.Search
                placeholder="search"
                style={{
                  width: isMobile ? '100%' : '400px',
                  marginLeft: isMobile ? 0 : '.5rem',
                }}
                size="middle"
              />
            </Flex>
            <Flex align="center" gap="small">
              <Tooltip title="Apps">
                <Button icon={<AppstoreOutlined />} type="text" size="large" />
              </Tooltip>
              <Tooltip title="Messages">
                <Button icon={<MessageOutlined />} type="text" size="large" />
              </Tooltip>
              <Tooltip title="Theme">
                <Switch
                  className=" hidden sm:inline py-1"
                  checkedChildren={<MoonOutlined />}
                  unCheckedChildren={<SunOutlined />}
                  checked={mytheme === 'light' ? true : false}
                  onClick={() => dispatch(toggleTheme())}
                />
              </Tooltip>
              <Dropdown menu={{ items }} trigger={['click']}>
                <Flex>
                  <img
                    src={user?.avatar || "/me.jpg"}
                    alt="user profile photo"
                    height={36}
                    width={36}
                    style={{ borderRadius, objectFit: 'cover' }}
                  />
                </Flex>
              </Dropdown>
            </Flex>
          </HeaderNav>
          <Content
            style={{
              margin: `0 0 0 ${collapsed ? 0 : '200px'}`,
              // background: 'none',
              borderRadius: collapsed ? 0 : borderRadius,
              transition: 'all .25s',
              padding: '24px 32px',
              minHeight: 360,
            }}
          >
            <TransitionGroup>
              <SwitchTransition>
                <CSSTransition
                  key={`css-transition-${location.key}`}
                  nodeRef={nodeRef}
                  onEnter={() => {
                    setIsLoading(true);
                  }}
                  onEntered={() => {
                    setIsLoading(false);
                  }}
                  timeout={300}
                  classNames="bottom-to-top"
                  unmountOnExit
                >
                  {() => (
                    <div ref={nodeRef} style={{ background: 'none' }}>
                      {children}
                    </div>
                  )}
                </CSSTransition>
              </SwitchTransition>
            </TransitionGroup>
            <div ref={floatBtnRef}>
              <FloatButton.BackTop />
            </div>
          </Content>
          <FooterNav
            style={{
              textAlign: 'center',
              marginLeft: collapsed ? 0 : '200px',
              background: 'none',
            }}
          />
        </Layout>
      </Layout>
    </>
  );
};

src\layouts\app\FooterNav.tsx:
import { Layout } from 'antd';

const { Footer } = Layout;

type FooterNavProps = React.HTMLAttributes<HTMLDivElement>;

const FooterNav = ({ ...others }: FooterNavProps) => {
  return (
    <Footer {...others}></Footer>
  );
};

export default FooterNav;


src\layouts\app\HeaderNav.tsx:
import { Layout } from 'antd';
import { useRef } from 'react';

const { Header } = Layout;

type HeaderNavProps = {
  navFill?: boolean;
} & React.HTMLAttributes<HTMLDivElement>;

const HeaderNav = ({ navFill, ...others }: HeaderNavProps) => {
  const nodeRef = useRef(null);

  return <Header ref={nodeRef} {...others} />;
};

export default HeaderNav;


src\layouts\app\index.ts:
export { AppLayout } from './App.tsx';


src\layouts\app\SideNav.tsx:
import React, { useEffect, useRef, useState } from 'react';
import { ConfigProvider, Layout, Menu, MenuProps, SiderProps } from 'antd';
import {
  AppstoreAddOutlined,
  BranchesOutlined,
  BugOutlined,
  GithubOutlined,
  IdcardOutlined,
  InfoCircleOutlined,
  PieChartOutlined,
  ProductOutlined,
  SecurityScanOutlined,
  SnippetsOutlined,
  UserOutlined,
} from '@ant-design/icons';
import { Logo } from '../../components';
import { Link, useLocation } from 'react-router-dom';
import {
  PATH_ABOUT,
  PATH_AUTH,
  PATH_DASHBOARD,
  PATH_DOCS,
  PATH_ERROR,
  PATH_GITHUB,
  PATH_LANDING,
  PATH_SITEMAP,
  PATH_USER_PROFILE,
} from '../../constants';
import { COLOR } from '../../App.tsx';

const { Sider } = Layout;

type MenuItem = Required<MenuProps>['items'][number];

const getItem = (
  label: React.ReactNode,
  key: React.Key,
  icon?: React.ReactNode,
  children?: MenuItem[],
  type?: 'group'
): MenuItem => {
  return {
    key,
    icon,
    children,
    label,
    type,
  } as MenuItem;
};

const items: MenuProps['items'] = [
  getItem('Dashboards', 'dashboards', <PieChartOutlined />, [
    getItem(
      <Link to={PATH_DASHBOARD.general}>General</Link>,
      PATH_DASHBOARD.general, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_DASHBOARD.projects}>Projects</Link>,
      PATH_DASHBOARD.projects, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_DASHBOARD.events}>Events</Link>,
      PATH_DASHBOARD.events, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_DASHBOARD.my_events}>My Events</Link>,
      PATH_DASHBOARD.my_events, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_DASHBOARD.participated_events}>Participated Events</Link>,
      PATH_DASHBOARD.participated_events, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_DASHBOARD.speaker_guest}>Speaker & Guest</Link>,
      PATH_DASHBOARD.speaker_guest, // key = pathname
      null
    ),
  ]),

  getItem('Pages', 'pages', null, [], 'group'),

  getItem('User profile', 'user-profile', <UserOutlined />, [
    getItem(
      <Link to={PATH_USER_PROFILE.personalInformation}>Information</Link>,
      PATH_USER_PROFILE.personalInformation, // key = pathname
      null
    ),
    getItem(
      <Link to={PATH_USER_PROFILE.security}>Security</Link>,
      PATH_USER_PROFILE.security, // key = pathname
      null
    ),
  ]),
];

const rootSubmenuKeys = ['dashboards', 'corporate', 'user-profile'];

type SideNavProps = SiderProps;

const SideNav = ({ ...others }: SideNavProps) => {
  const nodeRef = useRef(null);
  const { pathname } = useLocation();
  const [openKeys, setOpenKeys] = useState(['']);
  const [current, setCurrent] = useState('');

  const onClick: MenuProps['onClick'] = (e) => {
    console.log('click ', e);
  };

  const onOpenChange: MenuProps['onOpenChange'] = (keys) => {
    const latestOpenKey = keys.find((key) => openKeys.indexOf(key) === -1);
    if (latestOpenKey && rootSubmenuKeys.indexOf(latestOpenKey!) === -1) {
      setOpenKeys(keys);
    } else {
      setOpenKeys(latestOpenKey ? [latestOpenKey] : []);
    }
  };

  useEffect(() => {
    setCurrent(pathname); // Sử dụng pathname trực tiếp
  }, [pathname]);

  return (
    <Sider ref={nodeRef} breakpoint="lg" collapsedWidth="0" {...others}>
      <Logo
        color="blue"
        asLink
        href={PATH_LANDING.root}
        justify="center"
        gap="small"
        imgSize={{ h: 28, w: 28 }}
        style={{ padding: '1rem 0' }}
      />
      <ConfigProvider
        theme={{
          components: {
            Menu: {
              itemBg: 'none',
              itemSelectedBg: COLOR['100'],
              itemHoverBg: COLOR['50'],
              itemSelectedColor: COLOR['600'],
            },
          },
        }}
      >
        <Menu
          mode="inline"
          items={items}
          onClick={onClick}
          openKeys={openKeys}
          onOpenChange={onOpenChange}
          selectedKeys={[current]}
          style={{ border: 'none' }}
        />
      </ConfigProvider>
    </Sider>
  );
};

export default SideNav;


src\layouts\corporate\index.tsx:
import { AppLayout } from '../index.ts';
import { Button, Col, Row, Typography } from 'antd';
import { Link, Outlet, useLocation } from 'react-router-dom';
import {
  BlogsListCard,
  Card,
  PageHeader,
  SocialMediaCard,
} from '../../components';
import { HomeOutlined, IdcardOutlined } from '@ant-design/icons';
import { useStylesContext } from '../../context';

const { Text, Title } = Typography;

const BLOGS_DATA = Array.from({ length: 23 }).map((_, i) => ({
  href: 'https://ant.design',
  title: `Lorem ipsum ${i}`,
  avatar: `https://xsgames.co/randomusers/avatar.php?g=pixel&key=${i}`,
  description:
    'Ant Design, a design language for background applications, is refined by Ant UED Team.',
  content:
    'We supply a series of design principles, practical patterns and high quality design resources (Sketch and Axure), to help people create their product prototypes beautifully and efficiently.',
}));

export const CorporateLayout = () => {
  const { pathname } = useLocation();
  const stylesContext = useStylesContext();

  return (
    <>
      {/*@ts-ignore*/}
      <AppLayout>
        <PageHeader
          title="corporate"
          breadcrumbs={[
            {
              title: (
                <>
                  <HomeOutlined />
                  <span>home</span>
                </>
              ),
              path: '/',
            },
            {
              title: (
                <>
                  <IdcardOutlined />
                  <span>corporate</span>
                </>
              ),
            },
            {
              title: pathname.split('/')[pathname.split('/').length - 1] || '',
            },
          ]}
        />
        <Row {...stylesContext?.rowProps}>
          <Col xs={24} md={16} xl={18}>
            <Outlet />
          </Col>
          <Col xs={24} md={8} xl={6}>
            <Row {...stylesContext?.rowProps}>
              <Col span={24}>
                <Card title="Careers" actions={[<Button>Explore more</Button>]}>
                  <Text>
                    Tortor id aliquet lectus proin nibh nisl condimentum. Semper
                    quis lectus nulla at volutpat. Faucibus nisl tincidunt eget
                    nullam non. Malesuada nunc vel risus commodo viverra. Lectus
                    vestibulum mattis ullamcorper velit sed ullamcorper morbi
                    tincidunt ornare.
                  </Text>
                  <Title level={5}>Requirements</Title>
                  <ul>
                    <li>Experience with JavaScript</li>
                    <li>Good time-management skills</li>
                    <li>Experience with React & Nextjs</li>
                    <li>Experience with HTML / CSS</li>
                  </ul>
                  <Title level={5}>Our Achievements</Title>
                  <ul>
                    <li>ISO Certified</li>
                    <li>Atlassian Partner</li>
                    <li>Amazon Partner</li>
                    <li>Google Partner</li>
                    <li>Microsoft Partner</li>
                  </ul>
                </Card>
              </Col>
              <Col span={24}>
                <BlogsListCard data={BLOGS_DATA} />
              </Col>
              <Col span={24}>
                <SocialMediaCard />
              </Col>
            </Row>
          </Col>
        </Row>
      </AppLayout>
    </>
  );
};


src\layouts\dashboards\index.tsx:
import { AppLayout } from '../app';
import { Outlet } from 'react-router-dom';

export const DashboardLayout = () => {
  return (
    <AppLayout>
      <Outlet />
    </AppLayout>
  );
};


src\layouts\eventDetails\index.tsx:
// src/layouts/eventDetails/index.tsx
import React, { useEffect, useState } from 'react';
import { AppLayout } from '../index';
import {
  Col,
  Row,
  message,
  Spin,
  Typography,
  Card,
  Tag,
  Form,
  Rate,
  Input,
  Alert,
  Button,
} from 'antd';
import { useLocation, useParams, Outlet } from 'react-router-dom';
import { CiLocationOn, CiUser, CiCalendar } from 'react-icons/ci';
import { HomeOutlined, PieChartOutlined, IdcardOutlined, SendOutlined } from '@ant-design/icons';
import { PageHeader, BackBtn } from '../../components';
import { useStylesContext } from '../../context';
import authService from '../../services/authService';
import dayjs from 'dayjs';
import { RootState } from '../../redux/store';
import { useSelector } from 'react-redux';
import { Helmet } from 'react-helmet-async';
import TicketDetailsModal from '../../components/TicketDetailsModal';

const { Title, Text } = Typography;

export const EventDetailLayout: React.FC = () => {
  const { pathname } = useLocation();
  const { id: eventId } = useParams<{ id: string }>();
  const stylesContext = useStylesContext();
  const user = useSelector((state: RootState) => state.user);

  const [eventDetail, setEventDetail] = useState<any>(null);
  const [loadingEvent, setLoadingEvent] = useState(true);
  const [feedback, setFeedback] = useState<any | null>(null);
  const [feedbackLoading, setFeedbackLoading] = useState(false);
  const [feedbackError, setFeedbackError] = useState<string | null>(null);
  const [ratingValue, setRatingValue] = useState<number | undefined>(undefined);
  const [commentValue, setCommentValue] = useState<string>('');
  const [form] = Form.useForm();
  const [ticketData, setTicketData] = useState<any>(null);
  const [isTicketModalVisible, setIsTicketModalVisible] = useState(false);
  const [isParticipant, setIsParticipant] = useState<boolean | null>(null);

  useEffect(() => {
    const fetchEventDetail = async () => {
      setLoadingEvent(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventDetails(eventId) as {
          statusCode: number;
          data: { event: any };
          message?: string;
        };
        if (response.statusCode === 200 && response.data) {
          setEventDetail(response.data.event);
          if(eventDetail?.status === 'FINISHED') {
            const checkParticipant = await authService.getEventParticipants(eventId, accessToken || '') as any;
            if(checkParticipant.statusCode === 200) {
              setIsParticipant(true);
            } else {
              setIsParticipant(false);
            }
          }
        } else {
          message.error(response.message || 'Failed to load event details');
        }
      } catch (error: any) {
        message.error(error.message || 'Error fetching event details');
      } finally {
        setLoadingEvent(false);
      }
    };

    const fetchUserFeedback = async () => {
      if (!eventId) return;
      setFeedbackLoading(true);
      setFeedbackError(null);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventFeedbackByUser(eventId, accessToken || undefined) as any;
        if (response.statusCode === 200 && response.data.feedback) {
          setFeedback(response.data.feedback);
          setRatingValue(response.data.feedback.rating);
          setCommentValue(response.data.feedback.comment);
          form.setFieldsValue({
            rating: response.data.feedback.rating,
            comment: response.data.feedback.comment,
          });
        } else if (response.statusCode === 400 && response.data?.error === "Feedback not found") {
          setFeedback(null);
          form.resetFields();
          setRatingValue(undefined);
          setCommentValue('');
        } else {
        }
      } catch (error: any) {
      } finally {
        setFeedbackLoading(false);
      }
    };

    if (eventId) {
      fetchEventDetail();
      fetchUserFeedback();
    }
  }, [eventId, form]);

  const handleDownloadPdf = async () => {
    try {
      setLoadingEvent(true);
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        return;
      }
      const response = await authService.getEventParticipants(eventId, accessToken) as any;
      const participants = response.data || [];
      if (!participants || participants.length === 0) {
        message.error("No participants data available.");
        return;
      }
      const jsPDF = (await import('jspdf')).default;
      const doc = new jsPDF();
      doc.setFontSize(16);
      doc.text("Participants Check-in/Check-out List", 14, 20);
      const columns = ["No", "Name", "Email", "Check-In", "Check-Out"];
      const rows = participants.map((p: any, index: number) => [
        index + 1,
        p.name,
        p.email,
        p.checkInAt ? dayjs(p.checkInAt).format("YYYY-MM-DD HH:mm:ss") : "",
        p.checkOutAt ? dayjs(p.checkOutAt).format("YYYY-MM-DD HH:mm:ss") : ""
      ]);
      (doc as any).autoTable({
        head: [columns],
        body: rows,
        startY: 30,
        theme: 'grid'
      });
      doc.save("participants.pdf");
    } catch (error: any) {
      console.error("Error generating PDF:", error);
      message.error("List check-in/check-out is empty.");
    } finally {
      setLoadingEvent(false);
    }
  };

  const scheduleColumns = [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title',
    },
    {
      title: 'Start Time',
      dataIndex: 'startTime',
      key: 'startTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'End Time',
      dataIndex: 'endTime',
      key: 'endTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
  ];

  const hideTicketModal = () => {
    setIsTicketModalVisible(false);
  };

  const handleFeedbackSubmit = async (values: any) => {
    setFeedbackLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        return;
      }
      const feedbackData = {
        rating: values.rating,
        comment: values.comment,
      };
      let response: any;
      if (feedback) {
        // Update feedback
        response = await authService.patchEventFeedback(eventId!, feedbackData, accessToken);
      } else {
        // Submit new feedback
        response = await authService.postEventFeedback(eventId!, feedbackData, accessToken);
      }
      if (response.statusCode === 200 || response.statusCode === 201) {
        message.success(response.message);
        setFeedback(response.data.feedback);
        setRatingValue(response.data.feedback.rating);
        setCommentValue(response.data.feedback.comment);
        form.setFieldsValue({
          rating: response.data.feedback.rating,
          comment: response.data.feedback.comment,
        });
      } else {
        message.error(response.error || 'Failed to submit feedback');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to submit feedback');
    } finally {
      setFeedbackLoading(false);
    }
  };

  return (
    <>
      <Helmet>
        <title>Event Details</title>
      </Helmet>
      <AppLayout>
        <PageHeader
          title="Event Details"
          breadcrumbs={[
            {
              title: (
                <>
                  <HomeOutlined />
                  <span>home</span>
                </>
              ),
              path: '/',
            },
            {
              title: (
                <>
                  <IdcardOutlined />
                  <span>event</span>
                </>
              ),
            },
            {
              title: pathname.split('/')[pathname.split('/').length - 1] || '',
            },
          ]}
          btnBack={<BackBtn />}
        />
        <Row gutter={[16, 16]}>
          <Col xs={24} md={16} xl={18}>
            <Outlet context={{ eventId, eventDetail }} />
          </Col>
          <Col xs={24} md={8} xl={6}>
            <Row gutter={[16, 16]}>
              <Col span={24}>
                <Card title="Event Info">
                  {loadingEvent ? (
                    <div style={{ textAlign: 'center' }}>
                      <Spin tip="Loading event info..." />
                    </div>
                  ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <Text strong>Name:</Text>
                        <Text>{eventDetail?.name || 'N/A'}</Text>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <Text strong>Status:</Text>
                        <Tag color={
                          eventDetail?.status === 'SCHEDULED'
                            ? 'blue'
                            : eventDetail?.status === 'CANCELED'
                              ? 'red'
                              : eventDetail?.status === 'FINISHED'
                                ? 'green'
                                : 'default'
                        }>
                          {eventDetail?.status}
                        </Tag>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <CiLocationOn />
                        <Text strong>Location:</Text>
                        <Text>{eventDetail?.location || 'N/A'}</Text>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <CiUser />
                        <Text strong>Capacity:</Text>
                        <Text>{eventDetail?.maxParticipants || 'Unlimited'}</Text>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <CiCalendar />
                        <Text strong>Start Date:</Text>
                        <Text>
                          {eventDetail?.startDate ? dayjs(eventDetail.startDate).format('YYYY-MM-DD HH:mm') : 'N/A'}
                        </Text>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <CiCalendar />
                        <Text strong>End Date:</Text>
                        <Text>
                          {eventDetail?.endDate ? dayjs(eventDetail.endDate).format('YYYY-MM-DD HH:mm') : 'N/A'}
                        </Text>
                      </div>
                    </div>
                  )}
                </Card>
              </Col>
              {eventDetail?.status === 'FINISHED' && isParticipant && (
                <Col span={24} style={{ marginTop: "24px" }}>
                  <Card title="Feedback">
                    {feedbackError && (
                      <Alert
                        message="Error"
                        description={feedbackError}
                        type="error"
                        showIcon
                        closable
                        onClose={() => setFeedbackError(null)}
                        style={{ marginBottom: 16 }}
                      />
                    )}
                    {feedbackLoading ? (
                      <Spin tip="Loading feedback..." />
                    ) : (
                      <Form
                        form={form}
                        layout="vertical"
                        onFinish={handleFeedbackSubmit}
                        initialValues={{
                          rating: feedback?.rating,
                          comment: feedback?.comment,
                        }}
                      >
                        <Form.Item label="Rating" name="rating">
                          <Rate
                            allowHalf
                            value={ratingValue}
                            onChange={(value) => setRatingValue(value)}
                          />
                        </Form.Item>
                        <Form.Item label="Comment" name="comment">
                          <Input.TextArea
                            rows={4}
                            placeholder="Your feedback here"
                            value={commentValue}
                            onChange={(e) => setCommentValue(e.target.value)}
                          />
                        </Form.Item>
                        <Form.Item>
                          <Button type="primary" htmlType="submit" loading={feedbackLoading} icon={<SendOutlined />}>
                            Submit Feedback
                          </Button>
                        </Form.Item>
                      </Form>
                    )}
                  </Card>
                </Col>
              )}
            </Row>
          </Col>
        </Row>
      </AppLayout>
      <TicketDetailsModal
        visible={isTicketModalVisible}
        onCancel={hideTicketModal}
        ticket={ticketData}
      />
    </>
  );
};

export default EventDetailLayout;


src\layouts\guest\Guest.tsx:


src\layouts\userAccount\index.tsx:
// src\layouts\userAccount\index.tsx
import { AppLayout } from '../app';
import {
  Col,
  ConfigProvider,
  Descriptions,
  DescriptionsProps,
  Image,
  Row,
  Tabs,
  TabsProps,
  theme,
  Typography,
  Button,
  message,
  Spin,
} from 'antd';
import { Card } from '../../components';
import { Outlet, useLocation, useNavigate } from 'react-router-dom';
import { USER_PROFILE_ITEMS } from '../../constants';
import { useStylesContext } from '../../context';

const { Link } = Typography;

import './styles.css';
import { useEffect, useRef, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState } from '../../redux/store';
import authService from '../../services/authService';
import { updateUserProfile } from '../../redux/userSlice';

export const UserAccountLayout = () => {
  const {
    token: { borderRadius },
  } = theme.useToken();
  const navigate = useNavigate();
  const stylesContext = useStylesContext();
  const location = useLocation();
  const TAB_ITEMS: TabsProps['items'] = USER_PROFILE_ITEMS.map((u) => ({
    key: u.title,
    label: u.title,
  }));
  const [activeKey, setActiveKey] = useState(TAB_ITEMS[0].key);
  const user = useSelector((state: RootState) => state.user);
  const dispatch = useDispatch();
  const [uploadLoading, setUploadLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const onChange = (key: string) => {
    navigate(key);
  };

  useEffect(() => {
    const k =
      TAB_ITEMS.find((d) => location.pathname.includes(d.key))?.key || '';
    setActiveKey(k);
  }, [location]);

  const DESCRIPTION_ITEMS: DescriptionsProps['items'] = [
    {
      key: 'full-name',
      label: 'Name',
      children: <span>{user.name || 'N/A'}</span>,
    },
    {
      key: 'email',
      label: 'Email',
      children: (
        <Link href={`mailto:${user.email}`}>
          {user.email || 'N/A'}
        </Link>
      ),
    },
    {
      key: 'phone',
      label: 'Phone',
      children: user.phoneNumber || 'N/A',
    },
  ];

  const handleUploadAvatar = async (file: File) => {
    setUploadLoading(true);
    try {
      const formData = new FormData();
      formData.append('file', file);
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('Bạn chưa đăng nhập.');
        return;
      }
      const response = await authService.uploadAvatar(formData, accessToken);
      const res = response as { statusCode: number; message: string; data: { user: { avatar: string } } };
      if (res.statusCode === 201) {
        message.success(res.message);
        dispatch(updateUserProfile({ avatar: res.data.user.avatar } as any));
        localStorage.setItem('user', JSON.stringify(res.data.user));
        window.location.reload(); // Tự động reload trang sau khi upload thành công
      } else {
        message.error(res.message || 'Upload avatar không thành công.');
      }
    } catch (error: any) {
      message.error(error?.message || 'Đã có lỗi xảy ra khi upload avatar.');
    } finally {
      setUploadLoading(false);
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      handleUploadAvatar(file);
    }
  };

  const triggerFileInput = () => {
    fileInputRef.current?.click();
  };


  return (
    <>
      <AppLayout>
        <Card
          className="user-profile-card-nav card"
          actions={[
            <ConfigProvider
              theme={{
                components: {
                  Tabs: {
                    colorBorderSecondary: 'none',
                  },
                },
              }}
            >
              <Tabs
                defaultActiveKey={activeKey}
                activeKey={activeKey}
                items={TAB_ITEMS}
                onChange={onChange}
                style={{ textTransform: 'capitalize' }}
              />
            </ConfigProvider>,
          ]}
        >
          <Row {...stylesContext?.rowProps}>
            <Col xs={24} sm={8} lg={4} style={{ textAlign: 'center' }}>
              <Image
                src={user.avatar || "https://images.unsplash.com/photo-1633332755192-727a05c4013d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8dXNlcnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60"}
                alt="user profile image"
                height={120} // Set cố định chiều cao
                width={120}  // Set cố định chiều rộng
                style={{ borderRadius, objectFit: 'cover' }}
                fallback="https://images.unsplash.com/photo-1633332755192-727a05c4013d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8dXNlcnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60"
              />
              <div style={{ marginTop: '10px' }}>
                <Button onClick={triggerFileInput} loading={uploadLoading}>
                  {uploadLoading ? <Spin size="small" /> : 'Đổi Avatar'}
                </Button>
                <input
                  type="file"
                  ref={fileInputRef}
                  style={{ display: 'none' }}
                  onChange={handleFileChange}
                  accept="image/*"
                />
              </div>
            </Col>
            <Col xs={24} sm={16} lg={20}>
              <Descriptions
                title="User Info"
                items={DESCRIPTION_ITEMS}
                column={{ xs: 1, sm: 2, md: 2, lg: 3, xl: 3, xxl: 4 }}
              />
            </Col>
          </Row>
        </Card>
        <div style={{ marginTop: '1.5rem' }}>
          <Outlet />
        </div>
      </AppLayout>
    </>
  );
};

src\layouts\userAccount\styles.css:
.user-profile-card-nav .ant-tabs-nav {
  margin: 0 0 0 1rem;
}

.user-profile-card-nav .ant-card-actions li:first-of-type {
  margin: 0;
}


src\pages\DeclineEventPage.tsx:
// src/pages/DeclineEventPage.tsx
import React, { useEffect, useState } from 'react';
import { useSearchParams, useParams, useNavigate } from 'react-router-dom';
import { Spin, message, Result, Button } from 'antd';
import { Helmet } from 'react-helmet-async';
import authService from '../services/authService';

const DeclineEventPage: React.FC = () => {
  // Lấy token từ query string và eventId từ URL params
  const [searchParams] = useSearchParams();
  const { eventId } = useParams<{ eventId: string }>();
  const token = searchParams.get('token');
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [declineSuccess, setDeclineSuccess] = useState(false);

  useEffect(() => {
    const processDecline = async () => {
      if (!token || !eventId) {
        message.error('Thiếu token hoặc thông tin sự kiện. Vui lòng đăng nhập lại.');
        navigate('/auth/signin');
        return;
      }

      try {
        // Gọi API decline event
        const response = (await authService.declineEvent(eventId, token)) as { statusCode: number; error?: string };
        if (response.statusCode === 200) {
          setDeclineSuccess(true);
          message.success('Bạn đã từ chối lời mời thành công.');
        } else {
          message.error(response.error || 'Từ chối lời mời thất bại.');
          navigate('/auth/signin');
        }
      } catch (error: any) {
        console.error('Error declining event:', error);
        message.error(error.message || 'Có lỗi xảy ra khi từ chối lời mời.');
        navigate('/auth/signin');
      } finally {
        setLoading(false);
      }
    };

    processDecline();
  }, [eventId, token, navigate]);

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent:'center', alignItems:'center', height:'100vh' }}>
        <Helmet>
          <title>Đang xử lý...</title>
        </Helmet>
        <Spin size="large" tip="Đang xử lý phản hồi của bạn..." />
      </div>
    );
  }

  if (declineSuccess) {
    return (
      <>
        <Helmet>
          <title>Trả lời từ chối lời mời</title>
        </Helmet>
        <Result
          status="success"
          title="Cảm ơn bạn!"
          subTitle="Chúng tôi đã ghi nhận rằng bạn từ chối lời mời tham gia sự kiện. Cảm ơn bạn đã phản hồi. Hy vọng sẽ có cơ hội gặp lại bạn trong các sự kiện sắp tới."
          extra={[
            <Button type="primary" key="home" onClick={() => navigate('/')}>
              Về trang chủ
            </Button>,
          ]}
        />
      </>
    );
  }

  // Nếu không có gì hiển thị (trường hợp đã redirect) thì render null
  return null;
};

export default DeclineEventPage;


src\pages\Home.tsx:
import { Button, Col, Flex, Image, Row, theme, Typography } from 'antd';
import { useMediaQuery } from 'react-responsive';
import {
  PATH_AUTH,
  PATH_DASHBOARD,
  PATH_ERROR,
  PATH_GITHUB,
  PATH_USER_PROFILE,
} from '../constants';
import { Link } from 'react-router-dom';
import {
  AntDesignOutlined,
  AppstoreOutlined,
  BorderOutlined,
  CalendarOutlined,
  EditOutlined,
  FileOutlined,
  FormatPainterOutlined,
  GithubOutlined,
  LoginOutlined,
  MergeCellsOutlined,
  PieChartOutlined,
  RocketFilled,
  TableOutlined,
} from '@ant-design/icons';
import { Card, Container } from '../components';
import { createElement, CSSProperties } from 'react';

const { Title, Text } = Typography;

const DASHBOARDS = [
  {
    title: 'general',
    link: PATH_DASHBOARD.general,
  },
  {
    title: 'projects',
    link: PATH_DASHBOARD.projects,
  },
];

const APPS = [
  {
    title: 'user profile',
    link: PATH_USER_PROFILE.personalInformation,
  },
  {
    title: 'auth',
    link: PATH_AUTH.signin,
  },
  {
    title: 'errors',
    link: PATH_ERROR.error400,
  },
];

export const HomePage = () => {
  const {
    token: { colorPrimary },
  } = theme.useToken();
  const isMobile = useMediaQuery({ maxWidth: 769 });
  const isTablet = useMediaQuery({ maxWidth: 992 });

  const sectionStyles: CSSProperties = {
    paddingTop: isMobile ? 40 : 80,
    paddingBottom: isMobile ? 40 : 80,
    paddingRight: isMobile ? '1rem' : 0,
    paddingLeft: isMobile ? '1rem' : 0,
  };

  return (
    <div
      style={{
        // backgroundImage: "radial-gradient(rgba(255, 255, 255, 0.35) 40%, rgba(255, 255, 255, 1) 40%), url('/grid-3d.jpg')",
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        minHeight: '100vh',
      }}
    >
      <Flex
        vertical
        align="center"
        justify="center"
        style={{
          height: isTablet ? 600 : 800,
          width: '100%',
          padding: isMobile ? '2rem 1rem' : '5rem 0',
          // backgroundColor: 'rgba(255, 255, 255, 0.85)',
        }}
      >
        <Container>
          <Row style={{ alignItems: 'center' }}>
            <Col lg={12}>
              <Text
                style={{
                  color: colorPrimary,
                  fontSize: 16,
                  fontWeight: 700,
                }}
              >
                <RocketFilled /> Kick start your project with
              </Text>
              <Title
                style={{
                  fontSize: isMobile ? 36 : 40,
                  fontWeight: 900,
                  margin: '1.5rem 0',
                }}
              >
                A dynamic and versatile multipurpose{' '}
                <span className="text-highlight">dashboard</span> template built
                using <span className="text-highlight">React</span>,{' '}
                <span className="text-highlight">Vite</span>,{' '}
                <span className="text-highlight">Ant Design</span>, and{' '}
                <span className="text-highlight">Storybook</span>{' '}
              </Title>
              <Text style={{ fontSize: 20, marginBottom: '1.5rem' }}>
                <span className="text-highlight fw-bolder">60+</span> ready made
                components to use.
              </Text>
              <Flex
                gap="middle"
                vertical={isMobile}
                style={{ marginTop: '1.5rem' }}
              >
                <Link to={PATH_AUTH.signin}>
                  <Button
                    icon={<LoginOutlined />}
                    type="primary"
                    size="large"
                    block={isMobile}
                  >
                    Live preview
                  </Button>
                </Link>
                <Link to={PATH_GITHUB.repo}>
                  <Button
                    icon={<GithubOutlined />}
                    type="default"
                    size="large"
                    block={isMobile}
                  >
                    Give us a star
                  </Button>
                </Link>
              </Flex>
            </Col>
            {!isTablet && (
              <Col lg={12}>
                <Image src="/landing-frame.png" alt="dashboard image snippet" />
              </Col>
            )}
          </Row>
        </Container>
      </Flex>
      <Container style={sectionStyles}>
        <Title
          level={2}
          className="text-center"
          style={{ marginBottom: '2rem' }}
        >
          8 dashboard pages available
        </Title>
        <Row
          gutter={[
            { xs: 8, sm: 16, md: 24, lg: 32 },
            { xs: 8, sm: 16, md: 24, lg: 32 },
          ]}
        >
          {DASHBOARDS.map((dashboard) => (
            <Col key={dashboard.title} xs={24} lg={8} xl={6}>
              <Link to={dashboard.link}>
                <Card
                  hoverable
                  cover={<img alt={dashboard.title} />}
                >
                  <Text className="m-0 text-capitalize">{dashboard.title}</Text>
                </Card>
              </Link>
            </Col>
          ))}
        </Row>
      </Container>
      <Container style={sectionStyles}>
        <Title
          level={2}
          className="text-center"
          style={{ marginBottom: '2rem' }}
        >
          3+ pages available
        </Title>
        <Row
          gutter={[
            { xs: 8, sm: 16, md: 24, lg: 32 },
            { xs: 8, sm: 16, md: 24, lg: 32 },
          ]}
        >
          {APPS.map((app) => (
            <Col key={app.title} xs={24} sm={12} lg={8} xl={6}>
              <Link to={app.link}>
                <Card hoverable cover={<img alt={app.title} />}>
                  <Text className="m-0 text-capitalize">{app.title}</Text>
                </Card>
              </Link>
            </Col>
          ))}
        </Row>
      </Container>
      <Container style={sectionStyles}>
        <Title
          level={2}
          className="text-center"
          style={{ marginBottom: '2rem' }}
        >
          Other Amazing Features & Flexibility Provided
        </Title>
        <Row
          gutter={[
            { xs: 8, sm: 16, md: 24, lg: 32 },
            { xs: 8, sm: 16, md: 24, lg: 32 },
          ]}
        >
        </Row>
      </Container>
      <Card
        style={{
          width: isMobile ? '95%' : 500,
          margin: '0 auto',
          textAlign: 'center',
        }}
      >
        <Title level={4} style={{ marginTop: 0 }}>
          Haven't found an answer to your question?
        </Title>
        <Text style={{ marginTop: '1rem' }}>
          Connect with us either on discord or email us
        </Text>
        <Flex gap="middle" justify="center" style={{ marginTop: '1rem' }}>
          <Button href="mailto:kelvin.kiprop96@gmail.com" type="primary">
            Email
          </Button>
          <Button target="_blank" href={`${PATH_GITHUB.repo}/issues`}>
            Submit an issue
          </Button>
        </Flex>
      </Card>
    </div>
  );
};


src\pages\index.ts:
export { HomePage } from './Home.tsx';
export * from './dashboards';
export * from './userAccount';
export * from './authentication';
export * from './errors';
export * from './create';


src\pages\QRScannerPage.tsx:
// src/pages/QRScannerPage.tsx
import React, { useState, useRef } from 'react';
import { QrReader } from 'react-qr-reader';
import { Input, Button, message, Typography, Card, Spin } from 'antd';
import { BackBtn, PageHeader } from '../components';
import { Helmet } from 'react-helmet-async';
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../constants';
import { Link, useNavigate, useParams } from 'react-router-dom';
import authService from '../services/authService';

const { Title, Text } = Typography;

const QRScannerPage: React.FC = () => {
  const [lastScannedCode, setLastScannedCode] = useState<string>('');
  const [manualCode, setManualCode] = useState<string>('');
  const [isCameraActive, setIsCameraActive] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();
  const { id: eventId } = useParams<{ id: string }>();
  const isProcessingScan = useRef(false); // Theo dõi trạng thái xử lý scan

  // Thêm tham số manual để phân biệt quét tự động (manual = false) và submit thủ công (manual = true)
  const handleScanTicket = async (code: string, manual: boolean = false) => {
    if (isProcessingScan.current) {
      return;
    }
    isProcessingScan.current = true;
    setIsCameraActive(false);
    // Nếu không phải submit thủ công thì bật loading
    if (!manual) {
      setIsLoading(true);
      message.loading({ content: 'Checking ticket...', key: 'scanMessage', duration: 0 });
    }

    const startTime = Date.now();
    let response: { statusCode: number; data?: any[]; error?: string } | null = null;
    try {
      response = await authService.scanTicket(code.trim()) as { statusCode: number; data?: any[]; error?: string };
    } catch (error: any) {
      response = { statusCode: 500, error: error.error || 'Scan failed.' };
    }

    // Nếu submit tự động, đảm bảo hiển thị loading ít nhất 3s
    if (!manual) {
      const elapsed = Date.now() - startTime;
      const remainingTime = 3000 - elapsed;
      if (remainingTime > 0) {
        await new Promise((resolve) => setTimeout(resolve, remainingTime));
      }
    }

    if (!manual) {
      setIsLoading(false);
    }

    // Hiển thị thông báo kết quả
    if (response.statusCode === 200) {
      message.success({
        content: `Ticket scanned: ${response.data && response.data[0]?.name ? response.data[0].name : ''}. Ready for next scan.`,
        key: 'scanMessage',
        duration: 2,
      });
    } else {
      message.error({ content: response.error || 'Scan failed.', key: 'scanMessage', duration: 2 });
    }

    setIsCameraActive(true);
    setLastScannedCode('');
    isProcessingScan.current = false;
  };

  // Hàm xử lý khi mã QR được quét tự động (chỉ xử lý khi manualCode trống)
  const handleScan = (result: any) => {
    if (result && isCameraActive && manualCode.trim() === '') {
      const code = result.getText();
      if (code && code !== lastScannedCode) {
        setLastScannedCode(code);
        handleScanTicket(code); // Gọi với manual = false (mặc định)
      }
    }
  };

  // Hàm xử lý lỗi camera
  const handleError = (error: any) => {
    setIsCameraActive(false);
    console.error(error);
  };

  // Khi submit thủ công, gọi handleScanTicket với manual = true để bỏ qua delay
  const handleManualSubmit = async () => {
    if (manualCode.trim() === '') {
      message.warning('Please enter a code manually.');
      return;
    }
    // Gọi hàm xử lý mà không chờ delay
    handleScanTicket(manualCode.trim(), true);
    setManualCode('');
  };

  // Hàm xử lý hoàn thành sự kiện (giữ nguyên)
  const handleFinish = async () => {
    setIsCameraActive(false);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken || !eventId) {
        message.error('Missing access token or event id.');
        return;
      }
      const response = await authService.updateEvent(eventId, { status: 'FINISHED' }, accessToken) as { statusCode: number; message?: string };
      if (response.statusCode === 200) {
        message.success('Event finished successfully.');
        navigate('/dashboards/my-events');
      } else {
        message.error(response.message || 'Failed to finish event.');
      }
    } catch (error: any) {
      message.error(error.message || 'Failed to finish event.');
    } finally {
      setIsCameraActive(true);
    }
  };

  return (
    <div>
      <Helmet>
        <title>QR Scanner | Event Check-in/Check-out</title>
      </Helmet>
      <PageHeader
        title="QR Code Scanner"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          { title: 'QR Scanner' },
        ]}
        btnBack={<BackBtn />}
      />
      <BackBtn />

      <Card>
        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '24px' }}>
          <Title level={4}>Event Check-in/Check-out Scanner</Title>
          <div
            style={{
              border: '1px solid #ccc',
              padding: '10px',
              width: '100%',
              maxWidth: '500px',
              height: '400px',
              borderRadius: '8px',
              overflow: 'hidden',
              position: 'relative',
            }}
          >
            <QrReader
              constraints={{ facingMode: 'environment' }}
              scanDelay={300}
              onResult={(result, error) => {
                if (!!result) {
                  handleScan(result);
                }
                if (!!error) {
                  handleError(error);
                }
              }}
              videoStyle={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
              }}
            />
            {isLoading && (
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  backgroundColor: 'rgba(255, 255, 255, 0.5)',
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  borderRadius: '8px',
                }}
              >
                <Spin size="large" tip="Checking Ticket..." />
              </div>
            )}
          </div>
          <Text>Scanning for QR codes...</Text>

          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '12px' }}>
            <Text>Manual Code Entry:</Text>
            <Input
              placeholder="Enter code manually"
              value={manualCode}
              onChange={(e) => setManualCode(e.target.value)}
              style={{ width: 300 }}
            />
            <Button onClick={handleManualSubmit} disabled={isLoading}>
              Submit Code
            </Button>
          </div>

          <Button type="primary" onClick={handleFinish} style={{ marginTop: 20 }} disabled={isLoading}>
            Finish Event
          </Button>
        </div>
      </Card>
    </div>
  );
};

export default QRScannerPage;


src\pages\authentication\AccountDeactivate.tsx:
// src/pages/authentication/AccountDeactivate.tsx
import { Button, Flex, Typography, message } from 'antd';
import { Logo } from '../../components';
import { Link, useNavigate } from 'react-router-dom';
import { PATH_DASHBOARD } from '../../constants';
import { useState } from 'react';

const { Title, Text } = Typography;

export const AccountDeactivePage = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);

  const handleDeactivate = async () => {
    setLoading(true);
    try {
      const response = await fetch(`${import.meta.env.VITE_APP_API_URL}/auth/account-delete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      if (!response.ok) {
        throw new Error("Account deactivation failed");
      }
      message.success("Account deactivated successfully");
      navigate(PATH_DASHBOARD.default);
    } catch (error: any) {
      message.error(error.message || "Deactivation error");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Flex vertical gap="large" align="center" justify="center" style={{ height: '80vh' }}>
      <Logo color="blue" />
      <Title level={2} className="m-0">Deactivated Account</Title>
      <Text style={{ fontSize: 18 }}>
        Your account has been deactivated.
      </Text>
      <Button type="primary" onClick={handleDeactivate} loading={loading}>
        Reactivate Account
      </Button>
      <Link to={PATH_DASHBOARD.default}>
        <Button type="default">Go to Homepage</Button>
      </Link>
    </Flex>
  );
};


src\pages\authentication\ChangePassword.tsx:


src\pages\authentication\ForgotPassword.tsx:


src\pages\authentication\GoogleCallbackPage.tsx:
// src\pages\authentication\GoogleCallbackPage.tsx
import React, { useEffect, useCallback } from 'react'; // Import useCallback
import { useNavigate, useSearchParams } from 'react-router-dom';
import { message, Spin } from 'antd';
import axios from 'axios';
import { setUser } from '../../redux/userSlice';
import { useDispatch } from 'react-redux';

interface GoogleCallbackPageProps {
    clientId: string;
    redirectUri: string;
    scope: string;
    backendTokenEndpoint: string;
    onLoginSuccess: (accessToken: string, user: any) => void;
    onLoginFailure: (error: string) => void;
}

const GoogleCallbackPage: React.FC<GoogleCallbackPageProps> = ({
    clientId,
    redirectUri,
    scope,
    backendTokenEndpoint,
    onLoginSuccess,
    onLoginFailure,
}) => {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();
    const dispatch = useDispatch();

    // **Định nghĩa exchangeCodeForToken trước useEffect**
    const exchangeCodeForToken = useCallback(async (code: string) => { // Thêm useCallback
        try {
            const codeVerifier = localStorage.getItem('google_code_verifier');
            if (!codeVerifier) {
                throw new Error("Code verifier not found in localStorage");
            }
            localStorage.removeItem('google_code_verifier');

            const tokenResponse = await axios.post(backendTokenEndpoint, {
                code,
                clientId,
                redirectUri,
                codeVerifier,
                grantType: 'authorization_code',
            });

            const { accessToken, user } = tokenResponse.data as { accessToken: string, user: any };

            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('user', JSON.stringify(user));
            dispatch(setUser(user));
            onLoginSuccess(accessToken, user);
            message.success('Google login successful!');
            navigate('/dashboards/general');
        } catch (error: any) {
            console.error("Error exchanging code for token:", error);
            onLoginFailure(error.message || 'Failed to exchange code for token');
            message.error('Google login failed. Please try again.');
            navigate('/auth/signin');
        }
    }, [backendTokenEndpoint, clientId, dispatch, navigate, onLoginFailure, onLoginSuccess, redirectUri]); // Thêm dependencies cho useCallback

    useEffect(() => {
        const code = searchParams.get('code');
        if (code) {
            exchangeCodeForToken(code);
        } else {
            const error = searchParams.get('error');
            if (error) {
                onLoginFailure(`Google login error: ${error}`);
                message.error(`Google login error: ${error}`);
                navigate('/auth/signin');
            }
        }
    }, [searchParams, navigate, exchangeCodeForToken, onLoginFailure]); // Giữ exchangeCodeForToken trong dependencies

    return (
        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
            <Spin size="large" tip="Đang xử lý đăng nhập Google..." />
        </div>
    );
};

export default GoogleCallbackPage;


src\pages\authentication\index.ts:
// src/pages/authentication/index.ts
export { SignUpPage } from './SignUp';
export { SignInPage } from './SignIn';
export { WelcomePage } from './Welcome';
export { VerifyEmailPage } from './VerifyEmail';
export { PasswordResetPage } from './PasswordReset';
export { AccountDeactivePage } from './AccountDeactivate';


src\pages\authentication\PasswordReset.tsx:
// src\pages\authentication\PasswordReset.tsx
import React, { useState } from 'react';
import {
  Button,
  Col,
  Flex,
  Form,
  Input,
  message,
  Row,
  theme,
  Typography,
  Alert, // Import Alert
} from 'antd';
import { Logo } from '../../components';
import { useMediaQuery } from 'react-responsive';
import { PATH_AUTH } from '../../constants';
import { useNavigate } from 'react-router-dom';
import authService from '../../services/authService'; // Import authService

const { Title, Text } = Typography;

type FieldType = {
  email?: string;
};

export const PasswordResetPage = () => {
  const {
    token: { colorPrimary },
  } = theme.useToken();
  const isMobile = useMediaQuery({ maxWidth: 769 });
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null); // State error

  const onFinish = async (values: FieldType) => {
    setLoading(true);
    setError(null); // Reset error khi bắt đầu submit
    try {
      const response = await authService.forgotPassword(values.email as string) as { message: string }; // Gọi authService.forgotPassword
      message.success(response.message);
      setTimeout(() => {
        navigate(PATH_AUTH.signin); // Redirect về trang signin sau khi thành công
      }, 3000); // Giảm thời gian redirect xuống 3 giây
    } catch (error: any) {
      setError(error.message || "Password reset failed!"); // Set error message
      // message.error(error.message || "Password reset failed!"); // Không cần message.error ở đây, Alert sẽ hiển thị lỗi
    } finally {
      setLoading(false);
    }
  };

  return (
    <Row style={{ minHeight: isMobile ? 'auto' : '100vh', overflow: 'hidden' }}>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align="center"
          justify="center"
          className="text-center"
          style={{ background: colorPrimary, height: '100%', padding: '1rem' }}
        >
          <Logo color="white" />
          <Title level={2} className="text-white">
            Forgot Password
          </Title>
          <Text className="text-white" style={{ fontSize: 18 }}>
            Enter your email to reset your password.
          </Text>
        </Flex>
      </Col>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align={isMobile ? 'center' : 'flex-start'}
          justify="center"
          gap="middle"
          style={{ height: '100%', width: '100%', padding: '2rem' }}
        >
          <Title className="m-0">Forgot password</Title>
          {error && <Alert message="Error" description={error} type="error" showIcon closable onClose={() => setError(null)} />} {/* Hiển thị Alert lỗi */}
          <Form
            name="password-reset-form" // Đổi tên form
            layout="vertical"
            labelCol={{ span: 24 }}
            wrapperCol={{ span: 24 }}
            initialValues={{}} // Loại bỏ remember: true
            onFinish={onFinish}
            autoComplete="off"
            requiredMark={false}
            style={{ width: '100%' }}
          >
            <Form.Item<FieldType>
              label="Email"
              name="email"
              rules={[
                { required: true, message: 'Please input your email' },
                { type: 'email', message: 'Please enter a valid email' },
              ]}
            >
              <Input placeholder="Your email address" />
            </Form.Item>
            <Form.Item>
              <Flex align="center" gap="small">
                <Button
                  type="primary"
                  htmlType="submit"
                  size="middle"
                  loading={loading}
                >
                  Submit
                </Button>
                <Button type="text" size="middle" loading={loading} onClick={() => navigate(PATH_AUTH.signin)}> {/* Thêm onClick handler để cancel */}
                  Cancel
                </Button>
              </Flex>
            </Form.Item>
          </Form>
        </Flex>
      </Col>
    </Row >
  );
};

src\pages\authentication\SignIn.tsx:
// src\pages\authentication\SignIn.tsx
// src\pages\authentication\SignInPage.tsx
import React, { useState, useEffect } from 'react';
import {
  Button,
  Col,
  Divider,
  Flex,
  Form,
  Input,
  message,
  Row,
  theme,
  Typography,
} from 'antd';
import {
  Link,
  useLocation,
  useNavigate,
} from 'react-router-dom';
import authService from '../../services/authService';
import { useDispatch, useSelector } from 'react-redux';
import { setUser } from '../../redux/userSlice';
import GoogleLoginButton from '../../components/GoogleLoginButton';
import { PATH_AUTH } from '../../constants';
import { useMediaQuery } from 'react-responsive';
import { Logo } from '../../components';
import { RootState } from '../../redux/store';

const { Title, Text } = Typography;

type FieldType = {
  email?: string;
  password?: string;
};

export const SignInPage = () => {
  const {
    token: { colorPrimary },
  } = theme.useToken();
  const isMobile = useMediaQuery({ maxWidth: 769 });
  const navigate = useNavigate();
  const location = useLocation();
  const [loading, setLoading] = useState(false);
  const useDispatchHook = useDispatch();
  const user = useSelector((state: RootState) => state.user);

  // useEffect hook to redirect if already logged in
  useEffect(() => {
    if (user && user.id) {
      navigate('/dashboards/general', { replace: true });
    }
  }, [user, navigate]);


  const onFinish = async (values: FieldType) => {
    setLoading(true);
    try {
      const response = await authService.login(values) as unknown as {
        statusCode: number,
        message: string,
        data: {
          accessToken: string,
          user: any
        },
        error?: string
      };

      if (response.statusCode === 200) {
        message.success(response.message);

        localStorage.setItem('accessToken', response.data.accessToken);
        localStorage.setItem('user', JSON.stringify(response.data.user));
        useDispatchHook(setUser(response.data.user));

        setTimeout(() => {
          const from = location.state?.from || '/dashboards/general'; // Lấy URL đầy đủ từ state.from
          navigate(from, { replace: true }); // Redirect đến URL đầy đủ hoặc dashboard
        }, 1000);
      } else {
        message.error(response.error || 'Login failed');
      }
    } catch (error: any) {
      message.error(error.error || 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };


  return (
    <Row style={{ minHeight: isMobile ? 'auto' : '100vh', overflow: 'hidden' }}>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align="center"
          justify="center"
          className="text-center"
          style={{ background: colorPrimary, height: '100%', padding: '1rem' }}
        >
          <Logo color="white" />
          <Title level={2} className="text-white">
            Welcome back to Event Management
          </Title>
          <Text className="text-white" style={{ fontSize: 18 }}>
            Sign in page
          </Text>
        </Flex>
      </Col>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align={isMobile ? 'center' : 'flex-start'}
          justify="center"
          gap="middle"
          style={{ height: '100%', padding: '2rem' }}
        >
          <Title className="m-0">Login</Title>
          <Flex gap={4}>
            <Text>Don't have an account?</Text>
            <Link to={PATH_AUTH.signup}>Create an account here</Link>
          </Flex>
          <Form
            name="sign-in-form"
            layout="vertical"
            labelCol={{ span: 24 }}
            wrapperCol={{ span: 24 }}
            initialValues={{}}
            onFinish={onFinish}
            onFinishFailed={onFinishFailed}
            autoComplete="off"
            requiredMark={false}
          >
            <Row gutter={[8, 0]}>
              <Col xs={24}>
                <Form.Item<FieldType>
                  label="Email"
                  name="email"
                  rules={[
                    { required: true, message: 'Please input your email' },
                  ]}
                >
                  <Input />
                </Form.Item>
              </Col>
              <Col xs={24}>
                <Form.Item<FieldType>
                  label="Password"
                  name="password"
                  rules={[
                    { required: true, message: 'Please input your password!' },
                  ]}
                >
                  <Input.Password autoComplete="current-password" />
                </Form.Item>
              </Col>
            </Row>
            <Form.Item>
              <Flex align="center" justify="space-between">
                <Button
                  type="primary"
                  htmlType="submit"
                  size="middle"
                  loading={loading}
                >
                  Continue
                </Button>
                <Link to={PATH_AUTH.passwordReset}>Forgot password?</Link>
              </Flex>
            </Form.Item>
          </Form>
          <Divider className="m-0">or</Divider>
          <Flex
            vertical={isMobile}
            gap="small"
            wrap="wrap"
            style={{ width: '100%' }}
          >
            <GoogleLoginButton />
          </Flex>
        </Flex>
      </Col>
    </Row>
  );
};


src\pages\authentication\SignUp.tsx:
import React, { useState } from 'react';
import {
  Button,
  Col,
  Divider,
  Flex,
  Form,
  Input,
  message,
  Row,
  theme,
  Typography,
} from 'antd';
import {
  FacebookFilled,
  GoogleOutlined,
  TwitterOutlined,
} from '@ant-design/icons';
import { Logo } from '../../components';
import { useMediaQuery } from 'react-responsive';
import { PATH_AUTH, PATH_DASHBOARD } from '../../constants';
import { useNavigate } from 'react-router-dom';
import authService from '../../services/authService'; // Import service

const { Title, Text, Link } = Typography;

type FieldType = {
  name?: string;
  email?: string;
  password?: string;
  remember?: boolean;
};

export const SignUpPage = () => {
  const {
    token: { colorPrimary },
  } = theme.useToken();
  const isMobile = useMediaQuery({ maxWidth: 769 });
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);

  const onFinish = async (values: FieldType) => {
    setLoading(true);
    try {
      const response = await authService.register(values);

      message.success('Registration successful, please login.');
      setTimeout(() => {
        navigate(PATH_AUTH.signin);
      }, 1000); // chuyển hướng đến trang đăng nhập sau 1s
    } catch (error: any) {
      console.error('Registration failed:', error);
      message.error(error.message || 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  return (
    <Row style={{ minHeight: isMobile ? 'auto' : '100vh', overflow: 'hidden' }}>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align="center"
          justify="center"
          className="text-center"
          style={{ background: colorPrimary, height: '100%', padding: '1rem' }}
        >
          <Logo color="white" />
          <Title level={2} className="text-white">
            Welcome back to Event Management
          </Title>
          <Text className="text-white" style={{ fontSize: 18 }}>
            Sign up page
          </Text>
        </Flex>
      </Col>
      <Col xs={24} lg={12}>
        <Flex
          vertical
          align={isMobile ? 'center' : 'flex-start'}
          justify="center"
          gap="middle"
          style={{ height: '100%', padding: '2rem' }}
        >
          <Title className="m-0">Create an account</Title>
          <Flex gap={4}>
            <Text>Already have an account?</Text>
            <Link href={PATH_AUTH.signin}>Sign in here</Link>
          </Flex>
          <Flex
            vertical={isMobile}
            gap="small"
            wrap="wrap"
            style={{ width: '100%' }}
          >
            <Button icon={<GoogleOutlined />}>Sign up with Google</Button>
            <Button icon={<FacebookFilled />}>Sign up with Facebook</Button>
            <Button icon={<TwitterOutlined />}>Sign up with Twitter</Button>
          </Flex>
          <Divider className="m-0">or</Divider>
          <Form
            name="sign-up-form"
            layout="vertical"
            labelCol={{ span: 24 }}
            wrapperCol={{ span: 24 }}
            initialValues={{ remember: true }}
            onFinish={onFinish}
            onFinishFailed={onFinishFailed}
            autoComplete="off"
            requiredMark={false}
          >
            <Row gutter={[8, 0]}>
              <Col xs={24}>
                <Form.Item<FieldType>
                  label="User name"
                  name="name"
                  rules={[
                    {
                      required: true,
                      message: 'Please input your name!',
                    },
                  ]}
                >
                  <Input />
                </Form.Item>
              </Col>
              <Col xs={24}>
                <Form.Item<FieldType>
                  label="Email"
                  name="email"
                  rules={[
                    { required: true, message: 'Please input your email' },
                  ]}
                >
                  <Input />
                </Form.Item>
              </Col>
              <Col xs={24}>
                <Form.Item<FieldType>
                  label="Password"
                  name="password"
                  rules={[
                    { required: true, message: 'Please input your password!' },
                  ]}
                >
                  <Input.Password />
                </Form.Item>
              </Col>
            </Row>
            <Form.Item>
              <Button
                type="primary"
                htmlType="submit"
                size="middle"
                loading={loading}
              >
                Submit
              </Button>
            </Form.Item>
          </Form>
        </Flex>
      </Col>
    </Row>
  );
};


src\pages\authentication\VerifyEmail.tsx:
// src/pages/authentication/VerifyEmail.tsx
import { Button, Flex, Typography, message } from 'antd';
import { Logo } from '../../components';
import { Link, useNavigate, useSearchParams } from 'react-router-dom';
import { PATH_DASHBOARD } from '../../constants';
import { useState, useEffect } from 'react';

const { Title, Text } = Typography;

export const VerifyEmailPage = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [searchParams] = useSearchParams();
  const token = searchParams.get('token');

  const handleVerify = async () => {
    if (!token) {
      message.error("Missing verification token");
      return;
    }
    setLoading(true);
    try {
      const response = await fetch(`${import.meta.env.VITE_APP_API_URL}/auth/verify-email`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token }),
      });
      if (!response.ok) {
        throw new Error("Email verification failed");
      }
      message.success("Email verified successfully");
      navigate(PATH_DASHBOARD.default);
    } catch (error: any) {
      message.error(error.message || "Verification error");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Optionally auto-trigger verification on load
    // handleVerify();
  }, [token]);

  return (
    <Flex vertical gap="large" align="center" justify="center" style={{ height: '80vh' }}>
      <Logo color="blue" />
      <Title level={2} className="m-0">Verify Your Email</Title>
      <Text style={{ fontSize: 18 }}>
        Click the button below to verify your email.
      </Text>
      <Button type="primary" onClick={handleVerify} loading={loading}>
        Verify Email
      </Button>
      <Flex gap={2}>
        <Text>Didn't receive an email?</Text>
        <Link onClick={handleVerify} to={''}>Resend</Link>
      </Flex>
    </Flex>
  );
};


src\pages\authentication\Welcome.tsx:
// src/pages/authentication/Welcome.tsx
import { Button, Flex, Typography } from 'antd';
import { Logo } from '../../components';
import { Link } from 'react-router-dom';
import { PATH_DASHBOARD } from '../../constants';

const { Title, Text } = Typography;

export const WelcomePage = () => {
  return (
    <Flex vertical gap="large" align="center" justify="center" style={{ height: '80vh' }}>
      <Logo color="blue" />
      <Title level={2} className="m-0">Welcome to Our App</Title>
      <Text style={{ fontSize: 18 }}>
        Your account has been created successfully.
      </Text>
      <Link to={PATH_DASHBOARD.default}>
        <Button type="primary" size="middle">
          Go to Homepage
        </Button>
      </Link>
    </Flex>
  );
};


src\pages\create\Events.tsx:
// src\pages\create\Events.tsx
import { Button, Col, DatePicker, Form, Input, InputNumber, message, Modal, Row, Select, Typography, Checkbox, Alert } from 'antd';
import { Card, Loader } from '../../components';
import { SaveOutlined } from '@ant-design/icons';
import { Events } from '../../types';
import { useState, useEffect } from 'react';
import { useFetchData } from '../../hooks';
import { useNavigate } from 'react-router-dom';
import { PATH_DASHBOARD } from '../../constants';
import authService from '../../services/authService'; // Import authService
import dayjs from 'dayjs';

type FieldType = {
    name: string;
    description?: string;
    startDate: any; // Date type from DatePicker is 'dayjs'
    endDate: any;   // Date type from DatePicker is 'dayjs'
    location: string;
    categoryId: string;
    maxParticipants?: number;
    isFree?: boolean;
    price?: number;
    banner?: string;
    videoIntro?: string;
};

export const CreateEventPage = () => {
    const { data: users } = useFetchData('../mocks/Users.json');

    const [loading, setLoading] = useState(false);
    // Modal State for create event type
    const [isCreateTypeModalOpen, setIsCreateTypeModalOpen] = useState<any>(false);
    const [types, setTypes] = useState<any>([]); // Initialize types as empty array
    const [categoriesLoading, setCategoriesLoading] = useState(false);
    const [categoriesError, setCategoriesError] = useState<string | null>(null);


    const [form] = Form.useForm();
    const navigate = useNavigate();

    useEffect(() => {
        const fetchEventCategories = async () => {
            setCategoriesLoading(true);
            try {
                const accessToken = localStorage.getItem('accessToken');
                if (!accessToken) {
                    message.error("No access token found. Please login again.");
                    navigate(PATH_DASHBOARD.default);
                    return;
                }
                const response = await authService.getCategories(accessToken) as { statusCode: number; data: { categories: any[] } };
                if (response.statusCode === 200 && response.data.categories) {
                    setTypes(response.data.categories.map((category: any) => ({
                        value: category.id,
                        label: category.name,
                    })));
                } else {
                    setCategoriesError("Failed to load event categories.");
                    message.error("Failed to load event categories.");
                }
            } catch (error: any) {
                console.error("Failed to load event categories:", error);
                setCategoriesError("Failed to load event categories.");
                message.error("Failed to load event categories.");
            } finally {
                setCategoriesLoading(false);
            }
        };

        fetchEventCategories();
    }, [navigate]);


    const showCreateTypeModal = () => {
        setIsCreateTypeModalOpen(true);
    };

    const handleOkCreateType = () => {
        setIsCreateTypeModalOpen(false);
        form.submit()
    };

    const handleCancelCreateType = () => {
        setIsCreateTypeModalOpen(false);
    };


    const onFinish = async (values: FieldType) => {
        setLoading(true);
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) {
                message.error("No access token found. Please login again.");
                navigate(PATH_DASHBOARD.default);
                return;
            }

            const eventData = {
                name: values.name,
                description: values.description,
                startDate: values.startDate.toISOString(), // Convert to ISO string
                endDate: values.endDate.toISOString(),     // Convert to ISO string
                location: values.location,
                categoryId: values.categoryId,
                maxParticipants: values.maxParticipants,
                isFree: values.isFree || false, // Default to false if not checked
                price: values.price,
                banner: values.banner,
                videoIntro: values.videoIntro,
                schedule: [], // Empty schedule for now
                guestIds: [],   // Empty guestIds for now
            };


            const response = await authService.createEvent(eventData, accessToken) as { statusCode: number; message: string };
            if (response && response.statusCode === 201) {
                message.success(response.message);
                setTimeout(() => {
                    navigate(PATH_DASHBOARD.my_events);
                }, 1000);
            } else {
                if (response && 'message' in response) {
                    message.error(response.message);
                } else {
                    message.error('Failed to create event');
                }
            }
        } catch (error: any) {
            console.error('Error creating event:', error);
            message.error(error.message || 'Failed to create event');
        } finally {
            setLoading(false);
        }
    };

    // Modal State for create user
    const [isCreateUserModalOpen, setIsCreateUserModalOpen] = useState<any>(false);

    const showCreateUserModal = () => {
        setIsCreateUserModalOpen(true);
    };

    const handleOkCreateUser = () => {
        setIsCreateUserModalOpen(false);
    };

    const handleCancelCreateUser = () => {
        setIsCreateUserModalOpen(false);
    };

    const onFinishFailed = (errorInfo: any) => {
        console.log('Failed:', errorInfo);
    };

    const onFinishType = async (values: any) => {
        setCategoriesLoading(true);
        try {
            const accessToken = localStorage.getItem('accessToken');
            if (!accessToken) {
                message.error("No access token found. Please login again.");
                navigate(PATH_DASHBOARD.default);
                return;
            }
            const response = await authService.createCategory({ name: values.event_type, description: "" }, accessToken) as { statusCode: number; message: string; data: { category: { id: string; name: string } } };
            if (response && response.statusCode === 201) {
                message.success(response.message);
                // Update types with the new category
                setTypes([...types, { value: response.data.category.id, label: response.data.category.name }]);
                form.setFieldsValue({ categoryId: response.data.category.id }); // Optionally select the new category
                setIsCreateTypeModalOpen(false);
            } else {
                message.error(response?.message || 'Failed to create event type');
            }
        } catch (error: any) {
            console.error('Error creating event type:', error);
            message.error(error.message || 'Failed to create event type');
        } finally {
            setCategoriesLoading(false);
        }
    };

    return (
        <Card title="Create New Event">
             {categoriesError && (
                <Alert
                    message="Error"
                    description={categoriesError}
                    type="error"
                    showIcon
                    closable
                    onClose={() => setCategoriesError(null)}
                    style={{ marginBottom: 10 }}
                />
            )}
            <Modal title="Create Event Type" open={isCreateTypeModalOpen} onOk={handleOkCreateType} onCancel={handleCancelCreateType}>
                <Form layout='vertical'
                    onFinish={onFinishType}
                    form={form}
                >
                    <Form.Item label="Event Type" name="event_type" rules={[{ required: true, message: 'Please input event type!' }]}>
                        <Input placeholder="Enter Event Type" />
                    </Form.Item>
                    <Form.Item>
                        <Button type="primary" htmlType="submit" loading={categoriesLoading}>
                            Create Type
                        </Button>
                    </Form.Item>
                </Form>
            </Modal>
            <Modal title="Create Event User" open={isCreateUserModalOpen} onOk={handleOkCreateUser} onCancel={handleCancelCreateUser}>
                <Form layout='vertical'>
                    <Form.Item label="User's Email">
                        <Input placeholder="example@email.com" />
                    </Form.Item>
                    <Form.Item label="User's Full Name">
                        <Input placeholder="John Doe" />
                    </Form.Item>
                    <Form.Item label="User's Title">
                        <Input placeholder="Software Engineer" />
                    </Form.Item>
                </Form>
            </Modal>
            <Form
                name="create-event-form"
                layout="vertical"
                onFinish={onFinish}
                onFinishFailed={onFinishFailed}
                autoComplete="on"
                requiredMark={false}
            >
                <Row gutter={[16, 0]}>
                    <Col sm={24} lg={24}>
                        <Form.Item<FieldType>
                            label="Event's Name"
                            name="name"
                            rules={[{ required: true, message: 'Please input your event name!' }]}
                        >
                            <Input
                                placeholder='Tech Conference 2026'
                            />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={24}>
                        <Form.Item<FieldType>
                            label="Event's Description"
                            name="description"
                            rules={[{ required: false }]}
                        >
                            <Input.TextArea
                                rows={3}
                                placeholder='A major event about technology and innovation (optional)'
                            />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={8}>
                        <Form.Item<FieldType>
                            label="Event's Capacity"
                            name="maxParticipants"
                            rules={[{ required: false, message: 'Please input event capacity!' }]}
                        >
                            <InputNumber style={{ width: "100%" }} min={0} placeholder="Unlimited if empty" />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={8}>
                        <Form.Item<FieldType>
                            label="Start At"
                            name="startDate"
                            rules={[
                                { required: true, message: 'Please input your start of event' },
                            ]}
                        >
                            <DatePicker style={{ width: "100%" }} showTime format="YYYY-MM-DD HH:mm:ss" />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={8}>
                        <Form.Item<FieldType>
                            label="End At"
                            name="endDate"
                            rules={[
                                { required: true, message: 'Please input your end of event' },
                            ]}
                        >
                            <DatePicker style={{ width: "100%" }} showTime format="YYYY-MM-DD HH:mm:ss" />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={12}>
                        <Form.Item<FieldType>
                            label="Location"
                            name="location"
                            rules={[{ required: true, message: 'Please input event location!' }]}
                        >
                            <Input placeholder="Hall A, University Campus" />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={12}>
                        <Form.Item<FieldType>
                            label="Event Type"
                            name="categoryId" // Using categoryId to match API request
                            rules={[
                                { required: true, message: 'Please input your event type!' },
                            ]}
                        >
                            <Select
                                dropdownRender={(menu) => (
                                    <>
                                        {menu}
                                        <Button type="text" style={{ width: "100%" }} onClick={showCreateTypeModal} loading={categoriesLoading} >
                                            Create New Type
                                        </Button>
                                    </>
                                )}
                                options={types} // Use fetched categories here
                                placeholder="Select Event Type"
                                loading={categoriesLoading}
                            />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={12}>
                        <Form.Item<FieldType>
                            label="Banner URL (Optional)"
                            name="banner"
                            rules={[{ required: false }]}
                        >
                            <Input placeholder="https://example.com/banner.jpg" />
                        </Form.Item>
                    </Col>
                    <Col sm={24} lg={12}>
                        <Form.Item<FieldType>
                            label="Video Intro URL (Optional)"
                            name="videoIntro"
                            rules={[{ required: false }]}
                        >
                            <Input placeholder="https://example.com/video.mp4" />
                        </Form.Item>
                    </Col>
                    

                </Row>

                <Form.Item>
                    <Button type="primary" htmlType="submit" icon={<SaveOutlined />} loading={loading} disabled={categoriesLoading}>
                        Create Event
                    </Button>
                </Form.Item>
            </Form>
        </Card>
    );
};

src\pages\create\index.ts:
export {CreateEventPage} from './Events';

src\pages\dashboards\EventParticipantsTable.tsx:
// src\pages\dashboards\EventParticipantsTable.tsx
import React from 'react';
import { Table, TableProps, Alert } from 'antd';

import dayjs from 'dayjs';
import { Loader } from '../../components';
import { useFetchData } from '../../hooks';
import { Participants } from '../../types';

interface EventParticipantsTableProps extends TableProps<Participants> {
    eventId: string | undefined; // EventId can be undefined
}

const PARTICIPANTS_COLUMNS = [
    {
        title: 'ID',
        dataIndex: 'id',
        key: 'id',
    },
    {
        title: 'Name',
        dataIndex: 'name',
        key: 'name',
    },
    {
        title: 'Email',
        dataIndex: 'email',
        key: 'email',
    },
    {
        title: 'Check-in Time',
        dataIndex: 'checkInAt',
        key: 'checkInAt',
        render: (text: string) => text ? dayjs(text).format('YYYY-MM-DD HH:mm:ss') : 'N/A',
    },
    {
        title: 'Check-out Time',
        dataIndex: 'checkOutAt',
        key: 'checkOutAt',
        render: (text: string) => text ? dayjs(text).format('YYYY-MM-DD HH:mm:ss') : 'N/A',
    },
];

const EventParticipantsTable: React.FC<EventParticipantsTableProps> = ({ eventId }) => {
    const { data: participantsData, error: participantsError, loading: participantsLoading } = useFetchData(
        eventId ? `http://localhost:8080/api/v1/events/${eventId}/participants` : "", // Correct API URL
        localStorage.getItem('accessToken') || undefined
    );

    if (!eventId) {
        return <Alert message="Event ID is missing." type="warning" showIcon />;
    }

    if (participantsLoading) {
        return <Loader />;
    }

    if (participantsError) {
        return <Alert message="Error loading participants" description={participantsError.toString()} type="error" showIcon />;
    }

    // Check if data.data exists and is an array before accessing its length
    if (!participantsData?.data || !Array.isArray(participantsData.data) || participantsData.data.length === 0) {
        return <Alert message="No participants found for this event." type="info" showIcon />;
    }


    return (
        <div>
            <Table
                dataSource={participantsData.data}
                columns={PARTICIPANTS_COLUMNS}
                loading={participantsLoading} // Use hook's loading state
                pagination={{ pageSize: 5 }}
                rowKey="id"
            />
        </div>
    );
};

export { EventParticipantsTable };


src\pages\dashboards\Events.tsx:
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { useStylesContext } from '../../context';
import { Helmet } from 'react-helmet-async';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import {
    Col,
    Row,
} from 'antd';
  import {
    PageHeader,
} from '../../components';
import {
  EventTable
} from '../../components/dashboard';
import { useFetchData } from '../../hooks';


const EventsDashboardPage = () => {
    const stylesContext = useStylesContext();
    const {
        data: events,
        error: eventsError,
        loading: eventsLoading,
      } = useFetchData('../mocks/Events.json');
  return (
    <div>
      <Helmet>
        <title>Incomming Events | Antd Dashboard</title>
      </Helmet>
      <PageHeader
        title="incomming events dashboard"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'events',
          },
        ]}
      />
      <Row {...stylesContext?.rowProps}>
      <Col span={24}>
          <EventTable data={events} loading={eventsLoading} error={eventsError} />
        </Col>
      </Row>
    </div>
  )
}

export default EventsDashboardPage

src\pages\dashboards\EventsList.tsx:
// src/pages/dashboards/EventsList.tsx
import React, { useEffect, useState } from 'react';
import { Alert, Button, Card, Space, Table, Tag, Select, message, Spin, Input } from 'antd';
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { PageHeader } from '../../components';
import useFetchData from '../../hooks/useFetchData';
import { ColumnsType } from 'antd/es/table';
import { Events } from '../../types';
import dayjs from 'dayjs';
import authService from '../../services/authService';

interface EventsListResponse {
  data: {
    events: Events[];
    meta: {
      totalItems: number;
      // ... other meta properties if any ...
    };
  };
  statusCode: number;
  message: string;
}

const EVENT_STATUS_OPTIONS = [
  { value: '', label: 'All Statuses' },
  { value: 'SCHEDULED', label: 'Scheduled' },
  { value: 'CANCELED', label: 'Canceled' },
  { value: 'FINISHED', label: 'Finished' },
];

const EventsListPage = () => {
  const [categoryNamesMap, setCategoryNamesMap] = useState<Record<string, string>>({});
  const [categoryLoading, setCategoryLoading] = useState(false);
  // Use '' (empty string) to represent "All" filters.
  const [statusFilter, setStatusFilter] = useState<string>('');
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [categoryFilter, setCategoryFilter] = useState<string>(''); // '' means All Categories
  const [searchQuery, setSearchQuery] = useState<string>(''); // State for search query

  const {
    data: eventsListResponse,
    error: eventsError,
    loading: eventsLoading,
  } = useFetchData( 
    `http://localhost:8080/api/v1/events?page=${currentPage}&limit=${pageSize}` +
    `${statusFilter ? `&status=${statusFilter}` : ''}` +
    `${categoryFilter ? `&categoryId=${categoryFilter}` : ''}` +
    `${searchQuery ? `&search=${searchQuery}` : ''}`,
    localStorage.getItem('accessToken') || undefined
  );

  useEffect(() => {
    const fetchAllCategoryNames = async () => {
      setCategoryLoading(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getCategories(accessToken || '') as { statusCode: number; data: { categories?: any[] } };
        if (response.statusCode === 200 && response.data.categories) {
          const categoryMap: Record<string, string> = {};
          categoryMap[''] = 'All Categories'; // Add "All Categories" option with empty string key
          response.data.categories.forEach((category: any) => {
            categoryMap[category.id] = category.name;
          });
          setCategoryNamesMap(categoryMap);
        } else {
          message.error("Failed to load event categories.");
        }
      } catch (error: any) {
        message.error("Failed to load event categories.");
      } finally {
        setCategoryLoading(false);
      }
    };
    fetchAllCategoryNames();
  }, []);

  const onStatusFilterChange = (value: string) => {
    setStatusFilter(value);
    setCurrentPage(1);
  };

  const onCategoryFilterChange = (value: string) => {
    setCategoryFilter(value);
    setCurrentPage(1);
  };

  const handleSearch = (value: string) => {
    setSearchQuery(value);
    setCurrentPage(1);
  };

  const handlePaginationChange = (page: number, pageSize: number) => {
    setCurrentPage(page);
    setPageSize(pageSize);
  };

  const columns: ColumnsType<Events> = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
      render: (text, record) => <Link to={`/details/events/${record.id}`}>{text}</Link>,
    },
    {
      title: 'Location',
      dataIndex: 'location',
      key: 'location',
    },
    {
      title: 'Start Date',
      dataIndex: 'startDate',
      key: 'startDate',
      render: (date) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'End Date',
      dataIndex: 'endDate',
      key: 'endDate',
      render: (date) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'Category',
      dataIndex: 'categoryId',
      key: 'event_category',
      render: (categoryId: string) => (
        <Space>
          {categoryLoading ? (
            <Spin />
          ) : (
            <Tag color="blue">{categoryNamesMap[categoryId] || 'N/A'}</Tag>
          )}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status) => (
        <Tag color={status === 'SCHEDULED' ? 'blue' : status === 'CANCELED' ? 'red' : 'green'}>
          {status}
        </Tag>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record) => (
        <Space size="middle">
          <Button type="primary" size="small">
            <Link to={`/details/events/${record.id}`}>Details</Link>
          </Button>
        </Space>
      ),
    },
  ];

  const categoryOptions = Object.entries(categoryNamesMap).map(([key, label]) => ({
    value: key, // key is '' for "All Categories"
    label: label,
  }));

  return (
    <div>
      <Helmet>
        <title>Events List | Antd Dashboard</title>
      </Helmet>
      <PageHeader
        title="Events List"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Events List',
          },
        ]}
      />

      <Card
        title="Events"
        extra={
          <Space>
            <Select
              placeholder="Filter by Category"
              allowClear
              style={{ width: 200 }}
              onChange={onCategoryFilterChange}
              options={categoryOptions}
              value={categoryFilter}
            />
            <Select
              placeholder="Filter by Status"
              allowClear
              style={{ width: 200 }}
              onChange={onStatusFilterChange}
              options={EVENT_STATUS_OPTIONS}
              value={statusFilter}
            />
            <Input.Search
              placeholder="Search by event name"
              onSearch={handleSearch}
              style={{ width: 300 }}
              allowClear
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </Space>
        }
      >
        {eventsError && (
          <Alert
            message="Error"
            description={eventsError.toString()}
            type="error"
            showIcon
            closable
          />
        )}

        <Table
          columns={columns}
          dataSource={eventsListResponse?.data?.events || []}
          loading={eventsLoading}
          pagination={{
            current: currentPage,
            pageSize: pageSize,
            total: eventsListResponse?.data?.meta?.totalItems,
            showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} items`,
            pageSizeOptions: ['10', '20', '50', '100'],
            showSizeChanger: true,
            onChange: handlePaginationChange,
          }}
        />
      </Card>
    </div>
  );
};

export default EventsListPage;


src\pages\dashboards\General.tsx:
import {
  Alert,
  Button,
  ButtonProps,
  Col,
  Flex,
  Image,
  Popover,
  Progress,
  Row,
  Space,
  Table,
  Tag,
  TagProps,
  Typography,
} from 'antd';
import {
  Card,
  CustomerReviewsCard,
  PageHeader,
  RevenueCard,
  UserAvatar,
} from '../../components';
import { Area, Bullet, Pie } from '@ant-design/charts';
import {
  ArrowDownOutlined,
  ArrowUpOutlined,
  CheckCircleOutlined,
  ClockCircleOutlined,
  ExclamationCircleOutlined,
  HomeOutlined,
  PieChartOutlined,
  QuestionOutlined,
  StarFilled,
  SyncOutlined,
} from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { useStylesContext } from '../../context';
import { createElement, CSSProperties } from 'react';
import { useFetchData } from '../../hooks';
import { blue, green, red, yellow } from '@ant-design/colors';
import CountUp from 'react-countup';
import { numberWithCommas } from '../../utils';
import { CategoriesChart } from '../../components/dashboard/default';

const { Text, Title } = Typography;

const SalesChart = () => {
  const data = [
    { country: 'Online Store', date: 'Jan', value: 1390.5 },
    { country: 'Online Store', date: 'Feb', value: 1469.5 },
    { country: 'Online Store', date: 'Mar', value: 1521.7 },
    { country: 'Online Store', date: 'Apr', value: 1615.9 },
    { country: 'Online Store', date: 'May', value: 1703.7 },
    { country: 'Online Store', date: 'Jun', value: 1767.8 },
    { country: 'Online Store', date: 'Jul', value: 1806.2 },
    { country: 'Online Store', date: 'Aug', value: 1903.5 },
    { country: 'Online Store', date: 'Sept', value: 1986.6 },
    { country: 'Online Store', date: 'Oct', value: 1952 },
    { country: 'Online Store', date: 'Nov', value: 1910.4 },
    { country: 'Online Store', date: 'Dec', value: 2015.8 },
    { country: 'Facebook', date: 'Jan', value: 109.2 },
    { country: 'Facebook', date: 'Feb', value: 115.7 },
    { country: 'Facebook', date: 'Mar', value: 120.5 },
    { country: 'Facebook', date: 'Apr', value: 128 },
    { country: 'Facebook', date: 'May', value: 134.4 },
    { country: 'Facebook', date: 'Jun', value: 142.2 },
    { country: 'Facebook', date: 'Jul', value: 157.5 },
    { country: 'Facebook', date: 'Aug', value: 169.5 },
    { country: 'Facebook', date: 'Sept', value: 186.3 },
    { country: 'Facebook', date: 'Oct', value: 195.5 },
    { country: 'Facebook', date: 'Nov', value: 198 },
    { country: 'Facebook', date: 'Dec', value: 211.7 },
  ];

  const config = {
    data,
    xField: 'date',
    yField: 'value',
    seriesField: 'country',
    slider: {
      start: 0.1,
      end: 0.9,
    },
  };

  return <Area {...config} />;
};

const POPOVER_BUTTON_PROPS: ButtonProps = {
  type: 'text',
};

const cardStyles: CSSProperties = {
  height: '100%',
};

export const GeneralDashboardPage = () => {
  const stylesContext = useStylesContext();
  useFetchData('../mocks/TopProducts.json');

  return (
    <div>
      <Helmet>
        <title>General | Dashboard</title>
      </Helmet>
      <PageHeader
        title="general dashboard"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'general',
          },
        ]}
      />
      <Row {...stylesContext?.rowProps}>
        <Col sm={24} lg={16}>
          <Row {...stylesContext?.rowProps}>
            {/* RevenueCard cho số sự kiện người đó đã tổ chức */}
            <Col xs={24} sm={12}>
              <RevenueCard
                title="Organized Events"
                value={15} // Số sự kiện đã tổ chức của người dùng (điều chỉnh theo dữ liệu BE)
                diff={3.2} // Thay đổi % so với kỳ trước (nếu có)
                height={180}
                justify="space-between"
              />
            </Col>
            {/* RevenueCard cho số sự kiện người đó tham dự */}
            <Col xs={24} sm={12}>
              <RevenueCard
                title="Attended Events"
                value={8} // Số sự kiện người dùng tham dự
                diff={2.1}
                height={180}
                justify="space-between"
              />
            </Col>
            {/* RevenueCard cho số lượng speakers người đó đã tạo */}
            <Col xs={24} sm={12}>
              <RevenueCard
                title="Speakers Created"
                value={12} // Số lượng speakers do người dùng tạo ra
                diff={5.5}
                height={180}
                justify="space-between"
              />
            </Col>
            {/* RevenueCard cho số lượng guest người đó đã tạo */}
            <Col xs={24} sm={12}>
              <RevenueCard
                title="Guests Created"
                value={5} // Số lượng guest do người dùng tạo ra
                diff={1.7}
                height={180}
                justify="space-between"
              />
            </Col>
          </Row>
        </Col>
        <Col sm={24} lg={8}>
          <CustomerReviewsCard />
        </Col>
        <Col xs={24} lg={12}>
          <Card
            title="Total Revenue"
            extra={
              <Popover content="Total revenue over period x" title="Total revenue">
                <Button icon={<QuestionOutlined />} {...POPOVER_BUTTON_PROPS} />
              </Popover>
            }
            style={cardStyles}
          >
            <Flex vertical gap="middle">
              <Space>
                <Title level={3} style={{ margin: 0 }}>
                  $ <CountUp end={24485.67} />
                </Title>
                <Tag color="green-inverse" icon={<ArrowUpOutlined />}>
                  8.7%
                </Tag>
              </Space>
              <SalesChart />
            </Flex>
          </Card>
        </Col>
        <Col xs={24} lg={12}>
          <Card
            title="Categories"
            extra={
              <Popover content="Sales per categories" title="Categories sales">
                <Button icon={<QuestionOutlined />} {...POPOVER_BUTTON_PROPS} />
              </Popover>
            }
            style={cardStyles}
          >
            <CategoriesChart /> {/* Use the updated CategoriesChart component */}
          </Card>
        </Col>
      </Row>
    </div>
  );
};


src\pages\dashboards\index.ts:
export { ProjectsDashboardPage } from './Projects.tsx';
export { GeneralDashboardPage } from './General.tsx';
export {MyEventDashboardPage} from './MyEvents.tsx';
export {UserDashboardPage} from './Users.tsx';


src\pages\dashboards\MyEvents.tsx:
// src\pages\dashboards\MyEvents.tsx
import { Alert, Button, Col, Row, Space, Spin } from 'antd';
import {
    Card,
    Loader,
    PageHeader,
} from '../../components';
import { Events } from '../../types';
import { useState } from 'react';
import {
    CloudUploadOutlined,
    HomeOutlined,
    PieChartOutlined,
    PlusOutlined,
} from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link, useNavigate } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import useFetchOrganizedEventsData from '../../hooks/useFetchOrganizedEventsData';
import { EventsCard } from '../../components/dashboard/shared';
import { MyEventsTable } from '../../components/dashboard/events/MyEventTable'; // Corrected import here (Named import)

const EVENT_TABS = [
    {
        key: 'all',
        label: 'All events',
    },
    {
        key: 'SCHEDULED',
        label: 'Scheduled',
    },
    {
        key: 'CANCELED',
        label: 'Canceled',
    },
    {
        key: 'FINISHED',
        label: 'Finished',
    },
];

export const MyEventDashboardPage = () => {

    const { data: eventsData, error: eventsError, loading: eventsLoading, fetchData } = useFetchOrganizedEventsData();
    const [eventTabKey, setEventTabKey] = useState<string>('all');
    const navigate = useNavigate();

    const getFilteredEvents = (status?: string) => {
        return (eventsData || []).filter((event: Events) => status ? event.status === status : true);
    };

    const EVENT_TABS_CONTENT: Record<string, React.ReactNode> = {
        all: <MyEventsTable key="all-events-table" data={getFilteredEvents()} loading={eventsLoading} fetchData={fetchData} activeTabKey={eventTabKey} />,
        SCHEDULED: (
            <MyEventsTable
                key="scheduled-events-table"
                data={getFilteredEvents('SCHEDULED')}
                loading={eventsLoading}
                fetchData={() => fetchData('SCHEDULED')}
                activeTabKey={eventTabKey}
            />
        ),
        CANCELED: (
            <MyEventsTable
                key="canceled-events-table"
                data={getFilteredEvents('CANCELED')}
                loading={eventsLoading}
                fetchData={() => fetchData('CANCELED')}
                activeTabKey={eventTabKey}
            />
        ),
        FINISHED: (
            <MyEventsTable
                key="finished-events-table"
                data={getFilteredEvents('FINISHED')}
                loading={eventsLoading}
                fetchData={() => fetchData('FINISHED')}
                activeTabKey={eventTabKey}
            />
        ),
    };


    const onEventTabChange = (key: string) => {
        setEventTabKey(key);
        fetchData(key === 'all' ? undefined : key);
    };


    return (
        <div>
            <Helmet>
                <title>My Events | Antd Dashboard</title>
            </Helmet>
            <PageHeader
                title="your event dashboard"
                breadcrumbs={[
                    {
                        title: (
                            <>
                                <HomeOutlined />
                                <span>home</span>
                            </>
                        ),
                        path: '/',
                    },
                    {
                        title: (
                            <>
                                <PieChartOutlined />
                                <span>dashboards</span>
                            </>
                        ),
                        menu: {
                            items: DASHBOARD_ITEMS.map((d) => ({
                                key: d.title,
                                title: <Link to={d.path}>{d.title}</Link>,
                            })),
                        },
                    },
                    {
                        title: 'my events',
                    },
                ]}
            />
            <Row
                gutter={[
                    { xs: 8, sm: 16, md: 24, lg: 32 },
                    { xs: 8, sm: 16, md: 24, lg: 32 },
                ]}
            >
                <Col span={24}>
                    <Card
                        title="Recently added events"
                    >
                        {eventsError && (
                            <Alert
                                message="No events participated yet."
                                type="info"
                                showIcon
                            />
                        )}
                        {eventsLoading ? (
                            <Loader />
                        ) : (
                            <Row gutter={[16, 16]}>
                                {getFilteredEvents().slice(0, 4).map((o: Events) => {
                                    return (
                                        <Col xs={24} sm={12} xl={6} key={o.id}>
                                            <EventsCard
                                                event={o}
                                                type="inner"
                                                style={{ height: '100%' }}
                                            />
                                        </Col>
                                    );
                                })}
                            </Row>
                        )}
                    </Card>
                </Col>
                <Col span={24}>
                    <Card
                        title="Your Events"
                        extra={
                            <Space>
                                <Button onClick={() => navigate("/create/events")} icon={<PlusOutlined />}>New Event</Button>
                            </Space>
                        }
                        tabList={EVENT_TABS}
                        activeTabKey={eventTabKey}
                        onTabChange={onEventTabChange}
                    >
                        {eventsLoading ? <Loader /> : EVENT_TABS_CONTENT[eventTabKey]}
                    </Card>
                </Col>
            </Row>
        </div>
    );
};

export default MyEventDashboardPage


src\pages\dashboards\ParticipatedEvents.tsx:
// src/pages/dashboards/ParticipatedEventsPage.tsx
import React, { useState, useEffect } from 'react';
import {
  Alert,
  Button,
  Card,
  Space,
  Table,
  Tag,
  Select,
  message,
  Popconfirm,
  Spin,
} from 'antd';
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { PageHeader } from '../../components';
import { ColumnsType } from 'antd/es/table';
import { Events } from '../../types';
import dayjs from 'dayjs';
import useFetchParticipatedEventsData from '../../hooks/useFetchParticipatedEventsData';
import authService from '../../services/authService';
import { DASHBOARD_ITEMS } from '../../constants';

const EVENT_STATUS_OPTIONS = [
  { value: 'all', label: 'All Statuses' },
  { value: 'SCHEDULED', label: 'Scheduled' },
  { value: 'CANCELED', label: 'Canceled' },
  { value: 'FINISHED', label: 'Finished' },
];

const ParticipatedEventsPage = () => {
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const { data: eventsData, error: eventsError, loading: eventsLoading, fetchData } =
    useFetchParticipatedEventsData(statusFilter === 'all' ? undefined : statusFilter);
  // loading dành cho thao tác update/delete
  const [actionLoading, setActionLoading] = useState(false);

  // --- State để lưu mapping từ categoryId -> categoryName ---
  const [categories, setCategories] = useState<Record<string, string>>({});
  const [loadingCategories, setLoadingCategories] = useState(false);

  const onStatusFilterChange = (value: string) => {
    setStatusFilter(value);
    setCurrentPage(1);
  };

  const handlePaginationChange = (page: number, pageSize: number) => {
    setCurrentPage(page);
    setPageSize(pageSize);
  };

  const isEmptyData = eventsData?.events === undefined || eventsData?.events?.length === 0;

  // Khi eventsData thay đổi, duyệt qua các event và nếu chưa có category name thì fetch từ API
  useEffect(() => {
    const fetchCategoryName = async (event: Events) => {
      if (!event?.categoryId) return;
      // Nếu đã có category name trong mapping thì bỏ qua
      if (categories[event.categoryId]) return;
      setLoadingCategories(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getCategoryById(event.categoryId, accessToken || '');
        // Giả sử response trả về dạng: { data: { category: { name: string } } }
        const categoryResponse = response as { data: { category: { name: string } } };
        setCategories((prev) => ({
          ...prev,
          [event.categoryId]: categoryResponse.data.category.name,
        }));
      } catch (error: any) {
        console.error('Error fetching category name for event', event.id, error);
        message.error('Failed to load category name');
        setCategories((prev) => ({
          ...prev,
          [event.categoryId]: 'N/A',
        }));
      } finally {
        setLoadingCategories(false);
      }
    };

    if (eventsData && eventsData.events) {
      eventsData.events.forEach((event: Events) => {
        fetchCategoryName(event);
      });
    }
  }, [eventsData, categories]);

  // Hàm xử lý Unregister (delete) event
  const handleLeaveEvent = async (eventId: string) => {
    setActionLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error('No access token found. Please login again.');
        return;
      }

      // 1. Get Participant ID
      const participantIdResponse = await authService.getParticipantIdByEventId(eventId, accessToken) as any;
      const participantId = participantIdResponse.data.participantId;

      // 2. Unregister Event using participantId
      const response = (await authService.unregisterEvent(
        participantId,
        accessToken
      )) as { statusCode: number; message: string; error?: string };

      if (response.statusCode === 200) {
        message.success(response.message);
        // Refresh dữ liệu sau khi delete
        fetchData(statusFilter === 'all' ? undefined : statusFilter);
      } else {
        message.error(response.error || 'Failed to unregister from event');
      }
    } catch (error: any) {
      console.error('Error unregistering from event:', error);
      message.error(error.error || 'Failed to unregister from event');
    } finally {
      setActionLoading(false);
    }
  };

  // Định nghĩa các cột của bảng bên trong component để có thể sử dụng các biến state
  const columns: ColumnsType<Events> = [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
      render: (text, record) => (
        <Link to={`/details/participated-events/${record.id}`}>{text}</Link>
      ),
    },
    {
      title: 'Location',
      dataIndex: 'location',
      key: 'location',
    },
    {
      title: 'Start Date',
      dataIndex: 'startDate',
      key: 'startDate',
      render: (date) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'End Date',
      dataIndex: 'endDate',
      key: 'endDate',
      render: (date) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'Category',
      dataIndex: 'categoryId',
      key: 'categoryId',
      render: (categoryId: string) => (
        <Space>
          {loadingCategories ? (
            <Spin size="small" />
          ) : (
            <Tag color="blue">{categories[categoryId] || 'N/A'}</Tag>
          )}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status) => (
        <Tag color={status === 'SCHEDULED' ? 'blue' : status === 'CANCELED' ? 'red' : 'green'}>
          {status}
        </Tag>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record) => (
        <Space size="middle">
          <Button type="primary" size="small">
            <Link to={`/details/participated-events/${record.id}`}>Details</Link>
          </Button>
          <Popconfirm
            title="Cancel Event"
            description="Are you sure to unregister from this event?"
            onConfirm={() => handleLeaveEvent(record.id)}
            onCancel={() => message.info('Cancel')}
            okText="Yes, Cancel"
            cancelText="No"
            placement="topRight"
            overlayInnerStyle={{ width: 200 }}
          >
            <Button danger>Unregister</Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <div>
      <Helmet>
        <title>Participated Events | Antd Dashboard</title>
      </Helmet>
      <PageHeader
        title="Participated Events"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Participated Events',
          },
        ]}
      />

      <Card
        title="List of Participated Events"
        extra={
          <Select
            defaultValue="all"
            style={{ width: 200 }}
            onChange={onStatusFilterChange}
            options={EVENT_STATUS_OPTIONS}
          />
        }
      >
        {isEmptyData ? (
          <Alert message="No events participated yet." type="info" showIcon />
        ) : (
          <Table
            columns={columns}
            dataSource={eventsData?.events || []}
            loading={eventsLoading || actionLoading}
            pagination={{
              current: currentPage,
              pageSize: pageSize,
              total: eventsData?.meta?.totalItems || 0,
              showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} items`,
              pageSizeOptions: ['10', '20', '50', '100'],
              showSizeChanger: true,
              onChange: handlePaginationChange,
            }}
          />
        )}
      </Card>
    </div>
  );
};

export default ParticipatedEventsPage;


src\pages\dashboards\ParticipationStats.tsx:
// src\pages\dashboards\ParticipationStats.tsx
import React, { useState, useEffect } from 'react';
import { Card, Spin, Alert, Table } from 'antd';
import { PageHeader } from '../../components';
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import axiosInstance from '../../api/axiosInstance';

interface TimelineData {
  timeSlot: string;
  checkInCount: number;
  checkOutCount: number;
}

interface ParticipationData {
    eventId: string;
    registeredCount: number;
    checkInCount: number;
    checkOutCount: number;
}

const columns = [
  {
    title: 'Event ID',
    dataIndex: 'eventId',
    key: 'eventId',
  },
  {
    title: 'Registered Count',
    dataIndex: 'registeredCount',
    key: 'registeredCount',
  },
  {
    title: 'Check-in Count',
    dataIndex: 'checkInCount',
    key: 'checkInCount',
  },
  {
    title: 'Check-out Count',
    dataIndex: 'checkOutCount',
    key: 'checkOutCount',
  },
];

export const ParticipationStatsPage: React.FC = () => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [statsData, setStatsData] = useState<ParticipationData | null>(null);

  useEffect(() => {
    const fetchParticipationStats = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await axiosInstance.get<any>(`/reports/participation-stats`); // call api here
        setStatsData(response.data.data);
      } catch (e: any) {
        setError(e.message);
        setStatsData(null);
      } finally {
        setLoading(false);
      }
    };

    fetchParticipationStats();
  }, []);

  return (
    <div>
      <Helmet>
        <title>Participation Stats | Antd Dashboard</title>
      </Helmet>
      <PageHeader
        title="Participation Statistics"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Participation Stats',
          },
        ]}
      />
      <Card>
        {error && (
          <Alert
            message="Error"
            description={error}
            type="error"
            showIcon
            style={{ marginBottom: 16 }}
          />
        )}
        {loading ? (
          <Spin tip="Loading timeline report..." />
        ) : (
          <Table
            dataSource={statsData ? [statsData] : []}
            columns={columns}
            pagination={false}
            rowKey="eventId"
          />
        )}
      </Card>
    </div>
  );
};

src\pages\dashboards\Projects.tsx:
// src\pages\dashboards\Projects.tsx
import { Alert, Button, Col, Row, Segmented, Space, Typography } from 'antd';
import {
  Card,
  ClientsTable,
  Loader,
  PageHeader,
  ProjectsCard,
  ProjectsTable,
  RevenueCard,
} from '../../components';
import { Column } from '@ant-design/charts';
import { Events, Projects, User } from '../../types';
import { useState } from 'react';
import {
  CloudUploadOutlined,
  HomeOutlined,
  PieChartOutlined,
  PlusOutlined,
} from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { useFetchData } from '../../hooks';
import { EventsCard } from '../../components/dashboard/shared';
import useFetchOrganizedEventsData from '../../hooks/useFetchOrganizedEventsData';
import useFetchTopClients from '../../hooks/useFetchTopClients'; // Import useFetchTopClients

const RevenueColumnChart = () => {
  const data = [
    {
      name: 'Income',
      period: 'Mon',
      value: 18.9,
    },
    {
      name: 'Income',
      period: 'Tue',
      value: 28.8,
    },
    {
      name: 'Income',
      period: 'Wed',
      value: 39.3,
    },
    {
      name: 'Income',
      period: 'Thur',
      value: 81.4,
    },
    {
      name: 'Income',
      period: 'Fri',
      value: 47,
    },
    {
      name: 'Income',
      period: 'Sat',
      value: 20.3,
    },
    {
      name: 'Income',
      period: 'Sun',
      value: 24,
    },
    {
      name: 'Spent',
      period: 'Mon',
      value: 12.4,
    },
    {
      name: 'Spent',
      period: 'Tue',
      value: 23.2,
    },
    {
      name: 'Spent',
      period: 'Wed',
      value: 34.5,
    },
    {
      name: 'Spent',
      period: 'Thur',
      value: 99.7,
    },
    {
      name: 'Spent',
      period: 'Fri',
      value: 52.6,
    },
    {
      name: 'Spent',
      period: 'Sat',
      value: 35.5,
    },
    {
      name: 'Spent',
      period: 'Sun',
      value: 37.4,
    },
  ];
  const config = {
    data,
    isGroup: true,
    xField: 'period',
    yField: 'value',
    seriesField: 'name',

    /** set color */
    // color: ['#1ca9e6', '#f88c24'],

    /** Set spacing */
    // marginRatio: 0.1,
    label: {
      // Label data label position can be manually configured
      position: 'middle',
      // 'top', 'middle', 'bottom'
      // Configurable additional layout method
      layout: [
        // Column chart data label position automatically adjusted
        {
          type: 'interval-adjust-position',
        }, // Data label anti-obstruction
        {
          type: 'interval-hide-overlap',
        }, // Data label text color automatically adjusted
        {
          type: 'adjust-color',
        },
      ],
    },
  };
  // @ts-ignore
  return <Column {...config} />;
};

const PROJECT_TABS = [
  {
    key: 'all',
    label: 'All projects',
  },
  {
    key: 'inProgress',
    label: 'Active',
  },
  {
    key: 'onHold',
    label: 'On Hold',
  },
];

export const ProjectsDashboardPage = () => {
  const {
    data: projectsData,
    error: projectsDataError,
    loading: projectsDataLoading,
  } = useFetchData('../mocks/Projects.json');
  const {
    data: clientsData, // rename to topClientsData to avoid confusion
    error: topClientsError, // rename to topClientsError
    loading: topClientsLoading, // rename to topClientsLoading
  } = useFetchTopClients(5); // use useFetchTopClients hook to fetch top clients
  const [projectTabsKey, setProjectsTabKey] = useState<string>('all');
  const { data: eventsData, error: eventsError, loading: eventsLoading, fetchData } = useFetchOrganizedEventsData();
  const getFilteredEvents = (status?: string) => {
    return (eventsData || []).filter((event: Events) => status ? event.status === status : true);
  };

  const PROJECT_TABS_CONTENT: Record<string, React.ReactNode> = {
    all: <ProjectsTable key="all-projects-table" data={projectsData} />,
    inProgress: (
      <ProjectsTable
        key="in-progress-projects-table"
        data={projectsData.filter((_: Projects) => _.status === 'in progress')}
      />
    ),
    onHold: (
      <ProjectsTable
        key="on-hold-projects-table"
        data={projectsData.filter((_: Projects) => _.status === 'on hold')}
      />
    ),
  };

  const onProjectsTabChange = (key: string) => {
    setProjectsTabKey(key);
  };

  return (
    <div>
      <Helmet>
        <title>Projects | Dashboard</title>
      </Helmet>
      <PageHeader
        title="projects dashboard"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'projects',
          },
        ]}
      />
      <Row
        gutter={[
          { xs: 8, sm: 16, md: 24, lg: 32 },
          { xs: 8, sm: 16, md: 24, lg: 32 },
        ]}
      >
        <Col xs={24} sm={12} lg={6}>
          <RevenueCard title="Total revenue" value={1556.3} diff={280} />
        </Col>
        <Col xs={24} sm={12} lg={6}>
          <RevenueCard title="Spent this week" value={1806.3} diff={180} />
        </Col>
        <Col xs={24} sm={12} lg={6}>
          <RevenueCard title="Worked this week" value="35:12" diff={-10.0} />
        </Col>
        <Col xs={24} sm={12} lg={6}>
          <RevenueCard title="Worked today" value="05:30:00" diff={-20.1} />
        </Col>
        <Col span={24}>
          <Card
            title="Recently added events"
          >
            {eventsError && (
              <Alert
                message="No events participated yet."
                type="info"
                showIcon
              />
            )}
            {eventsLoading ? (
              <Loader />
            ) : (
              <Row gutter={[16, 16]}>
                {getFilteredEvents().slice(0, 4).map((o: Events) => {
                  return (
                    <Col xs={24} sm={12} xl={6} key={o.id}>
                      <EventsCard
                        event={o}
                        type="inner"
                        style={{ height: '100%' }}
                      />
                    </Col>
                  );
                })}
              </Row>
            )}
          </Card>
        </Col>
        <Col xs={24} sm={12} xl={16}>
          <Card
            title="Project stats"
            extra={
              <Segmented
                options={['Daily', 'Monthly', 'Yearly']}
              />
            }
          >
            <RevenueColumnChart />
          </Card>
        </Col>
        <Col xs={24} sm={12} xl={8}>
          <Card title="Top clients">
            {topClientsError ? ( // use topClientsError
              <Alert
                message="Error"
                description={topClientsError.toString()} // use topClientsError
                type="error"
                showIcon
              />
            ) : topClientsLoading ? ( // use topClientsLoading
              <Loader />
            ) : (
              <ClientsTable data={clientsData} /> // use clientsData (fetched from useFetchTopClients)
            )}
          </Card>
        </Col>
      </Row>
    </div>
  );
};


src\pages\dashboards\SpeakerManagementPage.tsx:
// src\pages\dashboards\SpeakerGuestManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Button,
    Card,
    message,
    Popconfirm,
    Space,
    Table,
    Modal,
    Form,
    Input,
    Typography,
    Alert,
    Tabs,
} from 'antd';
import {
    HomeOutlined,
    PieChartOutlined,
    EditOutlined,
    PlusOutlined,
    SaveOutlined,
    DeleteOutlined,
    CloseOutlined
} from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { PageHeader, Loader } from '../../components';
import { ColumnsType } from 'antd/es/table';
import { Speaker, Guest, SpeakerGuestData } from '../../types';
import axiosInstance from '../../api/axiosInstance';


const SpeakerGuestManagementPage: React.FC = () => {
    const [speakers, setSpeakers] = useState<Speaker[]>([]);
    const [guests, setGuests] = useState<Guest[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [form] = Form.useForm();
    const [editingItemId, setEditingItemId] = useState<string | null>(null);
    const [activeTabKey, setActiveTabKey] = useState<'speakers' | 'guests'>('speakers');
    const [noSpeakersData, setNoSpeakersData] = useState<boolean>(false);
    const [noGuestsData, setNoGuestsData] = useState<boolean>(false);


    const fetchSpeakers = useCallback(async () => {
        setLoading(true);
        setError(null);
        setNoSpeakersData(false);
        try {
            const response = await axiosInstance.get('/speakers');
            const speakerData = (response.data as { data: { speakers: Speaker[], meta: { totalItems: number } } }).data;
            setSpeakers(speakerData.speakers);
            if (speakerData.meta.totalItems === 0) {
                setNoSpeakersData(true);
            }
        } catch (error: any) {
            setError(error.message || 'Failed to load speakers');
            message.error(error.message || 'Failed to load speakers');
        } finally {
            setLoading(false);
        }
    }, []);

    const fetchGuests = useCallback(async () => {
        setLoading(true);
        setError(null);
        setNoGuestsData(false);
        try {
            const response = await axiosInstance.get('/guests');
            const guestData = (response.data as { data: { guests: Guest[], meta: { totalItems: number } } }).data;
            setGuests(guestData.guests);
            if (guestData.meta.totalItems === 0) {
                setNoGuestsData(true);
            }
        } catch (error: any) {
            setError(error.message || 'Failed to load guests');
            message.error(error.message || 'Failed to load guests');
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchSpeakers();
        fetchGuests();
    }, [fetchSpeakers, fetchGuests]);

    const handleCreateItem = () => {
        setEditingItemId(null);
        form.resetFields();
        setIsModalOpen(true);
    };

    const handleEditItem = (id: string, entityType: 'speaker' | 'guest') => {
        setEditingItemId(id);
        const itemToEdit = entityType === 'speaker'
            ? speakers.find(speaker => speaker.id === id)
            : guests.find(guest => guest.id === id);

        if (itemToEdit) {
            form.setFieldsValue({ ...itemToEdit, entityType, ...itemToEdit }); // ** giữ lại itemToEdit để set giá trị đúng **
            setIsModalOpen(true);
        }
    };


    const handleModalOk = () => {
        form.submit();
    };

    const handleModalCancel = () => {
        setIsModalOpen(false);
    };

    const onTabChange = (key: string) => {
        setActiveTabKey(key as 'speakers' | 'guests');
    };


    const onFinish = async (values: any) => {
        setLoading(true);
        setError(null);
        try {
            let response;
            const isSpeaker = values.entityType === 'speaker';
            const endpoint = isSpeaker ? '/speakers' : '/guests';
            const idToEdit = editingItemId;

            const payload = { // ** Tạo payload theo đúng format backend yêu cầu **
                name: values.name,
                jobTitle: values.jobTitle,
                email: values.email,
                ...(isSpeaker ? { bio: values.bio } : { organization: values.organization, linkSocial: values.linkSocial }) // ** Conditional payload cho speaker và guest **
            };


            if (idToEdit) {
                response = await axiosInstance.patch(`${endpoint}/${idToEdit}`, payload); // ** Gửi payload đã format **
                message.success(`${isSpeaker ? 'Speaker' : 'Guest'} updated successfully`);
            } else {
                response = await axiosInstance.post(endpoint, payload); // ** Gửi payload đã format **
                message.success(`${isSpeaker ? 'Speaker' : 'Guest'} created successfully`);
            }

            if (isSpeaker) {
                fetchSpeakers();
            } else {
                fetchGuests();
            }
            setIsModalOpen(false);
            form.resetFields();
        } catch (error: any) {
            setError(error.message || `Failed to save ${values.entityType}`);
            message.error(error.message || `Failed to save  ${values.entityType}`);
        } finally {
            setLoading(false);
        }
    };

    const onFinishFailed = (errorInfo: any) => {
        console.log('Failed:', errorInfo);
    };


    const speakerColumns: ColumnsType<SpeakerGuestData> = [
        {
            title: 'Name',
            dataIndex: 'name',
            key: 'name',
        },
        {
            title: 'Job Title',
            dataIndex: 'jobTitle',
            key: 'jobTitle',
        },
        {
            title: 'Email',
            dataIndex: 'email',
            key: 'email',
        },
        {
            title: 'Actions',
            key: 'actions',
            render: (_, record) => (
                <Space size="middle">
                    <Button icon={<EditOutlined />} size="small" onClick={() => handleEditItem(record.id!, 'speaker')}>
                        Edit
                    </Button>
                </Space>
            ),
        },
    ];

    const guestColumns: ColumnsType<SpeakerGuestData> = [
        {
            title: 'Name',
            dataIndex: 'name',
            key: 'name',
        },
        {
            title: 'Job Title',
            dataIndex: 'jobTitle',
            key: 'jobTitle',
        },
        {
            title: 'Organization',
            dataIndex: 'organization',
            key: 'organization',
        },
        {
            title: 'Email',
            dataIndex: 'email',
            key: 'email',
        },
        {
            title: 'Actions',
            key: 'actions',
            render: (_, record) => (
                <Space size="middle">
                    <Button icon={<EditOutlined />} size="small" onClick={() => handleEditItem(record.id!, 'guest')}>
                        Edit
                    </Button>
                </Space>
            ),
        },
    ];


    return (
        <div>
            <Helmet>
                <title>Speaker & Guest Management | Antd Dashboard</title>
            </Helmet>
            <PageHeader
                title="Speaker & Guest Management"
                breadcrumbs={[
                    {
                        title: (
                            <>
                                <HomeOutlined />
                                <span>Home</span>
                            </>
                        ),
                        path: '/',
                    },
                    {
                        title: (
                            <>
                                <PieChartOutlined />
                                <span>Dashboards</span>
                            </>
                        ),
                        menu: {
                            items: DASHBOARD_ITEMS.map((d) => ({
                                key: d.title,
                                title: <Link to={d.path}>{d.title}</Link>,
                            })),
                        },
                    },
                    {
                        title: 'Speaker & Guest Management',
                    },
                ]}
            />

            <Card
                title="Speaker & Guest List"
                extra={
                    <Button icon={<PlusOutlined />} type="primary" onClick={handleCreateItem}>
                        Create
                    </Button>
                }
                tabList={[ // Tabs for Speakers and Guests
                    { key: 'speakers', tab: 'Speakers' },
                    { key: 'guests', tab: 'Guests' },
                ]}
                activeTabKey={activeTabKey}
                onTabChange={onTabChange}
            >
                {error && (
                    <Alert
                        message="Error"
                        description={error}
                        type="error"
                        showIcon
                        closable
                        onClose={() => setError(null)}
                        style={{ marginBottom: 16 }}
                    />
                )}
                {activeTabKey === 'speakers' && noSpeakersData && !loading ? (
                    <Alert message="No speakers available." type="info" showIcon />
                ) : activeTabKey === 'guests' && noGuestsData && !loading ? (
                    <Alert message="No guests available." type="info" showIcon />
                ) : (
                    <Table
                        columns={activeTabKey === 'speakers' ? speakerColumns : guestColumns}
                        dataSource={activeTabKey === 'speakers'
                            ? speakers.map(speaker => ({ ...speaker, entityType: 'speaker' }))
                            : guests.map(guest => ({ ...guest, entityType: 'guest' }))}
                        loading={loading}
                        rowKey="id"
                        pagination={{ pageSize: 5 }}
                    />
                )}
            </Card>

            <Modal
                title={editingItemId ? `Edit ${form.getFieldValue('entityType') === 'speaker' ? 'Speaker' : 'Guest'}` : "Create New Speaker/Guest"}
                open={isModalOpen}
                onOk={handleModalOk}
                onCancel={handleModalCancel}
                confirmLoading={loading}
                destroyOnClose
            >
                <Form
                    form={form}
                    layout="vertical"
                    name="speaker-guest-form"
                    onFinish={onFinish}
                    onFinishFailed={onFinishFailed}
                    autoComplete="off"
                    initialValues={{ entityType: 'speaker' }}
                    requiredMark={false}
                >
                    <Form.Item name="entityType" hidden>
                        <Input />
                    </Form.Item>
                    <Form.Item
                        label="Name"
                        name="name"
                        rules={[{ required: true, message: 'Please input name!' }]}
                    >
                        <Input placeholder="Name" />
                    </Form.Item>
                    <Form.Item
                        label="Job Title"
                        name="jobTitle"
                        rules={[{ required: true, message: 'Please input job title!' }]}
                    >
                        <Input placeholder="Job Title" />
                    </Form.Item>
                    <Form.Item
                        label="Email"
                        name="email"
                        rules={[
                            { required: true, message: 'Please input Email!' },
                            { type: 'email', message: 'Please enter a valid email!' },
                        ]}
                    >
                        <Input placeholder="Email" />
                    </Form.Item>
                    {form.getFieldValue('entityType') === 'guest' && (
                        <Form.Item
                            label="Organization"
                            name="organization"
                            rules={[{ required: true, message: 'Please input organization!' }]}
                        >
                            <Input placeholder="Organization" />
                        </Form.Item>
                    )}
                    {form.getFieldValue('entityType') === 'guest' && (
                        <Form.Item
                            label="Social Link"
                            name="linkSocial"
                        >
                            <Input placeholder="Social Link" />
                        </Form.Item>
                    )}
                    {form.getFieldValue('entityType') === 'speaker' && (
                        <Form.Item
                            label="Bio"
                            name="bio"
                        >
                            <Input.TextArea rows={4} placeholder="Bio" />
                        </Form.Item>
                    )}
                </Form>
            </Modal>
        </div>
    );
};

export default SpeakerGuestManagementPage;

src\pages\dashboards\Users.tsx:
import { HomeOutlined, PieChartOutlined } from '@ant-design/icons';
import { useStylesContext } from '../../context';
import { Helmet } from 'react-helmet-async';
import { DASHBOARD_ITEMS } from '../../constants';
import { Link } from 'react-router-dom';
import {
    Col,
    Row,
} from 'antd';
  import {
    PageHeader,
} from '../../components';
import {
  UserTable
} from '../../components/dashboard';
import { useFetchData } from '../../hooks';

export const UserDashboardPage = () => {
    const stylesContext = useStylesContext();
    const {
        data: users,
        error: usersError,
        loading: usersLoading,
      } = useFetchData('../mocks/MyUsers.json');
  return (
    <div>
      <Helmet>
        <title>Incomming Events | Antd Dashboard</title>
      </Helmet>
      <PageHeader
        title="incomming events dashboard"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'users',
          },
        ]}
      />
      <Row {...stylesContext?.rowProps}>
      <Col span={24}>
          <UserTable data={users} loading={usersLoading} error={usersError} />
        </Col>
      </Row>
    </div>
  )
}

src\pages\details\EventDetailsPage.tsx:
// src\pages\details\EventDetailsPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate, Link, useOutletContext, useSearchParams } from 'react-router-dom';
import {
  Alert,
  Button,
  Card,
  Col,
  Flex,
  Image,
  List,
  message,
  Rate,
  Row,
  Spin,
  Table,
  Typography,
  Checkbox,
} from 'antd';
import { HomeOutlined, PieChartOutlined, UserAddOutlined, DownloadOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { PageHeader, Loader, BackBtn } from '../../components';
import dayjs from 'dayjs';
import authService from '../../services/authService';
import { Events } from '../../types';
import { EventParticipantsTable } from '../dashboards/EventParticipantsTable';
import { Helmet } from 'react-helmet-async';
import EventDiscussion from '../../components/EventDiscussion';

const { Title, Text } = Typography;

export const EventDetailsPage: React.FC = () => {
  // Lấy eventId từ outlet context (hoặc từ useParams nếu cần)
  const { id } = useParams<{ id: string }>();
  const { eventId } = useOutletContext<{ eventId: string }>();
  // Lấy token từ query string (nếu có)
  const [searchParams] = useSearchParams();

  const [eventDetails, setEventDetails] = useState<Events | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const [selectedSessionIds, setSelectedSessionIds] = useState<string[]>([]);
  const [questions, setQuestions] = useState<any[]>([]);
  const [feedbackSummary, setFeedbackSummary] = useState<{
    averageRating: number;
    totalFeedbacks: number;
    ratingDistribution: Record<string, number>;
  } | null>(null);
  const [feedbackSummaryLoading, setFeedbackSummaryLoading] = useState(false);

  // State để đảm bảo API accept được gọi 1 lần duy nhất
  const [hasAccepted, setHasAccepted] = useState(false);

  // Fetch chi tiết sự kiện (sử dụng eventId từ outlet context)
  useEffect(() => {
    console.log("EventDetailsPage useEffect is running, eventId:", eventId); 
    const fetchEventDetails = async () => {
      setLoading(true);
      setError(null);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventDetails(eventId, accessToken || undefined) as { statusCode: number; data: { event: Events }; message: string; error?: string };
        if (response && response.statusCode === 200) {
          setEventDetails(response.data.event);
        } else {
          setError(response?.message || 'Failed to load event details');
          message.error(response?.error);
        }
      } catch (error: any) {
        console.error('Error fetching event details:', error);
        setError(error.message || 'Failed to load event details');
        message.error(error.error);
      } finally {
        setLoading(false);
      }
    };

    const fetchEventFeedbackSummary = async () => {
      if (!eventId) return;
      setFeedbackSummaryLoading(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventFeedbackSummary(eventId, accessToken || undefined) as any;
        if (response.statusCode === 200 && response.data) {
          setFeedbackSummary(response.data.data);
        } else {
          console.error('Failed to fetch feedback summary:', response.message);
        }
      } catch (error: any) {
        console.error('Error fetching feedback summary:', error);
      } finally {
        setFeedbackSummaryLoading(false);
      }
    };

    fetchEventDetails();
    fetchEventFeedbackSummary();
  }, [eventId, navigate]);

  // Nếu URL có token, gọi API accept (chỉ gọi 1 lần)
  useEffect(() => {
    const token = searchParams.get('token');
    if (token && eventDetails && !hasAccepted) {
      const acceptEvent = async () => {
        try {
          const response = await authService.acceptEvent(eventDetails.id, token) as { statusCode: number; message: string; error?: string };
          if (response && response.statusCode === 200) {
            message.success(response.message || 'Bạn đã xác nhận tham gia sự kiện thành công.');
            setHasAccepted(true);
          } else {
            message.error(response.error || 'Xác nhận tham gia thất bại.');
          }
        } catch (error: any) {
          console.error('Error accepting event:', error);
          message.error(error.message || 'Có lỗi xảy ra khi xác nhận tham gia.');
        }
      };
      acceptEvent();
    }
  }, [searchParams, eventDetails, hasAccepted]);

  const handleRegisterEvent = async () => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        navigate('/auth/signin');
        return;
      }

      if (!eventDetails?.id) {
        message.error("Event ID is missing.");
        return;
      }

      const response = await authService.registerEvent(eventDetails.id, selectedSessionIds, accessToken) as { statusCode: number; message: string; error?: string };
      if (response && response.statusCode === 201) {
        message.success(response.message);
      } else {
        message.error(response?.error || 'Failed to register for event');
      }
    } catch (error: any) {
      message.error(error.error || 'Failed to register for event');
    } finally {
      setLoading(false);
    }
  };

  const handleDownloadPdf = async () => { /* ... Giữ nguyên hàm handleDownloadPdf ... */ };

  const onSessionSelectChange = (selectedKeys: React.Key[]) => {
    setSelectedSessionIds(selectedKeys as string[]);
  };

  const scheduleColumns = [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title'
    },
    {
      title: 'Start Time',
      dataIndex: 'startTime',
      key: 'startTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'End Time',
      dataIndex: 'endTime',
      key: 'endTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description'
    },
  ];

  if (loading) {
    return <Loader />;
  }

  if (error) {
    return <Alert message="Error" description={error} type="error" showIcon />;
  }

  if (!eventDetails) {
    return <Alert message="Event not found" description="Could not load event details" type="warning" showIcon />;
  }

  return (
    <div>
      <Helmet>
        <title>{eventDetails.name} | Event Details</title>
      </Helmet>
      <PageHeader
        title="Event Details"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Event Details',
          },
        ]}
        btnBack={<BackBtn />}
      />
      <BackBtn />

      <Card
        title={<Typography.Title level={3}>{eventDetails.name}</Typography.Title>}
        extra={<Button type="primary" icon={<UserAddOutlined />} onClick={handleRegisterEvent} loading={loading}>Register Event</Button>}
      >
        <Row gutter={[16, 16]}>
          <Col span={24}>
            {eventDetails.videoIntro ? (
              <Card title="Video Introduction">
                <iframe
                  width="100%"
                  height="480"
                  src={eventDetails.videoIntro}
                  title="Event Introduction Video"
                  frameBorder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowFullScreen
                />
              </Card>
            ) : eventDetails.banner ? (
              <Card title="Event Banner">
                <img
                  src={eventDetails.banner}
                  alt="Event Banner"
                  style={{ width: "100%", height: "480px", objectFit: "cover" }}
                />
              </Card>
            ) : (
              <Card title="Event Introduction">
                <iframe
                  width="100%"
                  height="480"
                  src="https://www.youtube.com/embed/iTJJC2Hlmu0"
                  title="Event Introduction Video"
                  frameBorder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowFullScreen
                />
              </Card>
            )}
          </Col>
          <Col span={24}>
            <Card title="Schedule">
              {eventDetails.schedule && eventDetails.schedule.length > 0 ? (
                <Table
                  rowKey="id"
                  dataSource={eventDetails.schedule}
                  columns={scheduleColumns}
                  pagination={false}
                  rowSelection={{
                    columnWidth: 80,
                    onChange: onSessionSelectChange,
                  }}
                />
              ) : (
                <Alert message="No schedule available for this event." type="info" showIcon />
              )}
            </Card>
          </Col>
          {eventDetails.documents && eventDetails.documents.length > 0 && (
            <Col span={24}>
              <Card title="Event Documents">
                <List
                  dataSource={eventDetails.documents}
                  renderItem={item => (
                    <List.Item>
                      <Typography.Link href={item} target="_blank">
                        {item}
                      </Typography.Link>
                    </List.Item>
                  )}
                />
              </Card>
            </Col>
          )}
          {eventDetails?.status === 'FINISHED' && (
            <Col span={24} >
              <Card title="Feedback Summary">
                {feedbackSummaryLoading ? (
                  <Spin tip="Loading feedback summary..." />
                ) : feedbackSummary ? (
                  <Flex vertical gap="middle">
                    <Flex align="center" gap="middle">
                      <Rate allowHalf value={feedbackSummary.averageRating} disabled />
                      <Typography.Text>
                        {feedbackSummary.averageRating.toFixed(1)}/5 ({feedbackSummary.totalFeedbacks} reviews)
                      </Typography.Text>
                    </Flex>
                    <Flex vertical gap="small">
                      {/* Hiển thị rating distribution */}
                      <Flex justify="space-between">
                        <Text>5 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["5"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>4 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["4"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>3 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["3"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>2 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["2"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>1 star:</Text>
                        <Text>{feedbackSummary.ratingDistribution["1"] || 0} feedbacks</Text>
                      </Flex>
                    </Flex>
                    <Button type="primary" size="small" >
                      <Link to={`/feedbacks/events/${eventId}`}>View All Feedbacks</Link>
                    </Button>
                  </Flex>
                ) : (
                  <Alert message="No feedback summary available for this event yet." type="info" showIcon />
                )}

              </Card>
            </Col>
          )}
          {eventDetails?.status === 'FINISHED' && (
            <Col span={24}>
              <Card title="Participants Check-in/Check-out List"
                extra={<Button icon={<DownloadOutlined />} onClick={handleDownloadPdf} loading={loading}>
                  Download PDF
                </Button>}
              >
                <EventParticipantsTable eventId={id || ''} />
              </Card>
            </Col>
          )}
          <Col span={24}>
            <EventDiscussion
              eventId={id || ''}
              questions={questions}
              setQuestions={setQuestions}
            />
          </Col>
        </Row>
      </Card>
    </div>
  );
};

export default EventDetailsPage;


src\pages\details\MyEventPage.tsx:
// src\pages\details\MyEventPage.tsx
import React, { useEffect, useState, useCallback } from 'react';
import { useParams, useNavigate, Link, useOutletContext, useSearchParams } from 'react-router-dom';
import {
  Alert,
  Button,
  Card,
  Col,
  Descriptions,
  Flex,
  Image,
  List,
  message,
  Row,
  Space,
  Table,
  Tag,
  Typography,
  Checkbox,
  Rate,
  Spin,
} from 'antd';
import { HomeOutlined, PieChartOutlined, UserAddOutlined, DownloadOutlined, QuestionOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { PageHeader, Loader, UserAvatar, BackBtn } from '../../components';
import { useFetchData } from '../../hooks';
import dayjs from 'dayjs';
import authService from '../../services/authService';
import { Events, TicketType, User } from '../../types';
import { EventParticipantsTable } from '../dashboards/EventParticipantsTable';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { Helmet } from 'react-helmet-async';
import { EventScheduleItem } from '../../types/schedule';
import TicketDetailsModal from '../../components/TicketDetailsModal';
import InviteUsersModal from '../../components/InviteUsersModal';
import { useDispatch } from 'react-redux';
import EventDiscussion from '../../components/EventDiscussion';

const { Title, Text, Paragraph } = Typography;

export interface ParticipantData {
  id: string;
  name: string;
  email: string;
  phoneNumber: string;
  checkInAt: string | null;
  checkOutAt: string | null;
}


const DetailMyEventPage: React.FC = () => {
  const { id: eventId } = useParams<{ id: string }>(); // Corrected: Use 'id' and rename to 'eventId'
  const [eventDetails, setEventDetails] = useState<Events | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const [selectedSessionIds, setSelectedSessionIds] = useState<string[]>([]);
  const [isTicketModalVisible, setIsTicketModalVisible] = useState(false);
  const [ticketData, setTicketData] = useState<TicketType | null>(null); // Declare ticketData here
  const [isInviteModalVisible, setIsInviteModalVisible] = useState(false);
  const dispatch = useDispatch();
  const [questions, setQuestions] = useState<any[]>([]);
  const [feedbackSummaryLoading, setFeedbackSummaryLoading] = useState(false);
  const [feedbackSummary, setFeedbackSummary] = useState<{
    averageRating: number;
    totalFeedbacks: number;
    ratingDistribution: Record<string, number>;
  } | null>(null);

  useEffect(() => {
    const fetchEventDetails = async () => {
      setLoading(true);
      setError(null);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventDetails(eventId, accessToken || undefined) as { statusCode: number; data: { event: Events }; message: string; error?: string };
        if (response && response.statusCode === 200) {
          setEventDetails(response.data.event);
        } else {
          setError(response?.error || 'Failed to load event details');
          message.error(response?.error);
        }
      } catch (error: any) {
        console.error('Error fetching event details:', error);
        setError(error.error || 'Failed to load event details');
        message.error(error.error);
      } finally {
        setLoading(false);
      }
    };

    const fetchEventFeedbackSummary = async () => { // Fetch feedback summary
      if (!eventId) return;
      setFeedbackSummaryLoading(true);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventFeedbackSummary(eventId, accessToken || undefined) as any;
        if (response.statusCode === 200 && response.data) {
          setFeedbackSummary(response.data);
        }
      } catch (error: any) {
        console.error('Error fetching feedback summary:', error);
      } finally {
        setFeedbackSummaryLoading(false);
      }
    };

    fetchEventDetails();
    eventDetails?.status === 'FINISHED' && fetchEventFeedbackSummary(); // Fetch feedback only if event finished
  }, [eventId, navigate, eventDetails?.status]); // Fetch feedback summary when event status changes to finished


  const handleDownloadPdf = handleDownloadPdfFunction(setLoading, message, authService, dayjs, eventId);

  const onSessionSelectChange = (selectedKeys: React.Key[]) => {
    setSelectedSessionIds(selectedKeys as string[]);
  };

  const scheduleColumns = getScheduleColumns();

  const hideTicketModal = () => {
    setIsTicketModalVisible(false);
  };
  const showInviteModal = () => {
    setIsInviteModalVisible(true);
  };

  const hideInviteModal = () => {
    setIsInviteModalVisible(false);
  };


  const handleUpdateSessionsForTicket = handleUpdateSessionsForTicketFunction(setLoading, message, navigate, localStorage, authService, setIsTicketModalVisible, setTicketData, ticketData);


  return (
    <div>
      <Helmet>
        <title>Details | Dashboard</title>
      </Helmet>
      <PageHeader
        title="Event Details"
        breadcrumbs={breadcrumbs}
        btnBack={<BackBtn />}
      />
      <BackBtn />

      <Card title={<Title level={3}>{eventDetails?.name}</Title>}
        extra={
          <Space>
            {eventDetails?.status === 'SCHEDULED' && (
            <><Button type="primary" icon={<UserAddOutlined />} onClick={showInviteModal}>Invite Users</Button><Button
                type="primary"
                onClick={() => navigate(`/dashboards/check-in-out/${eventId}`)} // Navigate to QR scanner page
              >
                Check-in/Check-out
              </Button></>
            )}
          </Space>
        }
      >
        <Row gutter={[16, 16]}>
          <Col span={24}>
            {renderEventIntroduction(eventDetails)}
          </Col>
          <Col span={24}>
            <Card title="Schedule">
              {renderScheduleTable(eventDetails, scheduleColumns)}
            </Card>
          </Col>
          {renderEventDocuments(eventDetails)}
          {eventDetails?.status === 'FINISHED' && (
            <Col span={24} >
              <Card title="Feedback Summary">
                {renderFeedbackSummary(feedbackSummaryLoading, feedbackSummary, eventId)}
              </Card>
            </Col>
          )}
          <Col span={24}>
            <Card title="Participants Check-in/Check-out List"
              extra={<Button icon={<DownloadOutlined />} onClick={handleDownloadPdf} loading={loading}>
                Download PDF
              </Button>}
            >
              <EventParticipantsTable eventId={eventId || ''} />
            </Card>
          </Col>

          <Col span={24}>
            <EventDiscussion
              eventId={eventId || ''}
              questions={questions}
              setQuestions={setQuestions}
            />
          </Col>
        </Row>
      </Card>
      <InviteUsersModal
        visible={isInviteModalVisible}
        onCancel={hideInviteModal}
        eventId={eventId || ''}
        onInvitationsSent={() => { }} // Example callback
      />
      <TicketDetailsModal
        visible={isTicketModalVisible}
        onCancel={hideTicketModal}
        ticket={ticketData}
      />
    </div>
  );
};


export default DetailMyEventPage;


// Các hàm helper để render UI và xử lý logic (giữ code sạch hơn trong component chính)
const handleDownloadPdfFunction = (setLoading: React.Dispatch<React.SetStateAction<boolean>>, message: any, authService: any, dayjs: any, eventId: string | undefined) => async () => {
  try {
    setLoading(true);
    const accessToken = localStorage.getItem('accessToken');
    if (!accessToken) {
      message.error("No access token found. Please login again.");
      return;
    }
    // Gọi API lấy danh sách participant
    const response = await authService.getEventParticipants(eventId, accessToken) as any;
    const participants = response.data || [];
    if (!participants || participants.length === 0) {
      message.error("No participants data available.");
      return;
    }

    // Khởi tạo jsPDF
    const doc = new jsPDF();
    // Tiêu đề của PDF
    doc.setFontSize(16);
    doc.text("Participants Check-in/Check-out List", 14, 20);

    // Định nghĩa cột và dữ liệu của bảng
    const columns = ["No", "Name", "Email", "Check-In", "Check-Out"];
    const rows = participants.map((p: any, index: number) => [
      index + 1,
      p.name,
      p.email,
      p.checkInAt ? dayjs(p.checkInAt).format("YYYY-MM-DD HH:mm:ss") : "",
      p.checkOutAt ? dayjs(p.checkOutAt).format("YYYY-MM-DD HH:mm:ss") : ""
    ]);

    // Dùng autoTable để tạo bảng
    (doc as any).autoTable({
      head: [columns],
      body: rows,
      startY: 30,
      theme: 'grid'
    });

    // Lưu file PDF
    doc.save("participants.pdf");
  } catch (error: any) {
    console.error("Error generating PDF:", error);
    message.error("List check-in/check-out is empty.");
  } finally {
    setLoading(false);
  }
};

const handleUpdateSessionsForTicketFunction = (setLoading: React.Dispatch<React.SetStateAction<boolean>>, message: any, navigate: any, localStorage: any, authService: any, setIsTicketModalVisible: React.Dispatch<React.SetStateAction<boolean>>, setTicketData: React.Dispatch<React.SetStateAction<TicketType | null>>, ticketData: TicketType | null) => async (sessionIds: string[]) => {
  setLoading(true);
  try {
    const accessToken = localStorage.getItem('accessToken');
    if (!accessToken) {
      message.error("No access token found. Please login again.");
      navigate('/auth/signin');
      return;
    }

    const response = await authService.updateParticipantSessions(ticketData?.participantId, { sessionIds }, accessToken) as any;
    if (response && response.statusCode === 200) {
      message.success(response.message || 'Sessions updated successfully');
      setIsTicketModalVisible(false);
    } else {
      message.error(response.message || 'Failed to update sessions');
    }
  } catch (error: any) {
    console.error('Error updating sessions:', error);
    message.error(error.message || 'Failed to update sessions');
  } finally {
    setLoading(false);
  }
};

const renderEventIntroduction = (eventDetails: Events | null) => {
  if (eventDetails?.videoIntro) {
    return (
      <Card title="Video Introduction">
        <iframe
          width="100%"
          height="480"
          src={eventDetails.videoIntro}
          title="Event Introduction Video"
          frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          allowFullScreen
        />
      </Card>
    );
  } else if (eventDetails?.banner) {
    return (
      <Card title="Event Banner">
        <Image
          src={eventDetails.banner}
          alt="Event Banner"
          style={{ width: "100%", height: "480px", objectFit: "cover" }}
        />
      </Card>
    );
  } else {
    return (
      <Card title="Event Introduction">
        <iframe
          width="100%"
          height="480"
          src="https://www.youtube.com/embed/iTJJC2Hlmu0"
          title="Event Introduction Video"
          frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          allowFullScreen
        />
      </Card>
    );
  }
};

const renderScheduleTable = (eventDetails: Events | null, scheduleColumns: any) => {
  return eventDetails?.schedule && eventDetails.schedule.length > 0 ? (
    <Table
      rowKey="id"
      dataSource={eventDetails.schedule}
      columns={scheduleColumns}
      pagination={false}
    />
  ) : (
    <Alert message="No schedule available for this event." type="info" showIcon />
  );
};

const renderEventDocuments = (eventDetails: Events | null) => {
  return eventDetails?.documents && eventDetails.documents.length > 0 ? (
    <Col span={24}>
      <Card title="Event Documents">
        <List
          dataSource={eventDetails?.documents}
          renderItem={item => (
            <List.Item>
              <Typography.Link href={item} target="_blank">
                {item}
              </Typography.Link>
            </List.Item>
          )}
        />
      </Card>
    </Col>
  ) : null;
};
const renderFeedbackSummary = (feedbackSummaryLoading: boolean, feedbackSummary: { averageRating: number; totalFeedbacks: number; ratingDistribution: Record<string, number>; } | null, eventId: string | undefined) => {
  return feedbackSummaryLoading ? (
    <Spin tip="Loading feedback summary..." />
  ) : feedbackSummary ? (
    <Flex vertical gap="middle">
      <Flex align="center" gap="middle">
        <Rate allowHalf value={feedbackSummary.averageRating} disabled />
        <Typography.Text>
          {feedbackSummary.averageRating.toFixed(1)}/5 ({feedbackSummary.totalFeedbacks} reviews)
        </Typography.Text>
      </Flex>
      <Flex vertical gap="small">
        {/* Hiển thị rating distribution */}
        {feedbackSummary.ratingDistribution && ( // Thêm kiểm tra ratingDistribution tồn tại
          <>
            <Flex justify="space-between">
              <Text>5 stars:</Text>
              <Text>{feedbackSummary.ratingDistribution["5.0"] || 0} feedbacks</Text>
            </Flex>
            <Flex justify="space-between">
              <Text>4 stars:</Text>
              <Text>{feedbackSummary.ratingDistribution["4"] || 0} feedbacks</Text>
            </Flex>
            <Flex justify="space-between">
              <Text>3 stars:</Text>
              <Text>{feedbackSummary.ratingDistribution["3"] || 0} feedbacks</Text>
            </Flex>
            <Flex justify="space-between">
              <Text>2 stars:</Text>
              <Text>{feedbackSummary.ratingDistribution["2"] || 0} feedbacks</Text>
            </Flex>
            <Flex justify="space-between">
              <Text>1 star:</Text>
              <Text>{feedbackSummary.ratingDistribution["1"] || 0} feedbacks</Text>
            </Flex>
          </>
        )}
      </Flex>
      <Button type="primary" size="small" >
        <Link to={`/feedbacks/events/${eventId}`}>View All Feedbacks</Link>
      </Button>
    </Flex>
  ) : (
    <Alert message="No feedback summary available for this event yet." type="info" showIcon />
  );
};


const breadcrumbs = [
  {
    title: (
      <>
        <HomeOutlined />
        <span>Home</span>
      </>
    ),
    path: '/',
  },
  {
    title: (
      <>
        <PieChartOutlined />
        <span>Dashboards</span>
      </>
    ),
    menu: {
      items: DASHBOARD_ITEMS.map((d) => ({
        key: d.title,
        title: <Link to={d.path}>{d.title}</Link>,
      })),
    },
  },
  {
    title: 'My Event Details', // Đổi breadcrumb title
  },
];

const getScheduleColumns = () => {
  return [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title'
    },
    {
      title: 'Start Time',
      dataIndex: 'startTime',
      key: 'startTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'End Time',
      dataIndex: 'endTime',
      key: 'endTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description'
    },
  ];
};


src\pages\details\ParticipatedEventDetailsPage.tsx:
// src\pages\details\ParticipatedEventDetailsPage.tsx
import React, { useEffect, useState, useCallback } from 'react';
import { useParams, useNavigate, Link, useOutletContext } from 'react-router-dom';
import {
  Alert,
  Button,
  Card,
  Col,
  Descriptions,
  Flex,
  Image,
  List,
  message,
  Row,
  Space,
  Table,
  Tag,
  Typography,
  Checkbox,
  Spin,
  Rate,
} from 'antd';
import { HomeOutlined, PieChartOutlined, UserAddOutlined, DownloadOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { PageHeader, Loader, BackBtn } from '../../components';
import { useFetchData } from '../../hooks';
import dayjs from 'dayjs';
import authService from '../../services/authService';
import { Events, TicketType } from '../../types';
import { EventParticipantsTable } from '../dashboards/EventParticipantsTable';
import { Helmet } from 'react-helmet-async';
import { EventScheduleItem } from '../../types/schedule';
import jsPDF from 'jspdf';
import { CheckboxValueType } from 'antd/es/checkbox/Group';
import TicketDetailsModal from '../../components/TicketDetailsModal';
import EventDiscussion from '../../components/EventDiscussion';

const { Title, Text, Paragraph } = Typography;

const ParticipatedEventDetailsPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const [eventDetails, setEventDetails] = useState<Events | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const [ticketData, setTicketData] = useState<TicketType | null>(null);
  const [questions, setQuestions] = useState<any[]>([]);
  const [selectedSessionIds, setSelectedSessionIds] = useState<string[]>([]); // State quản lý sessions đã chọn
  const [participation, setParticipation] = useState<any | null>(null); // State lưu thông tin participation
  const [updatingSessions, setUpdatingSessions] = useState<boolean>(false); // State loading cho update session
  const [isTicketModalVisible, setIsTicketModalVisible] = useState<boolean>(false); // State for ticket modal visibility
  const { eventId } = useOutletContext<{ eventId: string }>();
  const [feedbackSummaryLoading, setFeedbackSummaryLoading] = useState(false);
  const [feedbackSummary, setFeedbackSummary] = useState<{
    averageRating: number;
    totalFeedbacks: number;
    ratingDistribution: Record<string, number>;
  } | null>(null);

  useEffect(() => {
    const fetchEventDetailsAndParticipation = async () => {
      setLoading(true);
      setError(null);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const eventResponse = await authService.getEventDetails(id, accessToken || undefined) as { statusCode: number; data: { event: Events }; message: string; error?: string };
        if (eventResponse && eventResponse.statusCode === 200) {
          setEventDetails(eventResponse.data.event);

          const participationResponse = await authService.getParticipantData(id, accessToken || undefined) as any;
          if (participationResponse && participationResponse.statusCode === 200 && participationResponse.data.participation) {
            setParticipation(participationResponse.data.participation);
            setSelectedSessionIds(participationResponse.data.participation.sessionIds || []); // Khởi tạo selectedSessionIds từ participation data
          }
        } else {
          setError(eventResponse?.error || 'Failed to load event details');
          message.error(eventResponse?.error);
        }
      } catch (error: any) {
        console.error('Error fetching event details and participation:', error);
        setError(error.error);
        message.error(error.error);
      } finally {
        setLoading(false);
      }
    };

    fetchEventDetailsAndParticipation();
  }, [id, navigate]);

  const handleDownloadPdf = async () => { /* ... Giữ nguyên hàm handleDownloadPdf ... */ };


  const scheduleColumns = [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title'
    },
    {
      title: 'Start Time',
      dataIndex: 'startTime',
      key: 'startTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'End Time',
      dataIndex: 'endTime',
      key: 'endTime',
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss')
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description'
    },
    {
      title: 'Select Session',
      key: 'select',
      render: (_: any, record: EventScheduleItem) => (
        <Checkbox
          value={record.id}
          checked={selectedSessionIds.includes(record.id)} // Kiểm tra xem session ID có trong selectedSessionIds không
          onChange={(e) => handleSessionCheckboxChange(e.target.checked, record.id)}
        />
      ),
    }
  ];


  const handleUpdateSessions = async () => {
    setUpdatingSessions(true); // Set loading state cho button update session
    setError(null);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        navigate('/auth/signin');
        return;
      }

      const response = await authService.updateParticipantSessions(eventDetails!.id, { sessionIds: selectedSessionIds }, accessToken) as any;
      if (response && response.statusCode === 200) {
        message.success(response.message || 'Sessions updated successfully');
        setParticipation({ ...participation, sessionIds: selectedSessionIds });
      } else {
        message.error(response.message || 'Failed to update sessions');
      }
    } catch (error: any) {
      console.error('Error updating sessions:', error);
      message.error(error.message || 'Failed to update sessions');
    } finally {
      setUpdatingSessions(false); // Reset loading state
    }
  };

  const handleSessionCheckboxChange = (checked: boolean, sessionId: string) => {
    if (checked) {
      setSelectedSessionIds([...selectedSessionIds, sessionId]);
    } else {
      setSelectedSessionIds(selectedSessionIds.filter(id => id !== sessionId));
    }
  };

  const showTicketModal = async () => {
    setIsTicketModalVisible(true);
    setLoading(true);
    setError(null);
    try {
      if (!eventDetails?.id) {
        message.error("Missing user or event information.");
        return;
      }

      const participantIdResponse = await authService.getParticipantIdByUserIdEventId(eventDetails.id, localStorage.getItem('accessToken') || undefined) as any;
      const participantId = participantIdResponse.data.participantId;

      const response = await authService.getTicketByParticipantId(participantId, localStorage.getItem('accessToken') || undefined) as { statusCode: number; data: { ticket: TicketType }; message: string, error?: string };
      if (response && response.statusCode === 200 && response.data.ticket) {
        setTicketData(response.data.ticket);
      } else {
        setError(response?.error || 'Failed to load ticket details');
        message.error(response?.error || 'Failed to load ticket details');
        setTicketData(null);
      }
    } catch (error: any) {
      console.error('Error fetching ticket details:', error);
      setError(error.error || 'Failed to load ticket details');
      message.error(error.error || 'Failed to load ticket details');
      setTicketData(null);
    } finally {
      setLoading(false);
    }
  };

  const hideTicketModal = () => {
    setIsTicketModalVisible(false);
  };



  return (
    <div>
      <Helmet>
        <title>Event Details</title>
      </Helmet>
      <PageHeader
        title="Event Details"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Participated Event Details',
          },
        ]}
        btnBack={<BackBtn />}
      />
      <BackBtn />

      <Card title={<Title level={3}>{eventDetails?.name}</Title>}
        extra={
          <Space>
            <Button type="primary" onClick={showTicketModal} >
              View Ticket
            </Button>
            <Button type="primary" onClick={handleUpdateSessions} loading={updatingSessions}>
              Update Sessions
            </Button>
          </Space>
        }
      >
        <Row gutter={[16, 16]}>
          <Col span={24}>
            {eventDetails?.videoIntro ? (
              // Nếu có video, hiển thị video
              <Card title="Video Introduction">
                <iframe
                  width="100%"
                  height="480"
                  src={eventDetails.videoIntro}
                  title="Event Introduction Video"
                  frameBorder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowFullScreen
                />
              </Card>
            ) : eventDetails?.banner ? (
              // Nếu không có video mà có banner, hiển thị banner dưới dạng hình ảnh
              <Card title="Event Banner">
                <img
                  src={eventDetails.banner}
                  alt="Event Banner"
                  style={{ width: "100%", height: "480px", objectFit: "cover" }}
                />
              </Card>
            ) : (
              // Nếu không có cả video lẫn banner, hiển thị link mặc định mà bạn để sẵn
              <Card title="Event Introduction">
                <iframe
                  width="100%"
                  height="480"
                  src="https://www.youtube.com/embed/iTJJC2Hlmu0"
                  title="Event Introduction Video"
                  frameBorder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowFullScreen
                />
              </Card>
            )}
          </Col>

          <Col span={24}>
            <Card title="Schedule">
              {eventDetails?.schedule && eventDetails.schedule.length > 0 ? (
                <Table
                  rowKey="id"
                  dataSource={eventDetails?.schedule}
                  columns={scheduleColumns}
                  pagination={false}
                />
              ) : (
                <Alert message="No schedule available for this event." type="info" showIcon />
              )}
            </Card>
          </Col>
          {eventDetails?.documents && eventDetails.documents.length > 0 && (
            <Col span={24}>
              <Card title="Event Documents">
                <List
                  dataSource={eventDetails?.documents}
                  renderItem={item => (
                    <List.Item>
                      <Typography.Link href={item} target="_blank">
                        {item}
                      </Typography.Link>
                    </List.Item>
                  )}
                />
              </Card>
            </Col>
          )}
          {eventDetails?.status === 'FINISHED' && (
            <Col span={24} >
              <Card title="Feedback Summary">
                {feedbackSummaryLoading ? (
                  <Spin tip="Loading feedback summary..." />
                ) : feedbackSummary ? (
                  <Flex vertical gap="middle">
                    <Flex align="center" gap="middle">
                      <Rate allowHalf value={feedbackSummary.averageRating} disabled />
                      <Typography.Text>
                        {feedbackSummary.averageRating.toFixed(1)}/5 ({feedbackSummary.totalFeedbacks} reviews)
                      </Typography.Text>
                    </Flex>
                    <Flex vertical gap="small">
                      {/* Hiển thị rating distribution */}
                      <Flex justify="space-between">
                        <Text>5 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["5"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>4 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["4"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>3 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["3"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>2 stars:</Text>
                        <Text>{feedbackSummary.ratingDistribution["2"] || 0} feedbacks</Text>
                      </Flex>
                      <Flex justify="space-between">
                        <Text>1 star:</Text>
                        <Text>{feedbackSummary.ratingDistribution["1"] || 0} feedbacks</Text>
                      </Flex>
                    </Flex>
                    <Button type="primary" size="small" >
                      <Link to={`/feedbacks/events/${eventId}`}>View All Feedbacks</Link>
                    </Button>
                  </Flex>
                ) : (
                  <Alert message="No feedback summary available for this event yet." type="info" showIcon />
                )}

              </Card>
            </Col>
          )}
          {eventDetails?.status === 'FINISHED' && (
            <Col span={24}>
              <Card title="Participants Check-in/Check-out List"
                extra={<Button icon={<DownloadOutlined />} onClick={handleDownloadPdf} loading={loading}>
                  Download PDF
                </Button>}
              >
                <EventParticipantsTable eventId={id || ''} />
              </Card>
            </Col>
          )}
          <Col span={24}>
            <EventDiscussion
              eventId={id || ''}
              questions={questions}
              setQuestions={setQuestions}
            />
          </Col>
        </Row>
      </Card>
      <TicketDetailsModal
        visible={isTicketModalVisible}
        onCancel={hideTicketModal}
        ticket={ticketData}
      />
    </div>
  );
};

export default ParticipatedEventDetailsPage;


src\pages\edit\EditEventPage.tsx:
// src\pages\edit\EditEventPage.tsx
import React, { useEffect, useState, useCallback } from 'react';
import {
  Alert,
  Button,
  Card,
  Col,
  DatePicker,
  Form,
  Input,
  InputNumber,
  Row,
  Select,
  Typography,
  message,
  Space
} from 'antd';
import { DASHBOARD_ITEMS, PATH_DASHBOARD } from '../../constants';
import { PageHeader, Loader } from '../../components';
import { Events } from '../../types';
import authService from '../../services/authService';
import dayjs from 'dayjs';
import { Helmet } from 'react-helmet-async';
import EventFileUploadForm from './EventFileUploadForm';
import axiosInstance from '../../api/axiosInstance';
import { Link, useNavigate, useParams } from 'react-router-dom';
import { HomeOutlined, PieChartOutlined, ArrowLeftOutlined, CloseOutlined, PlusOutlined, SaveOutlined } from '@ant-design/icons';
import CreateSpeakerModal from '../../components/CreateSpeakerModal';
import CreateGuestModal from '../../components/CreateGuestModal';

const EditEventPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const [eventDetails, setEventDetails] = useState<Events | null>(null);
  const [loading, setLoading] = useState(false);
  const [form] = Form.useForm();
  const navigate = useNavigate();
  const [error, setError] = useState<string | null>(null);
  const [speakersOptions, setSpeakersOptions] = useState<any>([]);
  const [guestsOptions, setGuestsOptions] = useState<any>([]);
  const [isCreateSpeakerModalVisible, setIsCreateSpeakerModalVisible] = useState(false);
  const [isCreateGuestModalVisible, setIsCreateGuestModalVisible] = useState(false);

  const fetchEventDetails = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const accessToken = localStorage.getItem('accessToken');
      const response = await authService.getEventDetails(id, accessToken || undefined) as { statusCode: number; data: { event: Events }; message: string, error?: string };
      if (response.statusCode === 200 && response.data.event) {
        setEventDetails(response.data.event);
        form.setFieldsValue({
          name: response.data.event.name,
          description: response.data.event.description,
          startDate: dayjs(response.data.event.startDate),
          endDate: dayjs(response.data.event.endDate),
          location: response.data.event.location,
          categoryId: response.data.event.categoryId,
          maxParticipants: response.data.event.maxParticipants,
          banner: response.data.event.banner,
          videoIntro: response.data.event.videoIntro,
          status: response.data.event.status,
          guestIds: response.data.event.guestIds,
          schedule: response.data.event.schedule?.map((session: any) => ({
            ...session,
            speakerIds: session.speakerIds,
            title: session.title, // Make sure to include title
            description: session.description, // Make sure to include description
            startTime: dayjs(session.startTime),
            endTime: dayjs(session.endTime),
          })) || [],
        });
      } else {
        setError(response?.error || 'Failed to load event details');
        message.error(response?.error);
      }
    } catch (error: any) {
      console.error('Error fetching event details:', error);
      setError(error.error);
      message.error(error.error);
    } finally {
      setLoading(false);
    }
  }, [id, form, navigate]);

  const fetchSpeakersOptions = useCallback(async () => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        navigate(PATH_DASHBOARD.my_events);
        return;
      }
      const response = await axiosInstance.get('/speakers', {
        headers: { Authorization: `Bearer ${accessToken}` }
      });

      const data = response.data as { statusCode: number; data: { speakers: any[] } };
      if (data.statusCode === 200) {
        const speakerList = data.data.speakers || [];
        setSpeakersOptions(
          speakerList.map((speaker: any) => ({
            value: speaker.id,
            label: speaker.name,
          }))
        );
      } else {
        setError("Failed to load speakers options.");
        message.error("Failed to load speakers options.");
      }
    } catch (error: any) {
      console.error("Failed to load speakers options:", error);
      setError("Failed to load speakers options.");
      message.error("Failed to load speakers options.");
    } finally {
      setLoading(false);
    }
  }, [navigate]);

  const fetchGuestsOptions = useCallback(async () => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        navigate(PATH_DASHBOARD.my_events);
        return;
      }
      const response = await axiosInstance.get('/guests', {
        headers: { Authorization: `Bearer ${accessToken}` }
      });

      const data = response.data as { statusCode: number; data: { guests: any[] } };
      if (data.statusCode === 200) {
        const guestList = data.data.guests || [];
        setGuestsOptions(
          guestList.map((guest: any) => ({
            value: guest.id,
            label: guest.name,
          }))
        );
      } else {
        setError("Failed to load guests options.");
        message.error("Failed to load guests options.");
      }
    } catch (error: any) {
      console.error("Failed to load guests options:", error);
      setError("Failed to load guests options.");
      message.error("Failed to load guests options.");
    } finally {
      setLoading(false);
    }
  }, [navigate]);


  useEffect(() => {
    fetchEventDetails();
    fetchSpeakersOptions();
    fetchGuestsOptions();
  }, [fetchEventDetails, fetchSpeakersOptions, fetchGuestsOptions]);


  const onFinish = async (values: any) => {
    setLoading(true);
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        message.error("No access token found. Please login again.");
        navigate('/auth/signin');
        return;
      }

      const eventData = {
        ...values,
        startDate: values.startDate.toISOString(),
        endDate: values.endDate.toISOString(),
        guestIds: values.guestIds || [],
        schedule: values.schedule?.map((session: any) => ({
          title: session.title, // Include title
          description: session.description, // Include description
          speakerIds: session.speakerIds || [], // Ensure speakerIds is always an array
          startTime: session.startTime.toISOString(),
          endTime: session.endTime.toISOString(),
        })) || [],
      };

      const response = await authService.updateEvent(id!, eventData, accessToken) as { statusCode: number; message: string; error?: string };
      if (response.statusCode === 200) {
        message.success(response.message);
        setTimeout(() => {
          navigate('/dashboards/my-events');
        }, 1000);
      } else {
        message.error(response.message || response.error || 'Failed to update event');
      }
    } catch (error: any) {
      message.error(error.message || error.error || 'Failed to update event');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  const handleCreateSpeaker = () => {
    setIsCreateSpeakerModalVisible(true);
  };

  const handleCancelCreateSpeakerModal = () => {
    setIsCreateSpeakerModalVisible(false);
  };

  const handleSpeakerCreated = (newSpeaker: any) => {
    setSpeakersOptions((prevOptions: { value: string; label: string }[]) => [...prevOptions, { value: newSpeaker.id, label: newSpeaker.name }]);
    form.setFieldsValue({ speakerIds: [...(form.getFieldValue('speakerIds') || []), newSpeaker.id] });
  };

  const handleCreateGuest = () => {
    setIsCreateGuestModalVisible(true);
  };

  const handleCancelCreateGuestModal = () => {
    setIsCreateGuestModalVisible(false);
  };

  const handleGuestCreated = (newGuest: any) => {
    setGuestsOptions((prevOptions: { value: string; label: string }[]) => [...prevOptions, { value: newGuest.id, label: newGuest.name }]);
    form.setFieldsValue({ guestIds: [...(form.getFieldValue('guestIds') || []), newGuest.id] });
  };


  if (loading && !eventDetails) {
    return <Loader />;
  }

  if (error) {
    return <Alert message="Error" description={error} type="error" showIcon />;
  }


  return (
    <div>
      <Helmet>
        <title>Edit Event | Dashboard</title>
      </Helmet>
      <PageHeader
        title="Edit Event"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Edit Event',
          },
        ]}
      />

      <Card title={`Edit Event: ${eventDetails?.name}`} extra={<Button onClick={() => navigate(-1)} icon={<ArrowLeftOutlined />}>Back</Button>}>
        <Form
          form={form}
          name="edit-event-form"
          layout="vertical"
          onFinish={onFinish}
          onFinishFailed={onFinishFailed}
          autoComplete="on"
          requiredMark={false}
        >
          <Row gutter={[16, 0]}>
            <Col sm={24} lg={24}>
              <Form.Item<any>
                label="Event's Name"
                name="name"
                rules={[{ required: true, message: 'Please input your event name!' }]}
              >
                <Input placeholder='Tech Conference 2026' />
              </Form.Item>
            </Col>
            <Col sm={24} lg={24}>
              <Form.Item<any>
                label="Event's Description"
                name="description"
                rules={[{ required: false }]}
              >
                <Input.TextArea rows={3} placeholder='A major event about technology and innovation (optional)' />
              </Form.Item>
            </Col>
            <Col sm={24} lg={8}>
              <Form.Item<any>
                label="Event's Capacity"
                name="maxParticipants"
                rules={[{ required: false, message: 'Please input event capacity!' }]}
              >
                <InputNumber style={{ width: "100%" }} min={0} placeholder="Unlimited if empty" />
              </Form.Item>
            </Col>
            <Col sm={24} lg={8}>
              <Form.Item<any>
                label="Start At"
                name="startDate"
                rules={[{ required: true, message: 'Please input your start of event' },]}
              >
                <DatePicker style={{ width: "100%" }} showTime format="YYYY-MM-DD HH:mm:ss" />
              </Form.Item>
            </Col>
            <Col sm={24} lg={8}>
              <Form.Item<any>
                label="End At"
                name="endDate"
                rules={[{ required: true, message: 'Please input your end of event' },]}
              >
                <DatePicker style={{ width: "100%" }} showTime format="YYYY-MM-DD HH:mm:ss" />
              </Form.Item>
            </Col>
            <Col sm={24} lg={12}>
              <Form.Item<any>
                label="Location"
                name="location"
                rules={[{ required: true, message: 'Please input event location!' }]}
              >
                <Input placeholder="Hall A, University Campus" />
              </Form.Item>
            </Col>
            <Col sm={24} lg={12}>
              <Form.Item<any>
                label="Event Type"
                name="categoryId"
                rules={[{ required: true, message: 'Please input your event type!' }]}
              >
                <Select
                  options={[
                    { value: '678a2141f8a1c0593de58562', label: 'IT' }, // Replace with actual categories from API later
                    { value: '676b9128c0ea46752f9a5c89', label: 'Technology' },
                  ]}
                  placeholder="Select Event Type"
                />
              </Form.Item>
            </Col>
            <Col sm={24} lg={12}>
              <Form.Item<any>
                label="Banner URL (Optional)"
                name="banner"
                rules={[{ required: false }]}
              >
                <Input placeholder="https://example.com/banner.jpg" />
              </Form.Item>
            </Col>
            <Col sm={24} lg={12}>
              <Form.Item<any>
                label="Video Intro URL (Optional)"
                name="videoIntro"
                rules={[{ required: false }]}
              >
                <Input placeholder="https://example.com/video.mp4" />
              </Form.Item>
            </Col>
            <Col span={24} lg={12}>
              <Form.Item<any>
                label="Status"
                name="status"
                rules={[{ required: true, message: 'Please select event status!' }]}
              >
                <Select
                  options={[
                    { value: 'SCHEDULED', label: 'Scheduled' },
                    { value: 'CANCELED', label: 'Canceled' },
                    { value: 'FINISHED', label: 'Finished' },
                  ]}
                  placeholder="Select Event Status"
                />
              </Form.Item>
            </Col>
            <Col span={24} lg={12}>
              <Form.Item<any>
                label="Guests"
                name="guestIds"
              >
                <Select
                  mode="multiple"
                  placeholder="Select Guests"
                  options={guestsOptions}
                  allowClear
                  dropdownRender={(menu) => (
                    <div>
                      {menu}
                      <Button type="text" onClick={handleCreateGuest} icon={<PlusOutlined />} style={{width: '100%', textAlign: 'left'}}>
                        Create New Guest
                      </Button>
                    </div>
                  )}
                />
              </Form.Item>
            </Col>

            <Col span={24}>
              <Form.List name="schedule" >
                {(fields, { add, remove }, { errors }) => (
                  <>
                    {fields.map(({ key, name, fieldKey, ...restField }) => (
                      <Space key={key} style={{ display: 'flex', marginBottom: 8 }} align="baseline">
                        <Form.Item
                          {...restField}
                          name={[name, 'title']}
                          fieldKey={[fieldKey || 0, 'title']}
                          rules={[{ required: true, message: 'Missing session title' }]}
                        >
                          <Input placeholder="Title" />
                        </Form.Item>
                        <Form.Item
                          {...restField}
                          name={[name, 'startTime']}
                          fieldKey={[fieldKey || 0, 'startTime']}
                          rules={[{ required: true, message: 'Missing start time' }]}
                        >
                          <DatePicker showTime format="YYYY-MM-DD HH:mm:ss" placeholder="Start Time" />
                        </Form.Item>
                        <Form.Item
                          {...restField}
                          name={[name, 'endTime']}
                          fieldKey={[fieldKey || 0, 'endTime']}
                          rules={[{ required: true, message: 'Missing end time' }]}
                        >
                          <DatePicker showTime format="YYYY-MM-DD HH:mm:ss" placeholder="End Time" />
                        </Form.Item>
                        <Form.Item
                          {...restField}
                          name={[name, 'description']}
                          fieldKey={[fieldKey || 0, 'description']}
                        >
                          <Input placeholder="Description" />
                        </Form.Item>
                        <Form.Item
                          {...restField}
                          name={[name, 'speakerIds']}
                          fieldKey={[fieldKey || 0, 'speakerIds']}
                          label="Speakers"
                        >
                          <Select
                            mode="multiple"
                            placeholder="Select Speakers"
                            options={speakersOptions}
                            allowClear
                            dropdownRender={(menu) => (
                              <div>
                                {menu}
                                <Button type="text" onClick={handleCreateSpeaker} icon={<PlusOutlined />} style={{width: '100%', textAlign: 'left'}}>
                                  Create New Speaker
                                </Button>
                              </div>
                            )}
                          />
                        </Form.Item>
                        <Button danger icon={<CloseOutlined />} onClick={() => remove(name)} />
                      </Space>
                    ))}
                    <Form.ErrorList errors={errors} />
                    <Form.Item>
                      <Button type="dashed" onClick={() => add()} block icon={<PlusOutlined />}>
                        Add Session
                      </Button>
                    </Form.Item>
                  </>
                )}
              </Form.List>
            </Col>
          </Row>

          <Form.Item>
            <Button type="primary" htmlType="submit" icon={<SaveOutlined />} loading={loading}>
              Save changes
            </Button>
          </Form.Item>
        </Form>
      </Card>

      <Card title="Upload Files" style={{ marginTop: 24 }}>
        <EventFileUploadForm eventId={id!} />
      </Card>

      <CreateSpeakerModal
        visible={isCreateSpeakerModalVisible}
        onCancel={handleCancelCreateSpeakerModal}
        onCreated={handleSpeakerCreated}
      />
      <CreateGuestModal
        visible={isCreateGuestModalVisible}
        onCancel={handleCancelCreateGuestModal}
        onCreated={handleGuestCreated}
      />
    </div>
  );
};

export default EditEventPage;


src\pages\edit\EventFileUploadForm.tsx:
// src\pages\edit\EventFileUploadForm.tsx
import React, { useState } from 'react';
import { Upload, Button, message, Alert, Select } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import axiosInstance from '../../api/axiosInstance';

interface EventFileUploadFormProps {
    eventId: string;
}

const EventFileUploadForm: React.FC<EventFileUploadFormProps> = ({ eventId }) => {
    const [uploadedFile, setUploadedFile] = useState<File | null>(null);
    const [uploading, setUploading] = useState<boolean>(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [selectedField, setSelectedField] = useState<string>('documents'); // Default to documents

    const handleFileChange = (info: any) => {
        if (info.fileList.length > 0) {
            setUploadedFile(info.fileList[0].originFileObj as File);
        } else {
            setUploadedFile(null);
        }
    };

    const handleUpload = async () => {
        if (!uploadedFile || !selectedField) {
            message.error('Please select a file and a field type');
            return;
        }

        setUploading(true);
        setUploadError(null);

        const formData = new FormData();
        formData.append('field', selectedField); // append field trước
        formData.append('files', uploadedFile);

        try {
            const response = await axiosInstance.post(`/events/${eventId}/files`, formData, {
                // Loại bỏ header Content-Type
                // headers: {
                //     'Content-Type': 'multipart/form-data',
                // },
            });
            message.success(`Uploaded ${selectedField} successfully`);
        } catch (error: any) {
            message.error(`${error.response?.data?.message || error.message}`);
            setUploadError(`Upload ${selectedField} failed: ${error.response?.data?.message || error.message}`);
        } finally {
            setUploading(false);
        }
    };


    const fieldOptions = [
        { value: 'videoIntro', label: 'Video Intro (MP4)', accept: '.mp4,video/mp4', multiple: false },
        { value: 'banner', label: 'Banner (Image)', accept: 'image/*', multiple: false },
        { value: 'documents', label: 'Documents (Multiple)', accept: '*', multiple: true },
    ];

    const currentFieldOption = fieldOptions.find(option => option.value === selectedField);

    return (
        <div>
            {uploadError && (
                <Alert
                    message="Upload Error"
                    description={uploadError}
                    type="error"
                    closable
                    onClose={() => setUploadError(null)}
                    style={{ marginBottom: 24 }}
                />
            )}

            <Select
                value={selectedField}
                onChange={setSelectedField}
                style={{ width: '100%', marginBottom: 16 }}
                placeholder="Select File Type to Upload"
                options={fieldOptions.map(option => ({ value: option.value, label: option.label }))}
            />

            <Upload
                beforeUpload={() => false}
                onChange={handleFileChange}
                maxCount={currentFieldOption?.multiple ? undefined : 1} // Allow multiple for documents
                accept={currentFieldOption?.accept}
                fileList={uploadedFile ? [{
                    uid: '1',
                    name: uploadedFile.name,
                    status: 'done',
                    url: URL.createObjectURL(uploadedFile), // Or a URL if you have one
                }] : []}
            >
                <Button icon={<UploadOutlined />} disabled={!selectedField} loading={uploading}>
                    Select File
                </Button>
            </Upload>

            <Button
                type="primary"
                onClick={handleUpload}
                disabled={uploading || !uploadedFile || !selectedField}
                loading={uploading}
                style={{ marginTop: 24 }}
            >
                Upload
            </Button>
        </div>
    );
};

export default EventFileUploadForm;


src\pages\errors\Error.tsx:
// src\pages\errors\Error.tsx
import { useRouteError } from 'react-router-dom';
import { Result, Typography } from 'antd';
import { BackBtn, RefreshBtn } from '../../components';

const { Paragraph, Text } = Typography;

type Error = unknown | any;

export const ErrorPage = () => {
  const error: Error = useRouteError();
  console.error(error);

  return (
    <Result
      status="error"
      title="Oops!"
      subTitle="Sorry, an unexpected error has occurred."
      extra={[<BackBtn key="back-btn" type="primary" />, <RefreshBtn key="refresh-btn" />]} // Added key props here
    >
      <div className="desc">
        <Paragraph>
          <Text
            strong
            style={{
              fontSize: 16,
            }}
          >
            The page you tried to open has the following error:
          </Text>
        </Paragraph>
        <Paragraph copyable>{error.statusText || error.message}</Paragraph>
      </div>
    </Result>
  );
};

src\pages\errors\Error400.tsx:
import { Result, Typography } from 'antd';
import { CloseCircleOutlined } from '@ant-design/icons';
import { red } from '@ant-design/colors';
import { BackBtn, RefreshBtn } from '../../components';

const { Paragraph, Text } = Typography;

export const Error400Page = () => {
  return (
    <Result
      status="error"
      title="400"
      subTitle="Bad request. The request could not be understood by the server due to malformed syntax. The client should not repeat the request without modifications"
      extra={[<BackBtn type="primary" />, <RefreshBtn />]}
    >
      <div className="desc">
        <Paragraph>
          <Text
            strong
            style={{
              fontSize: 16,
            }}
          >
            The content you submitted has the following error:
          </Text>
        </Paragraph>
        <Paragraph>
          <CloseCircleOutlined style={{ color: red[5] }} />
          &nbsp;Bad Request - Invalid URL &nbsp;<a>Forward error &gt;</a>
        </Paragraph>
        <Paragraph>
          <CloseCircleOutlined style={{ color: red[5] }} />
          &nbsp;Bad Request. Your browser sent a request that this server could
          not understand &nbsp;<a>Go to console &gt;</a>
        </Paragraph>
      </div>
    </Result>
  );
};


src\pages\errors\Error403.tsx:
import { Result } from 'antd';
import { BackBtn } from '../../components';

export const Error403Page = () => {
  return (
    <Result
      status="403"
      title="403"
      subTitle="Sorry, you are not authorized to access this page."
      extra={<BackBtn type="primary" />}
    />
  );
};


src\pages\errors\Error404.tsx:
import { Result } from 'antd';
import { BackBtn } from '../../components';

export const Error404Page = () => {
  return (
    <Result
      status="404"
      title="404"
      subTitle="Sorry, the page you visited does not exist."
      extra={<BackBtn type="primary" />}
    />
  );
};


src\pages\errors\Error500.tsx:
import { Result } from 'antd';
import { BackBtn, RefreshBtn } from '../../components';

export const Error500Page = () => {
  return (
    <Result
      status="500"
      title="500"
      subTitle="Sorry, something went wrong."
      extra={[<BackBtn type="primary" />, <RefreshBtn />]}
    />
  );
};


src\pages\errors\Error503.tsx:
import { Result } from 'antd';
import { BackBtn, RefreshBtn } from '../../components';

export const Error503Page = () => {
  return (
    <Result
      status="500"
      title="500"
      subTitle="Sorry, something went wrong."
      extra={[<BackBtn type="primary" />, <RefreshBtn />]}
    />
  );
};


src\pages\errors\index.ts:
export { ErrorPage } from './Error.tsx';
export { Error400Page } from './Error400.tsx';
export { Error403Page } from './Error403.tsx';
export { Error404Page } from './Error404.tsx';
export { Error500Page } from './Error500.tsx';
export { Error503Page } from './Error503.tsx';


src\pages\feedbacks\EventFeedbacksPage.tsx:
// src\pages\feedbacks\EventFeedbacksPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { Alert, Button, Card, List, Spin, Typography, Rate, message, Avatar } from 'antd';
import { HomeOutlined, PieChartOutlined, UserOutlined } from '@ant-design/icons';
import { DASHBOARD_ITEMS } from '../../constants';
import { PageHeader, BackBtn, Loader } from '../../components';
import { Helmet } from 'react-helmet-async';
import authService from '../../services/authService';

const { Title, Text, Paragraph } = Typography;

const EventFeedbacksPage: React.FC = () => {
  const { eventId } = useParams<{ eventId: string }>();
  const [feedbacks, setFeedbacks] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [userInfos, setUserInfos] = useState<Record<string, any>>({}); // State to store user info

  useEffect(() => {
    const fetchEventFeedbacks = async () => {
      setLoading(true);
      setError(null);
      try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await authService.getEventFeedbacks(eventId, accessToken || undefined) as any;
        console.log('Event feedbacks:', response);
        if (response.statusCode === 200 && response.data.feedbacks) {
          setFeedbacks(response.data.feedbacks);
          // Fetch user info for each feedback
          const userIds = response.data.feedbacks.map((feedback: any) => feedback.userId);
          fetchUsersInfo(userIds);
        } else {
          setError(response?.message || 'Failed to load event feedbacks');
          message.error(response?.message || 'Failed to load event feedbacks');
        }
      } catch (error: any) {
        console.error('Error fetching event feedbacks:', error);
        setError(error.message || 'Failed to load event feedbacks');
        message.error(error.message || 'Failed to load event feedbacks');
      } finally {
        setLoading(false);
      }
    };

    const fetchUsersInfo = async (userIds: string[]) => {
      const usersInfoMap: Record<string, any> = {};
      for (const userId of userIds) {
        try {
          const response = await authService.getUserById(userId) as any;
          if (response.statusCode === 200 && response.data) {
            usersInfoMap[userId] = response.data.data;
          }
        } catch (error) {
          console.error(`Error fetching user info for ${userId}`, error);
        }
      }
      setUserInfos(usersInfoMap);
    };

    fetchEventFeedbacks();
  }, [eventId]);

  return (
    <div>
      <Helmet>
        <title>Event Feedbacks</title>
      </Helmet>
      <PageHeader
        title="Event Feedbacks"
        breadcrumbs={[
          {
            title: (
              <>
                <HomeOutlined />
                <span>Home</span>
              </>
            ),
            path: '/',
          },
          {
            title: (
              <>
                <PieChartOutlined />
                <span>Dashboards</span>
              </>
            ),
            menu: {
              items: DASHBOARD_ITEMS.map((d) => ({
                key: d.title,
                title: <Link to={d.path}>{d.title}</Link>,
              })),
            },
          },
          {
            title: 'Event Feedbacks',
          },
        ]}
        btnBack={<BackBtn />}
      />

      <Card title={<Title level={3}>User Feedbacks for Event ID: {eventId}</Title>}>
        {error && (
          <Alert
            message="Error"
            description={error}
            type="error"
            showIcon
          />
        )}
        {loading ? (
          <Loader />
        ) : (
          <List
            itemLayout="vertical"
            dataSource={feedbacks}
            renderItem={(feedback) => (
              <List.Item>
                <List.Item.Meta
                  avatar={<Avatar src={userInfos[feedback.userId]?.avatar} icon={<UserOutlined />} />}
                  title={<Text strong>{userInfos[feedback.userId]?.name || 'Unknown User'}</Text>}
                  description={<Rate disabled allowHalf value={feedback.rating} />}
                />
                <Paragraph>{feedback.comment}</Paragraph>
              </List.Item>
            )}
          />
        )}
      </Card>
    </div>
  );
};

export default EventFeedbacksPage;


src\pages\userAccount\index.ts:
export { UserProfileSecurityPage } from './Security.tsx';


src\pages\userAccount\Information.tsx:
// src\pages\userAccount\Information.tsx
import React, { useEffect, useState } from 'react';
import {
  Alert,
  Button,
  Card,
  Checkbox,
  Col,
  DatePicker,
  Flex,
  Form,
  Input,
  Row,
  Select,
  Spin,
  message,
} from 'antd';
import { SaveOutlined, UploadOutlined, MinusCircleOutlined, PlusOutlined } from '@ant-design/icons';
import { useDispatch } from 'react-redux';
import { updateUserProfile } from '../../redux/userSlice';
import dayjs from 'dayjs';
import authService from '../../services/authService';

const SOCIALS = [
  'Facebook',
  'Instagram',
  'Twitter',
  'LinkedIn',
  'Mastodon',
  'Threads',
  'YouTube',
  'WhatsApp',
  'Tiktok',
  'Telegram',
  'QQ',
  'WeChat',
];

interface FieldType {
  name?: string;
  phoneNumber?: string;
  country?: string;
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  postalCode?: string;
  preferred?: boolean;
  dob?: dayjs.Dayjs;
  socialLinks?: { social?: string; username?: string }[];
}

type BirthdayFieldType = {
  dob?: string;
};

export const UserProfileInformationPage = () => {
  const [form] = Form.useForm<FieldType>();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const dispatch = useDispatch();

  useEffect(() => {
    const fetchUserProfile = async () => {
      setLoading(true);
      setError(null);
      try {
        const accessToken = localStorage.getItem('accessToken') || undefined;
        const response = await authService.getUserProfile(accessToken) as any;
        if (response.statusCode === 200 && response.data.user) {
          form.setFieldsValue({
            name: response.data.user.name,
            phoneNumber: response.data.user.phoneNumber,
            country: 'Kenya', // Giá trị mặc định, bạn có thể thay đổi hoặc lấy từ API nếu có
            addressLine1: '828, 18282 ABC Drive, XYZ Rd', // Giá trị mặc định
            city: 'Nairobi', // Giá trị mặc định
            postalCode: '00100', // Giá trị mặc định
            preferred: true, // Giá trị mặc định
            dob: dayjs('1996/04/27'), // Giá trị mặc định
            socialLinks: [], // Giá trị mặc định
          });
        } else {
          setError(response?.message || 'Failed to load user profile');
          message.error(response?.message || 'Failed to load user profile');
        }
      } catch (error: any) {
        setError(error.message || 'Failed to load user profile');
        message.error(error.message || 'Failed to load user profile');
      } finally {
        setLoading(false);
      }
    };

    fetchUserProfile();
  }, [form, dispatch]);

  const onFinish = async (values: FieldType) => {
    setLoading(true);
    setError(null);
    try {
      const accessToken = localStorage.getItem('accessToken') || '';
      // Chỉ gửi 2 field: name và phoneNumber
      const payload = {
        name: values.name,
        phoneNumber: values.phoneNumber,
      };
      const response = await authService.updateUserProfile(payload, accessToken) as any;
      if (response.statusCode === 200 && response.data.user) {
        message.success(response.message);
        dispatch(updateUserProfile({ name: response.data.user.name, phoneNumber: response.data.user.phoneNumber })); // Update Redux
        localStorage.setItem('user', JSON.stringify(response.data.user)); // Update localStorage
      } else {
        setError(response?.message || 'Failed to update user profile');
        message.error(response?.message || 'Failed to update user profile');
      }
    } catch (error: any) {
      setError(error.message || 'Failed to update user profile');
      message.error(error.message || 'Failed to update user profile');
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  return (
    <div>
      {error && (
        <Alert
          message="Error"
          description={error}
          type="error"
          showIcon
          closable
          onClose={() => setError(null)}
          style={{ marginBottom: 16 }}
        />
      )}

      <Card title="Personal Information">
        <Flex gap="large" vertical>
          <Form
            form={form}
            name="user-profile-info-form"
            layout="vertical"
            initialValues={{ remember: true }}
            onFinish={onFinish}
            onFinishFailed={onFinishFailed}
            autoComplete="off"
            requiredMark={false}
          >
            <Row gutter={[16, 0]}>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="Name"
                  name="name"
                  rules={[{ required: true, message: 'Please input your name!' }]}
                >
                  <Input placeholder="Your Name" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="Phone Number"
                  name="phoneNumber"
                  rules={[{ required: false }]}
                >
                  <Input placeholder="Your Phone Number (Optional)" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="Country"
                  name="country"
                  rules={[{ required: false, message: 'Please select your country or region!' }]}
                >
                  <Select options={[]} placeholder="Country" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="City"
                  name="city"
                  rules={[{ required: false, message: 'Please enter your city!' }]}
                >
                  <Input placeholder="City" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="Address line 1"
                  name="addressLine1"
                  rules={[{ required: false, message: 'Please enter your address line!' }]}
                >
                  <Input.TextArea placeholder="Address line 1" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={12}>
                <Form.Item<FieldType>
                  label="Address line 2"
                  name="addressLine2"
                  rules={[{ required: false, message: 'Please enter your address line!' }]}
                >
                  <Input.TextArea placeholder="Address line 2" />
                </Form.Item>
              </Col>
              <Col sm={24} lg={8}>
                <Form.Item<BirthdayFieldType>
                  label="Birth date"
                  name="dob"
                  rules={[{ required: false, message: 'Please select your birthday!' }]}
                >
                  <DatePicker style={{ width: '100%' }} />
                </Form.Item>
              </Col>
            </Row>

            <Form.Item>
              <Button type="primary" htmlType="submit" icon={<SaveOutlined />} loading={loading}>
                Save changes
              </Button>
            </Form.Item>
          </Form>
        </Flex>
      </Card>

      <Card title="Social links" style={{ marginTop: 24 }}>
        {/* Phần Social links vẫn hiển thị nhưng không ảnh hưởng đến patch update */}
        <Form
          name="user-profile-social-form"
          onFinish={onFinish}
          autoComplete="off"
        >
          <Form.List name="socialLinks">
            {(fields, { add, remove }) => (
              <>
                {fields.map(({ key, name, ...restField }) => (
                  <Flex
                    key={key}
                    align="baseline"
                    gap="small"
                    style={{ marginBottom: 8 }}
                  >
                    <Form.Item
                      {...restField}
                      name={[name, 'social']}
                      rules={[{ required: true, message: 'Missing social' }]}
                      style={{ width: 200 }}
                    >
                      <Select
                        placeholder="social"
                        options={SOCIALS.map((s) => ({ value: s, label: s }))}
                      />
                    </Form.Item>
                    <Form.Item
                      {...restField}
                      name={[name, 'username']}
                      rules={[{ required: true, message: 'Missing username' }]}
                    >
                      <Input placeholder="username" />
                    </Form.Item>
                    <Button
                      type="text"
                      icon={<MinusCircleOutlined />}
                      onClick={() => remove(name)}
                    ></Button>
                  </Flex>
                ))}
                <Form.Item>
                  <Button
                    type="dashed"
                    onClick={() => add()}
                    block
                    icon={<PlusOutlined />}
                  >
                    Add link
                  </Button>
                </Form.Item>
              </>
            )}
          </Form.List>
          <Form.Item>
            <Button type="primary" htmlType="submit" icon={<SaveOutlined />}>
              Save changes
            </Button>
          </Form.Item>
        </Form>
      </Card>
    </div>
  );
};


src\pages\userAccount\Security.tsx:
// src/pages/userAccount/Security.tsx
import {
  Alert,
  Button,
  Card,
  Col,
  Form,
  Input,
  Row,
  message,
} from 'antd';
import { SaveOutlined } from '@ant-design/icons';
import React, { useState } from 'react';
import authService from '../../services/authService';

type FieldType = {
  currentPassword?: string;
  newPassword?: string;
  confirmPassword?: string;
};

export const UserProfileSecurityPage = () => {
  const [form] = Form.useForm<FieldType>();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const onFinish = async (values: FieldType) => {
    if (values.newPassword !== values.confirmPassword) {
      message.error("New password and confirmation password do not match!");
      return;
    }

    setLoading(true);
    setError(null);
    try {
      // Nếu backend yêu cầu trường "id", bạn có thể lấy từ localStorage (nếu lưu dưới key "user")
      // const user = JSON.parse(localStorage.getItem("user") || "{}");
      // const passwordData = {
      //   id: user.id,
      //   currentPassword: values.currentPassword,
      //   newPassword: values.newPassword,
      // };

      // Nếu backend lấy userId từ accessToken thì chỉ cần 2 field:
      const passwordData = {
        currentPassword: values.currentPassword,
        newPassword: values.newPassword,
      };

      const accessToken = localStorage.getItem("accessToken");
      if (!accessToken) {
        message.error("Access token is missing.");
        setLoading(false);
        return;
      }
      const response = await authService.changePassword(passwordData, accessToken) as any;
      if (response.statusCode === 200) {
        message.success(response.message);
        form.resetFields();
      } else {
        setError(response?.error || "Failed to change password.");
        message.error(response?.error  || "Failed to change password.");
      }
    } catch (error: any) {
      setError(error.error || "Failed to change password.");
      message.error(error.error || "Failed to change password.");
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo: any) => {
    console.log('Failed:', errorInfo);
  };

  return (
    <Card title="Change your password">
      {error && (
        <Alert
          message="Error"
          description={error}
          type="error"
          showIcon
          closable
          onClose={() => setError(null)}
          style={{ marginBottom: 16 }}
        />
      )}
      <Form
        form={form}
        name="form-change-password"
        layout="vertical"
        onFinish={onFinish}
        onFinishFailed={onFinishFailed}
        autoComplete="off"
        requiredMark={false}
      >
        <Row gutter={[16, 0]}>
          <Col span={24}>
            <Form.Item<FieldType>
              label="Current password"
              name="currentPassword"
              rules={[{ required: true, message: 'Please input your current password!' }]}
            >
              <Input.Password />
            </Form.Item>
          </Col>
          <Col span={24}>
            <Form.Item<FieldType>
              label="New password"
              name="newPassword"
              rules={[
                { required: true, message: 'Please input your new password!' },
                { min: 6, message: 'Password must be at least 6 characters long!' },
              ]}
            >
              <Input.Password />
            </Form.Item>
          </Col>
          <Col span={24}>
            <Form.Item<FieldType>
              label="Confirm password"
              name="confirmPassword"
              dependencies={['newPassword']}
              rules={[
                { required: true, message: 'Please re-input your new password!' },
                ({ getFieldValue }) => ({
                  validator(_: any, value: string) {
                    if (!value || getFieldValue('newPassword') === value) {
                      return Promise.resolve();
                    }
                    return Promise.reject('The two passwords that you entered do not match!');
                  },
                }),
              ]}
            >
              <Input.Password />
            </Form.Item>
          </Col>
        </Row>
        <Form.Item>
          <Button type="primary" htmlType="submit" icon={<SaveOutlined />} loading={loading}>
            Save changes
          </Button>
        </Form.Item>
      </Form>
    </Card>
  );
};

src\routes\routes.tsx:
// src\routes\routes.tsx
// src\routes\routes.tsx
import { createBrowserRouter, useLocation, Navigate, RouteObject } from 'react-router-dom';
import {
  AccountDeactivePage,
  GeneralDashboardPage,
  Error400Page,
  Error403Page,
  Error404Page,
  Error500Page,
  Error503Page,
  ErrorPage,
  PasswordResetPage,
  ProjectsDashboardPage,
  SignInPage,
  SignUpPage,
  UserProfileSecurityPage,
  VerifyEmailPage,
  WelcomePage,
  CreateEventPage,
  MyEventDashboardPage,
  UserDashboardPage,
} from '../pages';
import DetailMyEventPage from '../pages/details/MyEventPage';
import {
  DashboardLayout,
  EventDetailLayout,
  // GuestLayout,
  UserAccountLayout,
} from '../layouts';
import React, { ReactNode, useEffect } from 'react';
import EventsDashboardPage from '../pages/dashboards/Events.tsx';
import EventsListPage from '../pages/dashboards/EventsList.tsx';
import EventDetailsPage from '../pages/details/EventDetailsPage.tsx';
import EditEventPage from '../pages/edit/EditEventPage.tsx';
import ParticipatedEventsPage from '../pages/dashboards/ParticipatedEvents.tsx';
import SpeakerGuestManagementPage from '../pages/dashboards/SpeakerManagementPage.tsx';
import ParticipatedEventDetailsPage from '../pages/details/ParticipatedEventDetailsPage.tsx';
import { UserProfileInformationPage } from '../pages/userAccount/Information.tsx';
import QRScannerPage from '../pages/QRScannerPage.tsx';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store.ts';
import ProtectedRoute from '../components/ProtectedRoute.tsx';
import { Helmet } from 'react-helmet-async';
import DeclineEventPage from '../pages/DeclineEventPage.tsx';
import EventFeedbacksPage from '../pages/feedbacks/EventFeedbacksPage.tsx';

export const ScrollToTop: React.FC = () => {
  const { pathname } = useLocation();
  useEffect(() => {
    window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
  }, [pathname]);
  return null;
};

type PageProps = {
  children: ReactNode;
};

const PageWrapper = ({ children }: PageProps) => (
  <>
    <ScrollToTop />
    {children}
  </>
);

const PrivateRoute = ({ children }: { children: React.ReactNode }): React.ReactNode => {
  const user = useSelector((state: RootState) => state.user);

  return user && user.id ? children : <Navigate to="/auth/signin" replace state={{ from: location.pathname + location.search }} />;
};

const RootRoute = () => {
  const user = useSelector((state: RootState) => state.user);
  return user && user.id ? <Navigate to="/dashboards/general" replace /> : <SignInPage />;
};


// Create the router
const router = createBrowserRouter([
  {
    path: '/',
    element: <PageWrapper children={<RootRoute />} />,
    errorElement: <Helmet><title>Error</title></Helmet>,
  },
  {
    path: '*',
    element: <Navigate to="/errors/404" replace />,
  },
  {
    path: '/details/events/:eventId/decline',
    element: <PageWrapper children={<DeclineEventPage />} />,
    errorElement: <Helmet><title>Error</title></Helmet>,
  },
  {
    path: '/feedbacks', // Route cho trang feedback riêng
    element: <PageWrapper children={<DashboardLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'events/:eventId',
        element: <PrivateRoute>
          <EventFeedbacksPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: '/create',
    element: <PageWrapper children={<DashboardLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        index: true,
        path: 'events',
        element: <PrivateRoute>
          <CreateEventPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: '/details',
    element: <PageWrapper children={<EventDetailLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        index: true,
        path: 'events/:id',
        element: <PrivateRoute>
          <EventDetailsPage />
        </PrivateRoute>,
      },
      {
        path: 'my-events/:id',
        element: <PrivateRoute>
          <DetailMyEventPage />
        </PrivateRoute>,
      },
      {
        path: 'participated-events/:id',
        element: <PrivateRoute>
          <ParticipatedEventDetailsPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: '/dashboards',
    element: <PageWrapper children={<DashboardLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        index: true,
        path: 'general',
        element: <PrivateRoute>
          <GeneralDashboardPage />
        </PrivateRoute>,
      },
      {
        path: 'check-in-out/:id', // New route for QR scanner
        element: <PrivateRoute>
          <QRScannerPage />
        </PrivateRoute>,
      },
      {
        path: 'speakers-guests',
        element: <PrivateRoute>
          <SpeakerGuestManagementPage />
        </PrivateRoute>,
      },
      {
        path: 'participated-events',
        element: <PrivateRoute>
          <ParticipatedEventsPage />
        </PrivateRoute>,
      },
      {
        path: 'projects',
        element: <PrivateRoute>
          <ProjectsDashboardPage />
        </PrivateRoute>,
      },
      {
        path: 'events',
        element: <PrivateRoute>
          <EventsDashboardPage />
        </PrivateRoute>,

      },
      {
        path: 'my-events',
        element: <PrivateRoute>
          <MyEventDashboardPage />
        </PrivateRoute>,
      },
      {
        path: 'users',
        element: <PrivateRoute>
          <UserDashboardPage />
        </PrivateRoute>,
      },
      {
        path: 'events-list',
        element: <PrivateRoute>
          <EventsListPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: '/user-profile',
    element: <PageWrapper children={<UserAccountLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'personal-information',
        element: <PrivateRoute>
          <UserProfileInformationPage />
        </PrivateRoute>,
      },
      {
        path: 'security',
        element: <PrivateRoute>
          <UserProfileSecurityPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: '/auth',
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'signup',
        element: <SignUpPage />,
      },
      {
        path: 'signin',
        element: <SignInPage />,
      },
      {
        path: 'welcome',
        element: <WelcomePage />,
      },
      {
        path: 'verify-email',
        element: <VerifyEmailPage />,
      },
      {
        path: 'password-reset',
        element: <PasswordResetPage />,
      },
      {
        path: 'account-delete',
        element: <AccountDeactivePage />,
      },
    ],
  },
  {
    path: '/edit',
    element: <PageWrapper children={<DashboardLayout />} />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'events/:id',
        element: <PrivateRoute>
          <EditEventPage />
        </PrivateRoute>,
      },
    ],
  },
  {
    path: 'errors',
    errorElement: <ErrorPage />,
    children: [
      {
        path: '400',
        element: <Error400Page />,
      },
      {
        path: '403',
        element: <Error403Page />,
      },
      {
        path: '404',
        element: <Error404Page />,
      },
      {
        path: '500',
        element: <Error500Page />,
      },
      {
        path: '503',
        element: <Error503Page />,
      },
    ],
  },
]);

export default router;


src\services\authService.ts:
// src\services\authService.ts
import axiosInstance from '../api/axiosInstance';

const BASE_URL = 'http://localhost:8080/api/v1';
const API_BASE_URL = `${BASE_URL}/auth`;
const API_EVENT_BASE_URL = `${BASE_URL}/events`;
const API_CATEGORY_BASE_URL = `${BASE_URL}/categories`;
const API_USERS_BASE_URL = `${BASE_URL}/users`;
const API_PARTICIPANTS_BASE_URL = `${BASE_URL}/participants`;
const API_TICKETS_BASE_URL = `${BASE_URL}/tickets`;
const API_REPORT_BASE_URL = `${BASE_URL}/reports`;

const authService = {
  login: async (credentials: any) => {
    try {
      const response = await axiosInstance.post(`${API_BASE_URL}/login`, credentials);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  register: async (userData: any) => {
    try {
      const response = await axiosInstance.post(`${API_BASE_URL}/register`, userData);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  createEvent: async (eventData: any, accessToken: string) => {
    try {
      const response = await axiosInstance.post(`${API_EVENT_BASE_URL}`, eventData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  logout: async (accessToken: string) => {
    try {
      const response = await axiosInstance.post(
        `${API_BASE_URL}/logout`,
        {},
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getCategories: async (accessToken: string) => {
    try {
      const response = await axiosInstance.get(`${API_CATEGORY_BASE_URL}`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  createCategory: async (categoryData: any, accessToken: string) => {
    try {
      const response = await axiosInstance.post(`${API_CATEGORY_BASE_URL}`, categoryData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getEventDetails: async (eventId: string | undefined, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  registerEvent: async (eventId: string, sessionIds: string[], accessToken: string) => {
    try {
      const response = await axiosInstance.post(
        `${API_PARTICIPANTS_BASE_URL}`, // Sử dụng endpoint cho participant registration
        { eventId, sessionIds },
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  deleteEvent: async (eventId: string, accessToken: string) => {
    try {
      const response = await axiosInstance.delete(`${API_EVENT_BASE_URL}/${eventId}`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  updateEvent: async (eventId: string, eventData: any, accessToken: string) => {
    try {
      const response = await axiosInstance.patch(`${API_EVENT_BASE_URL}/${eventId}`, eventData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getOrganizedEvents: async (status?: string, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      let url = `${API_EVENT_BASE_URL}/organized-events`;
      if (status) {
        url += `?status=${status}`;
      }
      const response = await axiosInstance.get(url, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  uploadEventFiles: async (
    eventId: string,
    field: string,
    formData: FormData,
    accessToken: string
  ) => {
    try {
      const response = await axiosInstance.post(
        `${API_EVENT_BASE_URL}/events/${eventId}/files`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            Authorization: `Bearer ${accessToken}`,
            field: field, // Truyền field vào header
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getEventParticipants: async (eventId: string | undefined, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/participants`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getParticipatedEvents: async (status?: string, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      let url = `${API_EVENT_BASE_URL}/participated-events`;
      if (status && status !== 'all') {
        url += `?status=${status}`;
      }
      const response = await axiosInstance.get(url, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  // Hàm update lại sessions của participant
  updateParticipantSessions: async (
    eventId: string,
    sessionsData: any,
    accessToken: string
  ) => {
    try {
      const response = await axiosInstance.patch(
        `${API_PARTICIPANTS_BASE_URL}/${eventId}`,
        sessionsData,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  googleLogin: async () => { // Hàm googleLogin cho Server-Side Flow
    try {
      const response = await axiosInstance.get(`${API_BASE_URL}/google/login`);
      const data = response.data as { url: string }; // Backend có thể trả về URL đăng nhập Google (tùy chọn)
      window.location.href = data.url; // Chuyển hướng trình duyệt đến trang đăng nhập Google (nếu backend trả về url)
      // Hoặc, nếu backend không trả về URL, bạn có thể chỉ cần:
      // window.location.href = `${API_BASE_URL}/google/login`; // Chuyển hướng trực tiếp đến endpoint login của backend
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getTicketByParticipantId: async (participantId: string, accessToken?: string) => { // Add getTicketByParticipantId function
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_PARTICIPANTS_BASE_URL}/${participantId}/tickets`, { headers }); // Use correct endpoint
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getParticipantIdByUserIdEventId: async (eventId: string, accessToken?: string) => { // Updated function - Removed userId parameter
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_PARTICIPANTS_BASE_URL}/event/${eventId}/participant-id`, { headers }); // Updated API call - Removed userId from URL
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getUsers: async (accessToken?: string) => { // Hàm mới: Lấy danh sách users
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${BASE_URL}/users`, { headers }); // Gọi API /users
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  inviteUsersToEvent: async (eventId: string, users: { id: string, email: string }[], accessToken?: string) => { // Hàm mới: Mời users vào event
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.post(`${API_EVENT_BASE_URL}/${eventId}/invite`, { users }, { headers }); // Gọi API /events/{eventId}/invite
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  forgotPassword: async (email: string) => { // Hàm forgotPassword mới
    try {
      const response = await axiosInstance.post(`${API_BASE_URL}/forgot-password`, { email });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getParticipantIdByEventId: async (eventId: string | undefined, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_PARTICIPANTS_BASE_URL}/event/${eventId}/participant-id`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  unregisterEvent: async (participantId: string, accessToken: string) => { // Updated function to take participantId
    try {
      const response = await axiosInstance.delete(`${API_PARTICIPANTS_BASE_URL}/${participantId}`, { // Use participantId directly
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  updateUserProfile: async (userData: any, accessToken: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${accessToken}`,
      };
      const response = await axiosInstance.patch(`${API_USERS_BASE_URL}/profile`, userData, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  uploadAvatar: async (formData: FormData, accessToken: string) => {
    try {
      const response = await axiosInstance.post(`${API_USERS_BASE_URL}/upload/avatar`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  changePassword: async (passwordData: any, accessToken: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${accessToken}`,
      };
      const response = await axiosInstance.post(`${API_BASE_URL}/change-password`, passwordData, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  getUserProfile: async (accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_USERS_BASE_URL}/profile`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  scanTicket: async (code: string) => {
    try {
      const response = await axiosInstance.get(`${API_TICKETS_BASE_URL}/scan?code=${code}`);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getCategoryById: async (categoryId: string | undefined, accessToken?: string) => {
    try {
      if (!categoryId) {
        throw new Error("Category ID is required to fetch category details.");
      }
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_CATEGORY_BASE_URL}/${categoryId}`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getEventCategoryDistribution: async () => {
    try {
      const response = await axiosInstance.get('/reports/event-category-distribution');
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getEventQuestions: async (eventId: string) => { // Hàm lấy danh sách câu hỏi
    try {
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/questions`);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  postQuestion: async (eventId: string, text: string, accessToken: string) => { // Hàm đăng câu hỏi
    try {
      const response = await axiosInstance.post(
        `${API_EVENT_BASE_URL}/${eventId}/questions`,
        { text },
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  postAnswer: async (questionId: string, text: string, accessToken: string) => { // Hàm đăng câu trả lời
    try {
      const response = await axiosInstance.post(
        `${API_EVENT_BASE_URL}/questions/${questionId}/answers`,
        { text },
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getUserById: async (userId: string) => { // Hàm mới: Lấy thông tin user theo ID
    try {
      const response = await axiosInstance.get(`${API_USERS_BASE_URL}/${userId}`);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getEventFeedbackByUser: async (eventId: string | undefined, accessToken?: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/feedback/user`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  postEventFeedback: async (eventId: string, feedbackData: any, accessToken: string) => {
    try {
      const response = await axiosInstance.post(`${API_EVENT_BASE_URL}/${eventId}/feedback`, feedbackData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  patchEventFeedback: async (eventId: string, feedbackData: any, accessToken: string) => {
    try {
      const response = await axiosInstance.patch(`${API_EVENT_BASE_URL}/${eventId}/feedback`, feedbackData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getParticipantData: async (eventId: string | undefined, accessToken?: string) => { // Add this function
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/participant`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  declineEvent: async (eventId: string, token: string) => {
    try {
      const response = await axiosInstance.get(`/events/${eventId}/decline?token=${token}`);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  acceptEvent: async (eventId: string, token: string) => {
    try {
      const response = await axiosInstance.get(`/events/${eventId}/accept?token=${token}`);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  createSpeaker: async (speakerData: any, accessToken: string) => { // Hàm createSpeaker mới
    try {
      const response = await axiosInstance.post(`${BASE_URL}/speakers`, speakerData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },

  createGuest: async (guestData: any, accessToken: string) => { // Hàm createGuest mới
    try {
      const response = await axiosInstance.post(`${BASE_URL}/guests`, guestData, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getOrganizerEventFeedbackSummary: async (accessToken: string) => {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_REPORT_BASE_URL}/organizer-feedback-summary`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getUserEventsByDateReport: async (year: number, month: number | undefined, accessToken: string) => { // Đổi tên hàm rõ ràng hơn
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      let url = `${API_REPORT_BASE_URL}/events-by-date?year=${year}`;
      if (month) {
        url += `&month=${month}`;
      }
      const response = await axiosInstance.get(url, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getEventFeedbackSummary: async (eventId: string | undefined, accessToken?: string) => { // Hàm mới: Lấy feedback summary
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/feedback-analysis`, { headers });
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
  getEventFeedbacks: async (eventId: string | undefined, accessToken?: string) => { // Hàm mới: Lấy danh sách feedbacks
    try {
      const headers: any = {
        'Content-Type': 'application/json',
      };
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
      // ** Sử dụng endpoint chính xác, dựa trên response mẫu của bạn **
      const response = await axiosInstance.get(`${API_EVENT_BASE_URL}/${eventId}/feedbacks`, { headers });
      console.log('Event feedbacks:', response);
      return response.data;
    } catch (error: any) {
      throw error.response.data;
    }
  },
};

export default authService;


